<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Giraph 运行流程（一）]]></title>
    <url>%2F2019%2F09%2F14%2FGiraph%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 本文主要分析了 Giraph1.3 SNAPSHOT 的 Job 提交和初始化的过程。其中 Job 提交部分的分析根据运行在 Standalone 模式下的 Hadoop 部分进行，分析仅涉及本地运行时执行的代码， 而初始化部分则主要根据集群模式进行分析。 示例 Job 该部分不属于源码，而是为了方便分析运行的一个示例 Job，Job 的具体配置和运行在 Giraph 编程实践及源码调试 一文中已经说明。通常情况下， Job 提交过程如下： 1234567891011121314151617181920GiraphConfiguration conf = new GiraphConfiguration(new Configuration());//指定计算类conf.setComputationClass(Shortestpath.class);//设置输入和输出格式conf.setVertexInputFormatClass(JsonLongDoubleFloatDoubleVertexInputFormat.class);conf.setVertexOutputFormatClass(IdWithValueTextOutputFormat.class);//设置本地运行模式，方便调试查看源码conf.setLocalTestMode(true);//设置 Worker 配置conf.setWorkerConfiguration(1, 1, 100);//本地模式下运行不分 Master 和 WorkerGiraphConstants.SPLIT_Master_Worker.set(conf, false);GiraphJob job = new GiraphJob(conf, Shortestpath.class.getSimpleName());//设置输入和输出路径GiraphTextInputFormat.setVertexInputPath(conf, new Path(INPUT_PATH));GiraphTextOutputFormat.setOutputPath(job.getInternalJob(), new Path(OUTPUT_PATH));••••••//向 Giraph 提交 Jobjob.run(true); 首先指定一系列参数，然后调用 job.run(true) 向 Giraph 提交 Job Giraph 向 Hadoop 提交 Job Giraph 是基于 Hadoop 开发的，因此在向 Giraph 提交 Job 之后，Giraph 内部还会向 Hadoop 提交 Job。本部分主要分析 Giraph 如何向 Hadoop 提交 Job。首先查看 run 方法： org.apache.giraph.job.GiraphJob#run 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * Runs the actual graph application through Hadoop Map-Reduce. * * @param verbose If true, provide verbose output, false otherwise * @return True if success, false otherwise * @throws ClassNotFoundException * @throws InterruptedException * @throws IOException */public final boolean run(boolean verbose) throws IOException, InterruptedException, ClassNotFoundException &#123; //更改 Job 的 counter 数量限制 setIntConfIfDefault("mapreduce.job.counters.limit", 512); //设置 Giraph 中 Worker 或者 Master 内存上限 setIntConfIfDefault("mapred.job.map.memory.mb", 1024); setIntConfIfDefault("mapred.job.reduce.memory.mb", 0); // Speculative execution doesn't make sense for Giraph giraphConfiguration.setBoolean( "mapred.map.tasks.speculative.execution", false); // Set the ping interval to 5 minutes instead of one minute Client.setPingInterval(giraphConfiguration, 60000 * 5); // 设置优先使用用户上传的 Jar 包的 class giraphConfiguration.setBoolean("mapreduce.user.classpath.first", true); giraphConfiguration.setBoolean("mapreduce.job.user.classpath.first", true); //不做 Checkpoint 的时候最大尝试数为 1，为了让不能恢复的 Job 更快的结束 if (giraphConfiguration.getCheckpointFrequency() == 0) &#123; int oldMaxTaskAttempts = giraphConfiguration.getMaxTaskAttempts(); giraphConfiguration.setMaxTaskAttempts(1); •••••• &#125; ImmutableClassesGiraphConfiguration conf = new ImmutableClassesGiraphConfiguration(giraphConfiguration); checkLocalJobRunnerConfiguration(conf); int tryCount = 0; //默认是 org.apache.giraph.job.DefaultGiraphJobRetryChecker GiraphJobRetryChecker retryChecker = conf.getJobRetryChecker(); while (true) &#123; •••••• tryCount++; //创建一个 Hadoop Job Job submittedJob = new Job(conf, jobName); if (submittedJob.getJar() == null) &#123; submittedJob.setJarByClass(getClass()); &#125; //Giraph 不需要执行 Reduce 任务 submittedJob.setNumReduceTasks(0); //设置 Mapper submittedJob.setMapperClass(GraphMapper.class); //设置输入格式 submittedJob.setInputFormatClass(BspInputFormat.class); //设置输出格式，默认情况是 org.apache.giraph.bsp.BspOutputFormat submittedJob.setOutputFormatClass( GiraphConstants.HADOOP_OUTPUT_FORMAT_CLASS.get(conf)); •••••• //提交 Job submittedJob.submit(); •••••• //获取 Job 运行结果 boolean passed = submittedJob.waitForCompletion(verbose); •••••• //如果运行失败则会尝试重启 Job if (!passed) &#123; //默认情况（指没有指定 JobRetryChecker 情况）返回 null，即永远不会重启 Job String restartFrom = retryChecker.shouldRestartCheckpoint(submittedJob); if (restartFrom != null) &#123; GiraphConstants.RESTART_JOB_ID.set(conf, restartFrom); continue; &#125; &#125; //如果 Job 运行成功或者失败情况下不尝试重新运行（默认情况下永远不会尝试尝试重新运行） if (passed || !retryChecker.shouldRetry(submittedJob, tryCount)) &#123; return passed; &#125; ••••••• &#125;&#125; run 方法中首先会对 Hadoop 和 Giraph 进行配置，然后创建一个 Hadoop Job 对象。在设置好 Hadoop Job 的 MapperClass 和输入输出格式等相关信息后，即会调用 submit 向 Hadoop 提交 Job。从代码中可以看到整个过程与提交普通的 Hadoop Job 基本无异。 Hadoop 内部运行 在 Giraph 调用 submit 向 Hadoop 提交 Job 之后，程序的运行就会进入到 Hadoop 内部，对于该部分主要需要了解 Hadoop 如何启动 Giraph 的 MapTask。 内部提交 Job org.apache.hadoop.mapreduce.Job#submit 1234567891011121314151617public void submit() throws IOException, InterruptedException, ClassNotFoundException &#123; ensureState(JobState.DEFINE); //设置用新的 API setUseNewAPI(); connect(); final JobSubmitter submitter = getJobSubmitter(cluster.getFileSystem(), cluster.getClient()); //提交 Job 到系统 status = ugi.doAs(new PrivilegedExceptionAction&lt;JobStatus&gt;() &#123; public JobStatus run() throws IOException, InterruptedException, ClassNotFoundException &#123; return submitter.submitJobInternal(Job.this, cluster); &#125; &#125;); state = JobState.RUNNING; ••••••&#125; submit 方法内部会创建 JobSubmitter 对象，然后通过 submitJobInternal 方法进一步提交 Job。 org.apache.hadoop.mapreduce.JobSubmitter#submitJobInternal 1234567891011121314151617181920212223242526JobStatus submitJobInternal(Job job, Cluster cluster) throws ClassNotFoundException, InterruptedException, IOException &#123; •••••• Configuration conf = job.getConfiguration(); addMRFrameworkToDistributedCache(conf); //获得暂存目录， 默认情况下路径生成在 /tmp/hadoop/mapred/staging 下 Path jobStagingArea = JobSubmissionFiles.getStagingDir(cluster, conf); •••••• //生成 Job ID JobID jobId = submitClient.getNewJobID(); //设置 Job ID job.setJobID(jobId); //获得提交 Job 的目录 Path submitJobDir = new Path(jobStagingArea, jobId.toString()); JobStatus status = null; •••••• •••••• //实际提交 Job status = submitClient.submitJob( jobId, submitJobDir.toString(), job.getCredentials()); ••••••&#125; 在 submitJobInternal 中，Hadoop 会通过 submitClient 实际提交 Job。submitClient 是一个 ClientProtocol 接口，其有两个实现，由于提交 Job 的时候 Hadoop 运行在 Standalone 模式下，所以这里 submitClient 的实现是 LocalJobRunner。 启动 MapTask org.apache.hadoop.mapred.LocalJobRunner#submitJob 1234567public org.apache.hadoop.mapreduce.JobStatus submitJob( org.apache.hadoop.mapreduce.JobID jobid, String jobSubmitDir, Credentials credentials) throws IOException &#123; Job job = new Job(JobID.downgrade(jobid), jobSubmitDir); job.job.setCredentials(credentials); return job.status;&#125; org.apache.hadoop.mapred.LocalJobRunner.Job#Job 12345public Job(JobID jobid, String jobSubmitDir) throws IOException &#123; •••••• this.start();&#125; submitJob 内部会创建一个 Job 对象，这里的 Job 是继承了 Thread 的 LocalJobRunner 的内部类。通过构造方法可以知道，submitJob 在创建 Job 的同时也开启了线程，所以需要查看 Job#run 方法。 org.apache.hadoop.mapred.LocalJobRunner.Job#run 1234567891011121314151617181920212223242526@Overridepublic void run() &#123; JobID jobId = profile.getJobID(); JobContext jContext = new JobContextImpl(job, jobId); •••••• Map&lt;TaskAttemptID, MapOutputFile&gt; mapOutputFiles = Collections.synchronizedMap(new HashMap&lt;TaskAttemptID, MapOutputFile&gt;()); //获取需要执行的任务 List&lt;RunnableWithThrowable&gt; mapRunnables = getMapTaskRunnables( taskSplitMetaInfos, jobId, mapOutputFiles); initCounters(mapRunnables.size(), numReduceTasks); ExecutorService mapService = createMapExecutor(); //运行任务 runTasks(mapRunnables, mapService, "map"); •••••• // delete the temporary directory in output directory outputCommitter.commitJob(jContext); status.setCleanupProgress(1.0f); ••••••&#125; org.apache.hadoop.mapred.LocalJobRunner.Job#getMapTaskRunnables 123456789101112131415protected List&lt;RunnableWithThrowable&gt; getMapTaskRunnables( TaskSplitMetaInfo [] taskInfo, JobID jobId, Map&lt;TaskAttemptID, MapOutputFile&gt; mapOutputFiles) &#123; int numTasks = 0; ArrayList&lt;RunnableWithThrowable&gt; list = new ArrayList&lt;RunnableWithThrowable&gt;(); //生成对应数量的 MapTaskRunnable for (TaskSplitMetaInfo task : taskInfo) &#123; list.add(new MapTaskRunnable(task, numTasks++, jobId, mapOutputFiles)); &#125; return list;&#125; org.apache.hadoop.mapred.LocalJobRunner.Job#runTasks 123456789101112131415161718192021private void runTasks(List&lt;RunnableWithThrowable&gt; runnables, ExecutorService service, String taskType) throws Exception &#123; //提交任务 for (Runnable r : runnables) &#123; service.submit(r); &#125; try &#123; service.shutdown(); // Instructs queue to drain. // Wait for tasks to finish; do not use a time-based timeout. // (See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6179024) LOG.info("Waiting for " + taskType + " tasks"); service.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS); &#125; catch (InterruptedException ie) &#123; // Cancel all threads. service.shutdownNow(); throw ie; &#125; ••••••&#125; 对于 Job#run 方法应该主要关注 MapTaskRunnable 的生成和执行，可以看到 Hadoop 会通过 getMapTaskRunnables 方法根据分配的 Task 的数量生成对应数量的 MapTaskRunnable，然后会调用 runTasks 方法向线程池提交任务。 MapTaskRunnable 任务提交到线程池后继续关注 MapTaskRunnable#run 方法 org.apache.hadoop.mapred.LocalJobRunner.Job.MapTaskRunnable#run 123456789101112131415public void run() &#123; try &#123; •••••• MapTask map = new MapTask(systemJobFile.toString(), mapId, taskId, info.getSplitIndex(), 1); •••••• try &#123; •••••• map.run(localConf, Job.this); •••••• &#125; catch (Throwable e) &#123; this.storedException = e; &#125; &#125;&#125; 从 MapTaskRunnable#run 中可以看到其创建了一个 MapTask 对象，并调用了 MapTask#run 方法。 org.apache.hadoop.mapred.MapTask#run 1234567891011121314151617@Overridepublic void run(final JobConf job, final TaskUmbilicalProtocol umbilical)throws IOException, ClassNotFoundException, InterruptedException &#123; •••••• //org.apache.hadoop.mapreduce.Job#submit 设置了 useNewApi，所以返回 true boolean useNewApi = job.getUseNewMapper(); •••••• if (useNewApi) &#123; runNewMapper(job, splitMetaInfo, umbilical, reporter); &#125; else &#123; runOldMapper(job, splitMetaInfo, umbilical, reporter); &#125; done(umbilical, reporter);&#125; MapTask#run 中会调用 runNewMapper 方法，所以继续查看该方法 org.apache.hadoop.mapred.MapTask#runNewMapper 123456789101112131415161718192021222324252627282930313233343536373839private &lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt; void runNewMapper(final JobConf job, final TaskSplitIndex splitIndex, final TaskUmbilicalProtocol umbilical, TaskReporter reporter ) throws IOException, ClassNotFoundException, InterruptedException &#123; // make a task context so we can get the classes org.apache.hadoop.mapreduce.TaskAttemptContext taskContext = new org.apache.hadoop.mapreduce.task.TaskAttemptContextImpl(job, getTaskID(), reporter); // 反射获取设置的 MapperClass 实例对象 org.apache.hadoop.mapreduce.Mapper&lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt; mapper = (org.apache.hadoop.mapreduce.Mapper&lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt;) ReflectionUtils.newInstance(taskContext.getMapperClass(), job); •••••• //创建 Context org.apache.hadoop.mapreduce.MapContext&lt;INKEY, INVALUE, OUTKEY, OUTVALUE&gt; mapContext = new MapContextImpl&lt;INKEY, INVALUE, OUTKEY, OUTVALUE&gt;(job, getTaskID(), input, output, committer, reporter, split); org.apache.hadoop.mapreduce.Mapper&lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt;.Context mapperContext = new WrappedMapper&lt;INKEY, INVALUE, OUTKEY, OUTVALUE&gt;().getMapContext( mapContext); try &#123; •••••• mapper.run(mapperContext); •••••• &#125; finally &#123; •••••• &#125;&#125; MapTask#runNewMapper 方法中会通过反射创建设置的 MapperClass 的对象，即 org.apache.giraph.job.GiraphJob#run 中设定的 GraphMapper 类的对象。在获取到 GraphMapper 对象后，系统会调用其 run 方法，从而使得程序的执行进入到 Giraph 部分。 Giraph 执行 Job org.apache.giraph.graph.GraphMapper#run 1234567891011121314151617@Overridepublic void run(Context context) throws IOException, InterruptedException &#123; // Notify the master quicker if there is Worker failure rather than // waiting for ZooKeeper to timeout and delete the ephemeral znodes try &#123; //初始化 setup(context); //执行计算 while (context.nextKeyValue()) &#123; graphTaskManager.execute(); &#125; //清理 cleanup(context); &#125; catch (RuntimeException e) &#123; •••••• &#125;&#125; 从 GraphMapper#run 方法可以看到一个 Giraph Job 的执行能够分为三个过程： 初始化 执行计算 清理 下面针对初始化过程进行分析 初始化 org.apache.giraph.graph.GraphMapper#setup 123456789@Overridepublic void setup(Context context) throws IOException, InterruptedException &#123; // Execute all Giraph-related role(s) assigned to this compute node. // Roles can include "Master," "Worker," "zookeeper," or . . . ? graphTaskManager = new GraphTaskManager&lt;I, V, E&gt;(context); graphTaskManager.setup( DistributedCache.getLocalCacheArchives(context.getConfiguration()));&#125; GraphMapper#setup 方法中会创建 GraphTaskManager 对象，并调用其 setup 方法 org.apache.giraph.graph.GraphTaskManager#setup 12345678910111213141516171819202122232425262728public void setup(Path[] zkPathList) throws IOException, InterruptedException &#123; Configuration hadoopConf = context.getConfiguration(); //初始化一些配置 conf = new ImmutableClassesGiraphConfiguration&lt;I, V, E&gt;(hadoopConf); •••••• //从配置中读取 Zookeeper 的连接信息，没有提供外部 Zookeeper 情况下为空 String serverPortList = conf.getZookeeperList(); //如果没有提供外部 Zookeeper 则需要自己启动 Zookeeper if (serverPortList.isEmpty()) &#123; if (startZooKeeperManager()) &#123; return; // ZK connect/startup failed &#125; &#125; else &#123; createZooKeeperCounter(serverPortList); &#125; •••••• this.graphFunctions = determineGraphFunctions(conf, zkManager); if (zkManager != null &amp;&amp; this.graphFunctions.isMaster()) &#123; //将由 Master 创建的文件夹标记为删除，文件系统关闭时将会删除文件 zkManager.cleanupOnExit(); &#125; try &#123; //初始化 BSP 服务 instantiateBspService(); &#125; catch (IOException e) &#123; •••••• &#125;&#125; GraphTaskManager#setup 方法主要做三件事： 获取 Zookeeper 连接信息 决定进程的角色 初始化 BSP 服务 获取 Zookeeper 连接信息 GraphTaskManager#setup 中会通过 conf.getZookeeperList() 获得 Zookeeper 的连接信息。如果提供了外部 Zookeeper 则直接返回连接信息，但如果没有提供外部 Zookeeper 时，getZookeeperList() 会返回空值。此时 GraphTaskManager#setup 会调用 startZooKeeperManager 方法在某一个 Task 启动 Zookeeper。 org.apache.giraph.graph.GraphTaskManager#startZooKeeperManager 1234567891011121314151617181920212223/** * Instantiate and configure ZooKeeperManager for this job. This will * result in a Giraph-owned Zookeeper instance, a connection to an * existing quorum as specified in the job configuration, or task failure * @return true if this task should terminate */private boolean startZooKeeperManager() throws IOException, InterruptedException &#123; zkManager = new ZooKeeperManager(context, conf); context.setStatus("setup: Setting up Zookeeper manager."); zkManager.setup(); //如果计算已经结束则不需要再启动 Zookeeper， //大部分情况应该会在没有提供外部 Zookeeper 且重启 Task 时候起作用 if (zkManager.computationDone()) &#123; done = true; return true; &#125; zkManager.onlineZooKeeperServer(); //更新 Zookeeper 连接信息，创建计数器 String serverPortList = zkManager.getZooKeeperServerPortString(); conf.setZookeeperList(serverPortList); createZooKeeperCounter(serverPortList); return false;&#125; startZooKeeperManager 中首先会创建 ZooKeeperManager 对象，然后调用其 setup 方法 org.apache.giraph.zk.ZooKeeperManager#setup 1234public void setup() throws IOException, InterruptedException &#123; createCandidateStamp(); getZooKeeperServerList();&#125; ZooKeeperManager#setup 方法中会首先调用 createCandidateStamp 方法 org.apache.giraph.zk.ZooKeeperManager#createCandidateStamp 1234567891011121314151617181920212223242526272829/** * Create a HDFS stamp for this task. If another task already * created it, then this one will fail, which is fine. */public void createCandidateStamp() &#123; •••••• fs.mkdirs(baseDirectory); •••••• fs.mkdirs(serverDirectory); •••••• if (!fs.getFileStatus(baseDirectory).isDir()) &#123; throw new IllegalArgumentException( "createCandidateStamp: " + baseDirectory + " is not a directory, but should be."); &#125; •••••• //根据 hostname 和 taskPartition 生成文件名 Path myCandidacyPath = new Path( taskDirectory, myHostname + HOSTNAME_TASK_SEPARATOR + taskPartition); try &#123; •••••• fs.createNewFile(myCandidacyPath); &#125; catch (IOException e) &#123; LOG.error("createCandidateStamp: Failed (maybe previous task " + "failed) to create filestamp " + myCandidacyPath, e); &#125;&#125; 在 createCandidateStamp 方法中，每个 Task 会根据自己的 hostname 和 taskPartition 在 _bsp/_defaultZkManagerDir/_task 下创建对应文件，这些文件将会在系统选择某个 Task 启动 Zookeeper 服务时用到。具体结果如下图所示： 图中 hostname 是 localhost 的原因在于，运行源码的时候 Hadoop 处于 Standalone 模式。 在 createCandidateStamp 执行完成之后，ZooKeeperManager#setup 会接着调用 getZooKeeperServerList org.apache.giraph.zk.ZooKeeperManager#getZooKeeperServerList 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void getZooKeeperServerList() throws IOException, InterruptedException &#123; String serverListFile; //taskPartition 为 0 的 Task 会创建 zooKeeperServerList if (taskPartition == 0) &#123; //0 号 Task 如果重启检查到已经有 serverList 则不会重新创建 serverListFile = getServerListFile(); if (serverListFile == null) &#123; //创建 serverList createZooKeeperServerList(); &#125; &#125; while (true) &#123; //其余 Task 等待 serverList 的创建 serverListFile = getServerListFile(); •••••• if (serverListFile != null) &#123; break; &#125; //减少 CPU 的占用 try &#123; Thread.sleep(pollMsecs); &#125; catch (InterruptedException e) &#123; LOG.warn("getZooKeeperServerList: Strange interrupted " + "exception " + e.getMessage()); &#125; &#125; //解析 serverList 中的信息 String[] serverHostList = serverListFile.substring( ZOOKEEPER_SERVER_LIST_FILE_PREFIX.length()).split( HOSTNAME_TASK_SEPARATOR); •••••• //获得 Zookeeper 服务所在节点的 hostname zkServerHost = serverHostList[0]; //获得应该启动 Zookeeper 服务的 Task 的 taskPartition zkServerTask = Integer.parseInt(serverHostList[1]); //各个 Task 更新自己的 zkServerPortString updateZkPortString(); &#125; getZooKeeperServerList 方法会根据 taskPartition 进行判断，如果是 0 号 Task 则会先调用 createZooKeeperServerList 创建 serverListFile（serverListFile 表明了 Zookeeper 服务所在的 hostname 和 taskPartition），而如果是非 0 号 Task 则会进行轮询来获取 serverListFile 的文件名。在获取到文件名后会对其进行解析来更新 zkServerHost、zkServerTask 以及 zkServerPortString。 接下来会对 createZooKeeperServerList 和 getZooKeeperServerList 进行分析以便更好的理解系统如何选取启动 Zookeeper 服务的 Task org.apache.giraph.zk.ZooKeeperManager#createZooKeeperServerList 12345678910111213141516171819202122232425262728293031private void createZooKeeperServerList() throws IOException, InterruptedException &#123; String host; String task; while (true) &#123; //返回 Task 下文件的元数据，会有一个文件名格式校验的过程，会去掉以 . 开头和 crc 结尾文件 FileStatus [] fileStatusArray = fs.listStatus(taskDirectory); if (fileStatusArray.length &gt; 0) &#123; //选取第一位的元数据标识的 Task 去启动 Zookeeper 服务 FileStatus fileStatus = fileStatusArray[0]; //解析信息 String[] hostnameTaskArray = fileStatus.getPath().getName().split( HOSTNAME_TASK_SEPARATOR); •••••• host = hostnameTaskArray[0]; task = hostnameTaskArray[1]; break; &#125; Thread.sleep(pollMsecs); &#125; //根据解析的信息生成 serverListFile 文件名 String serverListFile = ZOOKEEPER_SERVER_LIST_FILE_PREFIX + host + HOSTNAME_TASK_SEPARATOR + task; Path serverListPath = new Path(baseDirectory, serverListFile); •••••• &#125; //创建文件 fs.createNewFile(serverListPath);&#125; createZooKeeperServerList 中会获取所有 Task 在 createCandidateStamp 方法中创建的文件的文件名，然后选取返回数组中第一个元素标识的 Task 信息去创建 serverListFile。 org.apache.giraph.zk.ZooKeeperManager#getServerListFile 1234567891011121314private String getServerListFile() throws IOException &#123; String serverListFile = null; //baseDirectory 是 _bsp/_defaultZkManagerDir，列出文件夹下的文件元数据 FileStatus [] fileStatusArray = fs.listStatus(baseDirectory); for (FileStatus fileStatus : fileStatusArray) &#123; //筛选文件名中含有 zkServerList_ 的文件，即 taskpartition 为 0 task 创建的 serverListFile if (fileStatus.getPath().getName().startsWith( ZOOKEEPER_SERVER_LIST_FILE_PREFIX)) &#123; serverListFile = fileStatus.getPath().getName(); break; &#125; &#125; return serverListFile;&#125; getServerListFile 会获取 baseDirectory 下的文件元数据，然后筛选出对应的 serverListFile，最后返回其文件名。 接着回到 startZooKeeperManager 方法中，在选定了启动 Zookeeper 服务的 Task 后，系统会首先判断计算是否完成，如果已经完成则表明无需再继续运行。否则会调用 onlineZooKeeperServer 方法启动 Zookeeper 服务。 org.apache.giraph.zk.ZooKeeperManager#onlineZooKeeperServer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public void onlineZooKeeperServer() throws IOException &#123; //如果当前 task 的 taskPartition 等于 zkServerTask，则需要启动 Zookeeper 服务 if (zkServerTask == taskPartition) &#123; File zkDirFile = new File(this.zkDir); try &#123; //删除旧的文件夹 •••••• FileUtils.deleteDirectory(zkDirFile); &#125; catch (IOException e) &#123; •••••• &#125; //生成 Zookeeper 配置 generateZooKeeperConfig(); synchronized (this) &#123; zkRunner = createRunner(); //启动 Zookeeper 服务 int port = zkRunner.start(zkDir, config); if (port &gt; 0) &#123; zkBasePort = port; updateZkPortString(); &#125; &#125; // Once the server is up and running, notify that this server is up // and running by dropping a ready stamp. int connectAttempts = 0; final int maxConnectAttempts = conf.getZookeeperConnectionAttempts(); while (connectAttempts &lt; maxConnectAttempts) &#123; try &#123; •••••• //连接 Zookeeper 服务 InetSocketAddress zkServerAddress = new InetSocketAddress(myHostname, zkBasePort); Socket testServerSock = new Socket(); testServerSock.connect(zkServerAddress, 5000); •••••• break; &#125; catch (SocketTimeoutException e) &#123; LOG.warn("onlineZooKeeperServers: Got " + "SocketTimeoutException", e); &#125; catch (ConnectException e) &#123; LOG.warn("onlineZooKeeperServers: Got " + "ConnectException", e); &#125; catch (IOException e) &#123; LOG.warn("onlineZooKeeperServers: Got " + "IOException", e); &#125; ++connectAttempts; try &#123; Thread.sleep(pollMsecs); &#125; catch (InterruptedException e) &#123; LOG.warn("onlineZooKeeperServers: Sleep of " + pollMsecs + " interrupted - " + e.getMessage()); &#125; &#125; //超过最大的尝试数，连接失败 if (connectAttempts == maxConnectAttempts) &#123; throw new IllegalStateException( "onlineZooKeeperServers: Failed to connect in " + connectAttempts + " tries!"); &#125; // Path myReadyPath = new Path( serverDirectory, myHostname + HOSTNAME_TASK_SEPARATOR + taskPartition + HOSTNAME_TASK_SEPARATOR + zkBasePort); try &#123; •••••• //创建文件表明 Zookeeper 服务已经准备好，并且提供连接的信息 fs.createNewFile(myReadyPath); &#125; catch (IOException e) &#123; •••••• &#125; &#125; else &#123; //其余 Task 等待 Zookeeper 服务的启动 int readyRetrievalAttempt = 0; String foundServer = null; while (true) &#123; try &#123; FileStatus [] fileStatusArray = fs.listStatus(serverDirectory); //检查 serverDirectory 文件夹下是否生成了 Zookeeper 连接信息文件 if ((fileStatusArray != null) &amp;&amp; (fileStatusArray.length &gt; 0)) &#123; //解析文件中的连接信息 for (int i = 0; i &lt; fileStatusArray.length; ++i) &#123; String[] hostnameTaskArray = fileStatusArray[i].getPath().getName().split( HOSTNAME_TASK_SEPARATOR); if (hostnameTaskArray.length != 3) &#123; throw new RuntimeException( "getZooKeeperServerList: Task 0 failed " + "to parse " + fileStatusArray[i].getPath().getName()); &#125; //zookeeper 服务所在地址 foundServer = hostnameTaskArray[0]; //zookeeper 服务的连接端口 zkBasePort = Integer.parseInt(hostnameTaskArray[2]); //更新 zookeeper 的连接信息 updateZkPortString(); &#125; •••••• //查看 hostname 是否相同，相同则跳出等待，具体场景尚未想到 if (zkServerHost.equals(foundServer)) &#123; break; &#125; &#125; else &#123; •••••• &#125; Thread.sleep(pollMsecs); ++readyRetrievalAttempt; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; catch (InterruptedException e) &#123; •••••• &#125; &#125; &#125;&#125; 可以看到 onlineZooKeeperServer 实际做了两件事情：一是在选定的 Task 上启动 Zookeeper 服务，并创建文件表明服务已经准备好。二是所有未启动 Zookeeper 服务的 Task 去更新 Zookeeper 的连接信息。 分配角色 在启动完成 Zookeeper 服务之后系统会更新 Zookeeper 相关的配置信息然后返回到 org.apache.giraph.graph.GraphTaskManager#setup 方法中，之后会调用 determineGraphFunctions org.apache.giraph.graph.GraphTaskManager#determineGraphFunctions 123456789101112131415161718192021222324252627282930313233343536373839private static GraphFunctions determineGraphFunctions( ImmutableClassesGiraphConfiguration conf, ZooKeeperManager zkManager) &#123; //判断是本地模式还是集群模式，本地模式只会启动一个 Task boolean splitMasterWorker = conf.getSplitMasterWorker(); //获取当前 Task 的 taskPartition int taskPartition = conf.getTaskPartition(); //判断是否提供了外部的 Zookeeper boolean zkAlreadyProvided = conf.isZookeeperExternal(); //初始时刻 Task 的角色 GraphFunctions functions = GraphFunctions.UNKNOWN; if (!splitMasterWorker) &#123; //本地模式下如果是内部启动 Zookeeper 则 Task 充当所有的角色，否则充当 Master 和 Worker if ((zkManager != null) &amp;&amp; zkManager.runsZooKeeper()) &#123; functions = GraphFunctions.ALL; &#125; else &#123; functions = GraphFunctions.ALL_EXCEPT_ZOOKEEPER; &#125; &#125; else &#123; if (zkAlreadyProvided) &#123; //如果有外部 Zookeeper 则 0 号 Task 就是 Master，其余的都是 Worker if (taskPartition == 0) &#123; functions = GraphFunctions.Master_ONLY; &#125; else &#123; functions = GraphFunctions.Worker_ONLY; &#125; &#125; else &#123; //如果是内部启动的 Zookeeper 服务， //则启动 Zookeeper 服务的 Task 充当 Master 和 zookeeper 角色，其余为 Worker if ((zkManager != null) &amp;&amp; zkManager.runsZooKeeper()) &#123; functions = GraphFunctions.Master_ZOOKEEPER_ONLY; &#125; else &#123; functions = GraphFunctions.Worker_ONLY; &#125; &#125; &#125; return functions;&#125; determineGraphFunctions 主要是对 Task 的角色进行判断，系统提供了 6 种角色： UNKNOWN 表明 Task 的角色还未知 Master_ONLY 表明 Task 是 Master Master_ZOOKEEPER_ONLY 表明 Task 既是 Master 也是 Zookeeper Worker_ONLY 表明 Task 只是 Worker ALL 表明 Task 既是 Master 也是 Worker 和 Zookeeper ALL_EXCEPT_ZOOKEEPER 表明 Task 既是 Master 也是 Worker 初始化 BSP 在决定各个 Task 的角色之后，系统会调用 instantiateBspService 初始化 BSP 服务。 org.apache.giraph.graph.GraphTaskManager#instantiateBspService 1234567891011121314151617181920private void instantiateBspService()throws IOException, InterruptedException &#123; if (graphFunctions.isMaster()) &#123; •••••• //创建 Master 对象 serviceMaster = new BspServiceMaster&lt;I, V, E&gt;(context, this); //Master 运行在线程里面 MasterThread = new MasterThread&lt;I, V, E&gt;(serviceMaster, context); MasterThread.setUncaughtExceptionHandler( createUncaughtExceptionHandler()); MasterThread.start(); &#125; if (graphFunctions.isWorker()) &#123; •••••• //创建 Worker 对象 serviceWorker = new BspServiceWorker&lt;I, V, E&gt;(context, this); installGCMonitoring(); •••••• &#125;&#125; instantiateBspService 中对于 Master 主要是创建 serviceMaster 对象，然后启动 MasterThread 线程，对于 Worker 则是创建 serviceWorker 对象。 总结 总的来说，Giraph 的 Job 提交和初始化依据以下流程来执行： 用户向 Giraph 提交 Job Giraph 向 Hadoop 提交 Job Hadoop 启动 MapTask，并执行 GraphMapper 的 run 方法 GraphMapper 创建 GraphTaskManager 对象进行初始化 初始化过程首先获取 Zookeeper 连接信息，如果没有外置 Zookeeper 则需要从所有 MapTask 中进行选取 Task 来启动 Zookeeper 服务。 获取到 Zookeeper 连接信息之后会根据 determineGraphFunctions 分配角色，由此区分 MapTask 中的 Master 和 Worker 分配完角色之后则会通过 instantiateBspService 来初始化 BSP 服务，由此结束整个初始化过程。]]></content>
      <categories>
        <category>Giraph 源码分析</category>
      </categories>
      <tags>
        <tag>图计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发编程之线程基础]]></title>
    <url>%2F2019%2F09%2F07%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言 本文首先对线程的定义及作用进行了说明，然后在此基础上介绍了线程的使用方式，并根据线程的生命周期对 Java 中提供的主要 API 进行分类，以期对线程的基础知识有一个了解。 线程的定义及作用 线程是程序内的单个顺序控制流（例如：在一个音乐 APP 当中一般会存在下载和后台播放两个控制流）。作为单个顺序控制流，线程不能单独执行，而必须依存于程序运行时创建的进程才能够执行。通常情况下，一个进程当中会存在多个线程。通过这种多线程机制，程序可以实现并发（并行）从而提高执行速度和资源利用率。以音乐 APP 为例，在不存在并发（并行）情况下，用户可能需要先完成下载才能进行后台播放，这种情况下程序的执行时间会很长，用户体验感也很差，而通过多线程实现的并发（并行），用户就可以边下载边进行后台播放。 这里可能会有一个疑问，既然多线程是实现并发（并行）的一种方式，那么多进程是否可以实现并发（并行）呢？答案当然是肯定的，但之所以一般不采用多进程实现并发（并行）是因为： 进程之间相互隔离，所以进程间通信比线程之间的通信要麻烦 进程作为资源分配的基本单位，其创建和撤销的代价都要高于线程 进程间的切换比线程间的切换要慢 线程的使用 使用线程一般有三种方式： 继承 Thread 实现 Runnable 接口 实现 Callable 接口 下面针对这三种方式给出相应的例子 继承 Thread Java 提供了 Thread 类进行线程的创建，在 Thread 内部存在一个可以重写的 run 方法，run 方法主要用于完成 task 的执行。run 方法可以重写，所以可以通过继承 Thread 重写 run 来使用线程。 123456789101112131415161718/** * @author ikroal * @date 2019-09-28 * @version: 1.0.0 */public class CustomThread extends Thread &#123; @Override public void run() &#123; System.out.println("Hello CustomThread"); &#125; public static void main(String[] args) &#123; //创建线程对象并启动线程 CustomThread customThread = new CustomThread(); customThread.start(); &#125;&#125; 运行后控制台将会输出 实现 Runnable 接口 由于 Java 单继承的特性，如果采用继承 Thread 的方式去使用线程会导致无法继承其它类。所以为解决这一问题，Java 提供了 Runnable 接口去使用线程。 1234567891011121314151617/** * @author ikroal * @date 2019-09-28 * @version: 1.0.0 */public class CustomRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println("Hello CustomRunnable"); &#125; public static void main(String[] args) &#123; CustomRunnable customRunnable = new CustomRunnable(); Thread thread = new Thread(customRunnable); thread.start(); &#125;&#125; 运行后将会输出 可以看到通过 Runnable 使用线程可以分为两步： 实现 Runnable 接口 将接口实现类的对象传递到 Thread 对象中，调用 Thread#start 启动线程。 实现 Callable 接口 某些时候用户可能需要线程运行完成的时候能够返回一些结果，但是 Runnable 和 Thread 都不能直接返回结果。所以在 JDK1.5 中，Java 增加了 Callable 接口，Callable 接口定义如下： 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 通过 call 方法，线程执行的时候能够返回结果，但是如何获取结果呢？这需要用到 Future 接口 12345678910111213public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Future 接口中最关键的方法是 get 方法，通过 get 方法用户就能够获取到由 Callable#call 方法返回的结果了。为了方便用户的使用以及兼容直接通过 Thread 创建线程的使用方式（Thread 类在 JDK1.0 时提供，构造方法仅能传入了 Runnable 接口的实现），Java 提供了 FutureTask 类，该类对 Callable 进行适配以适应 Thread 的构造函数。下面给出一个 callable 使用示例 123456789101112131415161718192021222324252627/** * @author ikroal * @date 2019-09-28 * @version: 1.0.0 */public class CustomCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println("Hello CustomCallable"); //返回 String 类型 return this.getClass().getSimpleName(); &#125; public static void main(String[] args) &#123; CustomCallable customCallable = new CustomCallable(); //利用 FutureTask 进行适配 FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(customCallable); Thread thread = new Thread(futureTask); thread.start(); try &#123; //输出返回值 System.out.println(futureTask.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行后将会输出 Callable 从例子中可以看到 Callable 的使用可以分为三步： 实现 Callable&lt;V&gt; 接口 将接口实现类的对象传递到 FutureTask&lt;V&gt; 对象中进行适配 将 FutureTask&lt;V&gt; 对象传递到 Thread 对象中，然后调用 Thread#start 接口中启动线程 通过 FutureTask#get 获取返回值 线程的生命周期 从 Thread.State 枚举类中可以看出，Java 将线程的生命周期划分为 6 种状态： New 新建态，线程创建之后尚未调用 start 方法时的状态 Runnable 可运行状态，处于可运行状态的线程可能正在 JVM 中执行，也有可能正在等待操作系统的其它资源（例如处理器） Blocked 阻塞态，处于这一状态的线程需要等待一个 monitor 锁 Waiting 等待态，处于这一状态的线程会一直等待另一个线程执行特定操作 Timed_Waiting 定时等待，处于这一状态的线程会在指定的时间内等待另一个线程执行特定操作 Terminated 终止态，执行完成的线程会处于这一状态。 各个状态之间的转换关系如下图所示 下面结合一些例子说明状态的转换过程 New----------&gt;Runnable 12345678910111213public class StateSwitch &#123; public static void main(String[] args) &#123; newToRunnable(); &#125; private static void newToRunnable() &#123; Thread newtoRunnable = new Thread(() -&gt; System.out.println("2: " + Thread.currentThread().getState())); System.out.println("1: " + newtoRunnable.getState()); newtoRunnable.start(); &#125;&#125; 运行之后将会输出 可以看到线程在创建之后处于 New 态，然后通过调用 start 方法，线程的状态会从 New 态转换为 Runnable 态 Runnable----------&gt;Terminated 1234567891011121314public class StateSwitch &#123; public static void main(String[] args) throws InterruptedException &#123; runnableToTerminated(); &#125; private static void runnableToTerminated() throws InterruptedException &#123; Thread runnableToTerminated = new Thread(() -&gt; System.out.println("1: " + Thread.currentThread().getState())); runnableToTerminated.start(); Thread.sleep(1000); System.out.println("2: " + runnableToTerminated.getState()); &#125;&#125; 与第一个程序类似，只是状态的输出全都在调用 Thread#start 方法之后，运行之后将会输出 线程完成任务之后会由 Runnable 态转为 Terminated 态 Runnable----------&gt;Waiting----------&gt;Runnable 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class StateSwitch &#123; public static void main(String[] args) throws InterruptedException &#123; runnableToWaiting(); &#125; private static void runnableToWaiting() throws InterruptedException &#123; String waitingObject = "waiting"; WaitingRunnable waitingRunnable = new WaitingRunnable(waitingObject); Thread runnableToWaiting = new Thread(waitingRunnable); runnableToWaiting.start(); //等待线程调用了 waitingObject 的 wait 方法 Thread.sleep(1000); System.out.println("2: " + runnableToWaiting.getState()); //通知 synchronized (waitingObject) &#123; waitingObject.notify(); &#125; &#125; static class WaitingRunnable implements Runnable &#123; private final String mWaitingObject; public WaitingRunnable(String waitingObject) &#123; mWaitingObject = waitingObject; &#125; @Override public void run() &#123; synchronized (mWaitingObject) &#123; //获取当前对象所在线程 Thread thread = Thread.currentThread(); //输出线程状态 System.out.println("1: " + thread.getState()); try &#123; //等待 mWaitingObject.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("3: " + thread.getState()); &#125; &#125; &#125;&#125; 运行之后将会输出 可以看到，当 runnableToWaiting 线程的任务调用了 mWaitingObject.wait 之后，线程就会进入 Waiting 态，而当主线程中的 waitingObject 对象调用了 notify 方法之后，runnableToWaiting 线程会从 Waiting 态转为 Runnable 态。这与 Waiting 状态中的说明一致，处于 Waiting 态的线程需要等待另一个线程执行特定操作。 Runnable----------&gt;Timed_Waiting----------&gt;Runnable 将 3 中的 WaitingRunnable 稍作修改，去掉 notify 过程，并指定 wait 的时间 123456789101112131415161718192021222324252627282930313233343536373839public class StateSwitch &#123; public static void main(String[] args) throws InterruptedException &#123; runnableToTimedWaiting(); &#125; private static void runnableToTimedWaiting() throws InterruptedException &#123; String waitingObject = "waiting"; TimedWaitingRunnable waitingRunnable = new TimedWaitingRunnable(waitingObject); Thread runnableToTimedWaiting = new Thread(waitingRunnable); runnableToTimedWaiting.start(); //等待线程调用了 waitingObject 的 wait 方法 Thread.sleep(1000); System.out.println("2: " + runnableToTimedWaiting.getState()); &#125; static class TimedWaitingRunnable implements Runnable &#123; private final String mWaitingObject; public TimedWaitingRunnable(String waitingObject) &#123; mWaitingObject = waitingObject; &#125; @Override public void run() &#123; synchronized (mWaitingObject) &#123; Thread thread = Thread.currentThread(); System.out.println("1: " + thread.getState()); try &#123; //等待 1500 ms mWaitingObject.wait(1500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("3: " + thread.getState()); &#125; &#125; &#125;&#125; 运行后将会输出 可以看到当在线程执行过程中调用 mWaitingObject.wait(1500) 之后，线程将会从 Runnable 态转为 Timed_Waiting 态。与 Waiting 不同的是，当线程等待超过 1500ms 之后，线程又回从 Timed_Waiting 态转为 Runnable 态，而不是必须等待另外一个线程执行特定操作。 Runnable----------&gt;Blocked----------&gt;Runnable 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class StateSwitch &#123; public static void main(String[] args) throws InterruptedException &#123; runnableToBlocked(); &#125; private static void runnableToBlocked() throws InterruptedException &#123; String blockedObject = "blocked"; BlockedRunnable blockedRunnable = new BlockedRunnable(blockedObject); Thread runnableToBlocked = new Thread(blockedRunnable); runnableToBlocked.start(); //获取 blockedObject 的锁 synchronized (blockedObject) &#123; //确保 runnableToBlocked 线程已经处于阻塞状态 Thread.sleep(1000); System.out.println("2: " + runnableToBlocked.getState()); &#125; &#125; static class BlockedRunnable implements Runnable &#123; private final String mBlockedObject; public BlockedRunnable(String blockedObject) &#123; mBlockedObject = blockedObject; &#125; @Override public void run() &#123; Thread thread = Thread.currentThread(); System.out.println("1: " + thread.getState()); //保证主线程优先获得 mBlockedObject 所指向对象的锁 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //尝试获取 mBlockedObject 的锁 synchronized (mBlockedObject) &#123; &#125; System.out.println("3: " + thread.getState()); &#125; &#125;&#125; 运行后将会输出 通过运行结果可以看出当线程尝试去获取一个对象的锁时，如果获取不到即会从 Runnable 态转换成 Blocked 态，然后在获取到锁之后又回从 Blocked 态转换回 Blocked 态。 主要 API Thread 类提供的 API 可以分为两类：一类是影响生命周期的 API，另一类则是修改和读取线程信息的 API 影响生命周期的 API public static native void sleep(long millis) throws InterruptedException public static void sleep(long millis, int nanos) throws InterruptedException 让线程从 Runnable 态进入 Timed_Waiting 态，这两个方法都是类方法，不同之处在于后者能够更精确的控制线程睡眠时间。 1234567891011121314151617181920212223242526272829303132333435/** * @author ikroal * @date 2019-09-30 * @version: 1.0.0 */public class Apis &#123; public static void main(String[] args) throws InterruptedException &#123; testSleep(); &#125; static void testSleep() throws InterruptedException &#123; SleepRunnable sleepRunnable = new SleepRunnable(); Thread sleepThread = new Thread(sleepRunnable); sleepThread.start(); Thread.sleep(500); System.out.printf("2: thread state is %s\n", sleepThread.getState()); &#125; static class SleepRunnable implements Runnable &#123; @Override public void run() &#123; System.out.printf("1: thread state is %s\n", Thread.currentThread().getState()); long start = System.currentTimeMillis(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.printf("cost time %d\n", end - start); &#125; &#125;&#125; 运行之后将会输出 Note: 这里的 cost time 结果会接近 1000，而不一定是 1000 public synchronized void start() 启动线程的方法，让线程从 New 态进入到 Runnable 态 public final void stop() public final synchronized void stop(Throwable obj) 停止线程的方法，可以让线程进入 Terminated 状态。由于这种停止线程的方法可能导致数据不一致，所以这两个方法已被废弃。 修改和读取线程信息的 API 其它问题 线程调度 守护线程 Thanks What Is a Thread? Why should I use a thread vs. using a process? Life Cycle of a Thread in Java]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Giraph 编程实践及源码编译调试]]></title>
    <url>%2F2019%2F09%2F07%2FGiraph%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前言 本文主要总结了如何利用 Giraph 提供的 API 实现图计算编程，并说明了将 Giraph 源码导入 IDEA 进行调试的过程。 编程实践 本部分通过实现最短路径算法说明 Giraph 的编程流程 创建 Maven 工程 添加相关依赖 123456789101112131415161718192021&lt;dependencies&gt; &lt;!--添加 Giraph 依赖--&gt;&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.giraph&lt;/groupId&gt; &lt;artifactId&gt;giraph-core&lt;/artifactId&gt; &lt;version&gt;1.2.0-hadoop2&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加 Hadoop 依赖--&gt;&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建 ShortestPathComputation 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import org.apache.giraph.edge.Edge;import org.apache.giraph.graph.BasicComputation;import org.apache.giraph.graph.Vertex;import org.apache.hadoop.io.DoubleWritable;import org.apache.hadoop.io.FloatWritable;import org.apache.hadoop.io.LongWritable;import java.io.IOException;public class ShortestPathComputation extends BasicComputation&lt;LongWritable, DoubleWritable, FloatWritable, DoubleWritable&gt; &#123; /** * 需要计算最短路径的源顶点 */ private static final int SOURCE_VERTEX = 0; /** * 表示节点不可达 */ private static final double UNREACHABLE = Double.MAX_VALUE; /** * @param vertex 待处理的顶点 * @param messages vertex 接收到的来自其余顶点的 message */ @Override public void compute(Vertex&lt;LongWritable, DoubleWritable, FloatWritable&gt; vertex, Iterable&lt;DoubleWritable&gt; messages) throws IOException &#123; if (getSuperstep() == 0) &#123; //超步 0 时源顶点最短路径设置为 0，其余顶点设置为不可达，并且源顶点需要向其它顶点发送最短距离message if (vertex.getId().get() == SOURCE_VERTEX) &#123; vertex.setValue(new DoubleWritable(0)); sendDist(vertex); &#125; else &#123; vertex.setValue(new DoubleWritable(UNREACHABLE)); &#125; &#125; else &#123; //遍历处理从其余顶点收到的 message， // 查看 message 中传递的最短距离是否小于当前的最短距离，如果是则进行更新 for (DoubleWritable message : messages) &#123; if (message.get() &lt; vertex.getValue().get()) &#123; vertex.setValue(message); sendDist(vertex); &#125; &#125; &#125; //主动将顶点置于不活跃状态，如果顶点收到 message，系统会将顶点再度激活 vertex.voteToHalt(); &#125; /** * 发送顶点 vertex 到其邻接顶点的最短距离 */ private void sendDist(Vertex&lt;LongWritable, DoubleWritable, FloatWritable&gt; vertex) &#123; for (Edge&lt;LongWritable, FloatWritable&gt; edge : vertex.getEdges()) &#123; double distance = vertex.getValue().get() + edge.getValue().get(); sendMessage(edge.getTargetVertexId(), new DoubleWritable(distance)); &#125; &#125;&#125; ShortestPathComputation 继承了 BasicComputation，对于 BasicComputation 中指定的四个类型参数，其含义依次为 Vertex id Vertex data Edge data Message 整个计算的过程可以总结为： Superstep 0 的时候进行初始化，然后源头顶点向邻接顶点发送可能的最短路径 message 下一 Superstep 邻接顶点处理接收到的 message 然后和顶点值进行比较，如果 message 小于顶点值则对顶点值进行更新，并向邻接顶点发送可能的最短路径 message。 重复 2 直到所有的顶点处于不活跃状态，最后结束计算进行输出。 提交验证 验证部分基于 Pseudo-Distributed 模式的 Hadoop 进行 上传测试文件到 HDFS 12345678$HADOOP_HOME/bin/hdfs dfs -put giraph_data.txt &lt;your_input_path&gt;/shortestpath#giraph_data 中的数据，格式为 [source_id,source_value,[[dest_id, edge_value],...]]，# 如 [0,0,[[1,1],[3,3]]] 表示顶点序号为 0，顶点值为 0，存在序号 0 到 序号 1 的边，值为 1，存在序号 0 到序号 3 的边，值为 3。[0,100,[[1,1],[3,3]]][1,20,[[0,1],[2,2],[3,1]]][2,90,[[1,2],[4,4]]][3,50,[[0,3],[1,1],[4,4]]][4,80,[[3,4],[2,4]]] 将工程打包为 jar 文件，并提交到 Hadoop 1$HADOOP_HOME/bin/hadoop jar Examples.jar org.apache.giraph.GiraphRunner com.ikroal.shortestpath.ShortestPathComputation -vif org.apache.giraph.io.formats.JsonLongDoubleFloatDoubleVertexInputFormat -vip &lt;your_input_path&gt;/giraph_data.txt -vof org.apache.giraph.io.formats.IdWithValueTextOutputFormat -op &lt;your_output&gt;/shortestpaths -w 1 提交任务的过程基本与一般的提交过程一致，只是还额外指定了 Giraph 运行所需要的参数，对于相关参数的解释请参考 Giraph 环境搭建 。 查看结果 运行之后将会在输出路径下看到输出文件，其内容为 123450 0.01 1.02 3.03 2.04 6.0 总结 Giraph 的编程过程可以总结为： 继承 BasicComputation，实现 compute 方法 compute 方法主要完成顶点的计算更新和必要的消息发送 命令行提交 Job 由于系统已经提供了 GiraphRunner 的主类，所以大部分情况下用户不需要编写 Job 的配置和提交过程，但是如果 GiraphRunner 不满足用户需求，用户也可以自定义主类然后命令行提交的时候进行指定 以上仅仅说明了最基本的 Giraph 编程过程，但如果想要实现性能最优的图计算过程，则还需要考虑编程过程中利用 Aggregators 和 Combiners 机制，相关示例可以参考 giraph 源码的 giraph-examples 部分。 源码编译调试 环境要求 Giraph 源码的编译调试要求 Java 1.8、Maven 3 以上版本以及 Hadoop2.5.1 导入源码 下载源码 1git clone https://github.com/apache/giraph.git 编译源码 1mvn -Phadoop_2 -DskipTests clean package 成功后将会输出 使用 IDEA 打开 giraph 源码目录 在 Maven 的 Profies 页面选择 hadoop2 ( 默认是 hadoop1 ) 增加自定义入口 Giraph 提供了一个位于 giraph-core/src/main/java/org/apache/giraph 下的入口类 GiraphRunner。但该类比较繁琐并且不能自动删除输出文件，不太利于本地调试阅读 Giraph 的源码。因此最好是增加一个自定义的入口类。 在 org.apache.giraph 包下创建 custom 包 在 custom 包下创建用于测试的 Shortestpath 类（内容与编程实践部分一致） 在 custom 包下创建自定义入口类 CustomRunner 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import org.apache.giraph.conf.GiraphConfiguration;import org.apache.giraph.conf.GiraphConstants;import org.apache.giraph.io.formats.*;import org.apache.giraph.job.GiraphJob;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import java.io.File;public class CustomRunner &#123; /** * 输入路径 */ private static final String INPUT_PATH = "giraph-core/src/main/resources/input/graph_data.txt"; /** * 输出路径 */ private static final String OUTPUT_PATH = "giraph-core/src/main/resources/output/shortestPath"; public static void main(String[] args) throws Exception &#123; GiraphConfiguration conf = new GiraphConfiguration(new Configuration()); conf.setComputationClass(Shortestpath.class); //设置输入和输出格式 conf.setVertexInputFormatClass(JsonLongDoubleFloatDoubleVertexInputFormat.class); conf.setVertexOutputFormatClass(IdWithValueTextOutputFormat.class); //设置本地运行模式 conf.setLocalTestMode(true); //设置 worker 配置 conf.setWorkerConfiguration(1, 1, 100); //可选，如果要学习 Checkpoint 机制应该设置 conf.setCheckpointFrequency(4); GiraphConstants.SPLIT_MASTER_WORKER.set(conf, false); GiraphJob job = new GiraphJob(conf, Shortestpath.class.getSimpleName()); //设置输入和输出路径 GiraphTextInputFormat.setVertexInputPath(conf, new Path(INPUT_PATH)); GiraphTextOutputFormat.setOutputPath(job.getInternalJob(), new Path(OUTPUT_PATH)); //删除之前的输出 deletePath(OUTPUT_PATH, true); job.run(true); &#125; /** * 用于删除输出目录 * * @param path 目录路径 */ public static void deletePath(String path, boolean isDirectory) &#123; File file = new File(path); if (file.exists()) &#123; //本地目录递归删除 if (isDirectory) &#123; File[] subFiles = file.listFiles(); for (File subFile : subFiles) &#123; if (subFile.isFile()) &#123; subFile.delete(); &#125; else &#123; deletePath(subFile.getPath(), true); &#125; &#125; &#125; file.delete(); &#125; &#125;&#125; 在 resources 文件夹创建 input 文件夹并放入编程实践中的测试数据 graph_data.txt 验证 修改配置并运行如果在 resources 文件夹下看到输出文件，证明添加自定义入口成功，此时可以进行断点调试 问题 运行时提示 TestYarnJob 中的 MiniYARNCluster 缺失问题 对于 Test 部分的内容因为不影响源码阅读，可以将出错部分注释掉 Thanks Introduction to Apache Giraph Building and Testing]]></content>
      <categories>
        <category>Giraph 基础</category>
      </categories>
      <tags>
        <tag>图计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Giraph 环境搭建]]></title>
    <url>%2F2019%2F08%2F17%2FGiraph%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言 本文主要介绍了 Giraph 的环境搭建过程 运行模式 Giraph 是基于 Hadoop 开发的上层应用，因此其运行模式取决于 Hadoop 的运行模式。关于 Hadoop 的运行模式请参照 Hadoop基础之搭建环境 一文。 搭建过程 本次环境搭建基于 Hadoop 2.5.1 以及 Giraph 1.2.0，系统环境是 Ubuntu 18.04，JDK 版本是 openjdk8。 配置 Hadoop 的环境 首先下载 Hadoop 2.5.1，然后参考 Hadoop基础之搭建环境 完成配置，这里为了简单起见仅使用了默认的 Standalone 模式。 配置 Giraph 下载 Giraph 1.2.0，然后进行解压即可。 配置环境变量 为了更好使用 Giraph ，需要配置如下三个环境变量 123456#Setting Hadoopexport HADOOP_HOME="/your_path/hadoop-2.5.1"export HADOOP_CONF_DIR="$HADOOP_HOME/etc/hadoop"#Setting Giraphexport GIRAPH_HOME="/your_path/giraph-1.2.0-hadoop2-for-hadoop-2.5.1" 验证环境 在 Giraph 同级目录下创建 input 文件夹，然后在 input 文件夹内创建 tiny_graph.txt 文件 1234567891011mkdir inputcd input touch tiny_graph.txtvim tiny_graph.txt#在文件中输入以下数据，其格式为 [source_id,source_value,[[dest_id, edge_value],...]]，如 [0,0,[[1,1],[3,3]]] 表示顶点序号为 0，顶点值为 0，存在序号 0 到 序号 1 的边，值为 1，存在序号 0 到序号 3 的边，值为 3。[0,0,[[1,1],[3,3]]][1,0,[[0,1],[2,2],[3,1]]][2,0,[[1,2],[4,4]]][3,0,[[0,3],[1,1],[4,4]]][4,0,[[3,4],[2,4]]] 在 Giraph 的同级目录下执行命令 1$GIRAPH_HOME/bin/giraph $GIRAPH_HOME/giraph-examples-1.2.0-hadoop2.jar org.apache.giraph.examples.SimpleShortestPathsComputation -vif org.apache.giraph.io.formats.JsonLongDoubleFloatDoubleVertexInputFormat -vip ./input/tiny_graph.txt -vof org.apache.giraph.io.formats.IdWithValueTextOutputFormat -op ./output/shortestpaths -w 1 -ca giraph.SplitMasterWorker=false 这行命令实质是向 Hadoop 提交一个 Job，giraph-examples-1.2.0-hadoop2.jar 是提交的 jar 文件，SimpleShortestPathsComputation 表示 Giraph 将会运行的计算类。其余的各项参数含义为： -vif 用于指定输入数据的格式 -vip 用于指定输入数据的路径，可以看到这里指定了前一步中创建的 tiny_graph.txt 文件 -vof 用于指定输出格式 -op 用于指定输出路径，这里指定的路径是 input 同级目录下的 output 文件夹下的 shortestpaths 文件夹 -w 用于指定 worker 的数量，这里由于在本地运行只能指定为 1 个 -ca 表明指定参数为自定义的参数，这里指定 giraph.SplitMasterWorker 为 false，表明不区分 Master 和 Worker（本地运行必须指定）。更多的自定义参数请参考 🔗 查看结果 运行结束之后进入 output/shortestpaths 将会看到输出文件 part-m-00000，其内容为： 123450 1.01 0.02 2.03 1.04 5.0 这里的验证是针对 Standalone 模式而言，如果需要在 Pseudo-Distributed 和 Full-Distributed 模式下进行验证，只需要把相应的输入文件上传到 HDFS，然后更改执行命令中的输入路径和输出路径即可。 Thanks Quick Start]]></content>
      <categories>
        <category>Giraph 基础</category>
      </categories>
      <tags>
        <tag>图计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Giraph 简介]]></title>
    <url>%2F2019%2F08%2F11%2FGiraph%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前言 本文主要阐述了 Giraph 由来及其作用，并根据 Giraph 的系统架构和计算模型简要介绍了 Giraph 的运行流程。 什么是 Giraph Giraph 是 Google 于 2010 年发布的论文 Pregel: a system for large-scale graph processing 的开源实现。Giraph 是以 Hadoop 为基础开发的上层应用，其系统架构和计算模型与 Pregel 保持了一致。同时也在 Pregel 模型上增加了一些新的特性，如：out-of-core computation、edge-oriented input 等。Giraph 的目的是为了解决大规模图的分布式计算问题。通过隐藏分布式和并行计算的细节以及提供一套用于描述图算法的 API，Giraph 不仅拥有了很好的可扩展性，还降低了分布式图计算的使用门槛。 系统架构 上图蓝色部分标识了 Giraph 的系统架构，可以看到 Giraph 实质上还是一个 Master/Slave 的架构，主要由三个部分构成： Master Master 实质上运行在 Hadoop 的 MapTask 上， 其主要作用是对输入图进行分区、协调 Worker 的活动、维护一份存活的 Worker 列表（包括 Worker 的标识符、地址信息等）以及更新 Job 的状态。 Worker 与 Master 一样，Worker 也运行在 Hadoop 的 MapTask 上，其主要作用是维护已分配图的状态。 Zookeeper 在 Giraph 中 Zookeeper 的主要作用是 Master 选举、命名服务以及协调服务。图中显示的 Zookeeper 是外置状态，但实际上如果不给 Giraph 提供外置 Zookeeper，那么 Giraph 将会在 Master 所在节点上自行启动一个 Zookeeper 来提供服务。 计算模型 上图显示了 Giraph 的整个计算模型，主要由输入、一系列 Superstep 迭代计算、输出构成，其中这些 Superstep 被称之为 BSP(Bulk Synchronous Parallelism) 模型。 BSP 模型 BSP 模型是一个块同步并行模型，其由许多个 Superstep 组成。对于 BSP 模型而言，其在 Superstep 内的操作是并行的，但在两个 Superstep 之间则是由一个同步操作进行隔离的。也就是说 Superstep(N + 1) 会等待 Superstep(N) 执行完成之后才会开始。 上图显示了 Superstep 的结构图，一个 Superstep 由局部计算、通讯、栅栏同步 三个部分构成。可以看到即使有部分的计算比较快，但最终还是会在栅栏同步这里停下等待其余的计算完成。在图计算中应用这种模型的好处是：可以解决图计算的同步问题，同步模型有利于推断程序语义（即利于编程），并且消除了死锁和数据竞争的问题。 计算过程 上图展示了一个计算图中顶点最大值的过程，其中深色的顶点表示本次 Superstep 结束之后将自己标记为不活跃状态（即不再需要进行计算），当所有顶点均处于不活跃状态的时候即表明计算结束。下面针对各个 Superstep 进行分析： Superstep0 Superstep0 时所有的顶点处于活跃状态并沿出边发送其顶点值 Superstep1 Superstep1 时每个顶点处理 Superstep0 发来的顶点值，第一、四个顶点[从左往右计数]发现有更大的顶点值 6，所以更新其顶点值为 6 ，并沿出边发送更新之后的顶点值。而第二、三个顶点发现并没有比它们顶点值更大的顶点值，因此两个顶点将自身标记为不活跃状态。 Superstep2 Superstep2 时由于第二个顶点收到了 Superstep1 发送过来的顶点值，所以系统会将第二个顶点标记为活跃状态然后去处理接收到的顶点值，但第二个顶点依旧发现没有比它更大的顶点值，所以会再次标记自己为不活跃状态。第一、四个顶点由于没有接收到 Superstep1 发来的顶点值，所以会将其标记为不活跃状态。第三个顶点在处理 Superstep1 发来的顶点值时，发现了比它更大的顶点值 6，所以会进行更新然后沿出边发送更新之后的顶点值。 Superstep3 Superstep3 阶段只有第二、四顶点接收到了 Superstep2 发来的顶点值，所以跟 Superstep2 中处理方式一致，系统先标记为这两个顶点为活跃状态，顶点比较接收的顶点值之后将自身标记为不活跃状态。至于第一、四顶点因为处于不活跃状态且没有收到上一个超步接收到的顶点值，所以不会进行处理从而依旧保持不活跃状态。至此整个计算过程就结束了。 运行流程 在了解了 Giraph 的系统架构和计算模型之后，这里简单介绍一下 Giraph 的整个运行流程： Giraph 向 Hadoop 提交 Job 之后，Zookeeper 将会选出一个 MapTask 作为 Giraph 的 Master，其余的 MapTask 则作为 Worker。然后这些 Worker 会通过 Zookeeper 命名服务找到 Master，并向 Master 进行注册。 Master 将会对输入图进行分区，并发送分区信息给 Worker，Woker 会对分区进行读取，期间可能会发生 Worker 之间的分区交换。 之后 Master 会开始协调 Worker 迭代执行 Superstep，Worker 将会在 Superstep 中完成顶点的计算过程，直到所有的顶点处于不活跃状态之后结束计算。 在计算结束之后，Giraph 将会根据用户指定的格式输出结果。 总结 上述简要介绍了 Giraph 的核心知识，即架构和计算模型。但除此之外，Giraph 中还有重要的优化和容错机制尚未介绍，这些都需要后续学习的时候进行整理分析。 Thanks Pregel: a system for large-scale graph processing Pregel（图计算）技术原理 BSP模型的相关讲解 从BSP模型到Apache Hama Introduction to Apache Giraph]]></content>
      <categories>
        <category>Giraph 基础</category>
      </categories>
      <tags>
        <tag>图计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop 基础之 HDFS 入门]]></title>
    <url>%2F2019%2F05%2F11%2FHadoop%E5%9F%BA%E7%A1%80%E4%B9%8BHDFS%2F</url>
    <content type="text"><![CDATA[前言 本文主要介绍了 HDFS 的体系架构以及其执行流程，并给出了读写操作的编程实例，希望对 HDFS 有个初步的认识。 简介 HDFS (Hadoop Distributed File System) 是一个运行在商业 PC 上的分布式文件系统，其设计思想源自于 Google 2003 年发布的论文 The Google File System 。HDFS的主要目的是为了解决大规模数据存储和管理的问题。 体系架构 上图表明 HDFS 是一个标准的 master/slave 架构，主要由三个部分构成： NameNode（master 节点） 元数据（MetaData）的管理，其中元数据由文件路径名、数据块ID以及存储位置等信息构成 管理 HDFS 的名字空间。 SecondaryNameNode 定期合并 NameNode 的 edit logs（对文件系统的改动序列） 到 fsimage（对整个文件系统的快照），并拷贝修改后的 fsimage 到 NameNode。 提供一个 NameNode 的检查点（切忌认为是 NameNode 的备份），可用于 NameNode 的故障恢复。 DataNode（slave 节点） 提供文件存储和进行数据块操作。 周期性的向 NameNode 汇报块信息。 这里对图中出现的一些概念进行说明： Replication（副本） 为了保证数据的高可用，HDFS 会对写入的数据进行冗余存储，默认情况下会保存 3 份。 Blocks Block 是最基本的存储和操作单位（默认情况下为 128M），这里的 Block 不是指物理 Block ，而是指文件系统的 Block，其大小一般是物理 Block 的整数倍。 执行流程 读文件 读文件的过程可以概括为： Client 向 NameNode 发起请求获取文件数据块位置信息 Client 按照数据块距 Client 的远近依次进行连接然后读取数据 写文件 写文件的过程可以概括为： Client 向 NameNode 发起写文件的请求获得可写的 DataNode 列表等信息 Client 根据 HDFS 设定的分块大小对文件进行分块 Client 和 NameNode 分配的 DataNode 构成 pipeline 并进行数据写入 写入完成之后，NameNode 接收来自 DataNode 的消息进行元数据的更新 常用命令 文件操作 列出文件 1hdfs dfs -ls &lt;path&gt; 创建目录 1hdfs dfs -mkdir &lt;path&gt; 上传文件 1hdfs dfs -put &lt;localsrc&gt; &lt;dst&gt; 输出文件内容 1hdfs dfs -cat &lt;src&gt; 文件复制到本地 1hdfs dfs -get &lt;src&gt; &lt;localdst&gt; 删除文件和目录 12hdfs dfs -rm &lt;src&gt;hdfs dfs -rmdir &lt;dir&gt; 管理 查看统计信息 1hdfs dfsadmin -report 进入和退出安全模式（该模式不允许文件系统有任何修改） 12hdfs dfsadmin -safemode enterhdfs dfsadmin -safemode leave 编程实例 IDEA 新建 Maven 项目 勾选相关选项后，点击 next 填入项目相关信息即可 pom.xml 中添加依赖 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; //根据 Hadoop 版本进行选择 &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 读写文件 创建 Sample 类编写相应的读写函数 Sample 类 123456789101112131415161718192021222324252627282930313233343536373839import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FSDataInputStream;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import java.io.*;/** * @author ikroal */public class Sample &#123; //默认的 HDFS 地址 private static final String DEFAULT_FS = "hdfs://localhost:9000"; private static final String PATH = DEFAULT_FS + "/tmp/demo.txt"; private static final String DEFAULT_FILE = "demo.txt"; public static void main(String[] args) &#123; Configuration conf = new Configuration(); FileSystem fs = null; conf.set("fs.defaultFS", DEFAULT_FS); //配置 HDFS 地址 try &#123; fs = FileSystem.get(conf); write(fs, DEFAULT_FILE, PATH); read(fs, PATH); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fs != null) &#123; fs.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; write 函数 123456789101112131415161718192021222324252627282930/*** 进行文件写入* @param inputPath 待写入文件路径* @param outPath HDFS 的写入路径*/public static void write(FileSystem fileSystem, String inputPath, String outPath) &#123; FSDataOutputStream outputStream = null; FileInputStream inputStream = null; try &#123; outputStream = fileSystem.create(new Path(outPath)); //获得 HDFS 的写入流 inputStream = new FileInputStream(inputPath); //读取本地文件 int data; while ((data = inputStream.read()) != -1) &#123; //写入操作 outputStream.write(data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (outputStream != null) &#123; outputStream.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; read 函数 1234567891011121314151617181920212223242526272829/*** 进行文件读取* @param path HDFS 上待读取文件路径*/public static void read(FileSystem fileSystem, String path) &#123; FSDataInputStream inputStream = null; BufferedReader reader = null; try &#123; inputStream = fileSystem.open(new Path(path)); //获取 HDFS 读取流 reader = new BufferedReader(new InputStreamReader(inputStream)); String content; while ((content = reader.readLine()) != null) &#123; //读取并输出到控制台 System.out.println(content); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (inputStream != null) &#123; inputStream.close(); &#125; if (reader != null) &#123; reader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在工程文件夹的根目录下创建计划上传的文件（这里是 demo.txt），填入 Hello World！ 启动 Hadoop 然后运行程序查看结果 通过 http://localhost:50070/explorer.html#/ 可以查看写入结果 控制台则会输出上传文件的内容 Thanks 初步掌握HDFS的架构及原理 深入理解HDFS：Hadoop分布式文件系统 HDFS读写流程（史上最精炼详细） Hadoop学习之路（十一）HDFS的读写详解]]></content>
      <categories>
        <category>Hadoop 基础</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop 基础之搭建环境]]></title>
    <url>%2F2019%2F05%2F04%2FHadoop%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言 本文主要介绍了 Hadoop 的三种运行模式以及配置的方式。 运行模式 Hadoop 的运行模式分为三种： Standalone（本地模式/单机模式/local模式） 该模式下没有任何守护进程，用户程序和 Hadoop 程序运行在同一个 Java 进程，使用的文件系统是本地文件系统而不是分布式文件系统，此模式下一般用于本地调试。 Pseudo-Distributed（伪集群模式） 在单机上模拟集群模式，各守护进程运行在单独的 Java 进程当中，使用的文件系统是 HDFS Fully-Distributed（集群模式） 守护进程运行在集群上，使用的文件系统也是 HDFS 配置过程 本次配置基于 Hadoop2.9.2，其中 Standalone 在 CentOS 7.2 系统下进行配置， Pseudo-Distributed 模式在 MacOS 10.14.4 上进行配置，Fully-Distributed 模式在腾讯云主机上进行配置，集群由两台云主机组成，分别运行 Ubuntu 14.04.1 和 CentOS 7.2 系统。 环境准备 Java 7/8 Hadoop 2.7.x to 2.x 支持 Java 7/8，其它 Hadoop 版本支持的 Java 版本请点击 🔗 进行查询 下载： 1sudo yum install java-1.8.0-openjdk-devel //centos 安装 Java8，ubuntu 下需要用 apt-get 进行安装 配置环境变量： 1234cd ~vi .bash_profileexport JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386source .bash_profile ssh 和 rsync: 用 ssh 和 rsync 命令测试后发现 Centos 本身就有，所以无须进行安装。 Hadoop 12sudo wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-2.9.2/hadoop-2.9.2.tar.gztar -zxvf hadoop-2.9.2.tar.gz 这里的下载地址最好根据云主机所在的区域进行选择，如果是国内的云主机最好使用国内的镜像地址，这样下载会快很多。 Standalone 模式 下载解压之后的 Hadoop 默认就是 Standalone 模式，可直接运行 wordcount 进行测试 12345mkdir input //hadoop 的同级目录创建cp hadoop-2.9.2/LICENSE.txt input/hadoop-2.9.2/bin/hadoop jar hadoop-2.9.2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar wordcount input output //运行 wordcountcat output/part-r-00000 //查看结果 同时再开一个终端在作业运行的时候输入 jps 查看进程 可以看到 Standalone 模式下 Hadoop 只会启动 RunJar 进程来运行整个作业 Pseudo-Distributed 模式 修改 etc/hadoop/core-site.xml 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;!--配置访问 nameNode 的 URI--&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;!--指定临时目录，MapReduce 和 HDFS 的许多路径配置依赖此路径--&gt; &lt;value&gt;/home/hadoop/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 etc/hadoop/hdfs-site.xml 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;!--配置文件的副本数量--&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;!--关闭防火墙--&gt; &lt;/property&gt;&lt;/configuration&gt; 配置免密登录 1234ssh localhost 测试能否免密登录（如果能够则跳过以下操作）ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsacat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 0600 ~/.ssh/authorized_keys 修改 etc/hadoop/hadoop-env.sh（如果提示找不到 JAVA_HOME） 1export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386 //上面配置的 JAVA_HOME 好像没起作用 格式化 HDFS 1bin/hdfs namenode -format 启动 HDFS 1sbin/start-dfs.sh 启动后输入 jps 看到以下进程即成功，这个时候可以通过 http://localhost:50070/ 访问 NameNode 运行 wordcount 123456bin/hdfs dfs -mkdir /userbin/hdfs dfs -mkdir /user/&lt;username&gt;bin/hdfs dfs -mkdir /user/&lt;username&gt;/inputbin/hdfs dfs -put LICENSE.txt /user/&lt;username&gt;/input //创建文件夹并上传文件bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar wordcount input output //运行 wordcountbin/hdfs dfs -cat output/part-r-00000 //显示结果 在另一终端输入 jps 可以看到运行时的以下进程 依旧是用 RunJar 提交，只是读取和写入采用了 HDFS。 通过 YARN 执行 Job（可选配置，不过为了更接近真实集群还是建议配置） 修改 etc/hadoop/mapred-site.xml 12cp etc/hadoop/mapred-site.xml.template etc/hadoop/mapred-site.xmlvi etc/hadoop/mapred-site.xml 增加以下内容 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;!--表明运行在 YARN 上--&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 etc/hadoop/yarn-site.xml 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;&lt;!--设置resourcemanager的hostname--&gt; &lt;value&gt;localhost&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;!--指定 nodemanager 获取数据的方式--&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 启动 YARN 1sbin/start-yarn.sh 启动成功后可以通过 http://localhost:8088/ 访问 ResourceManager 节点，并且输入 jps 会显示以下进程 其中 ResourceManager 和 NodeManager 是属于 YARN 的进程。 重复 7 的操作，输入 jps 查询进程 可以看到新增加了 YarnChild 进程和 MRAppMaster 进程，之所以有两个 YarnChild 进程是因为输入文件夹中存在两个文本文件，这说明了 MapReduce 是通过创建多个进程并行计算的。 Fully-Distributed 模式 集群包括两个节点，节点名分别为 master 和 slave，master 和 slave 的节点配置过程基本一致，以下是配置过程（两个节点差异配置会进行注明，建议先配置好 master 节点的 Hadoop，然后用 scp 命令复制到 slave 节点进行修改。）： 修改 /etc/hosts 12152.136.76.12 master //腾讯云公网ip94.191.43.137 slave 免密登录（⚠️两个节点的登录名必须一致，这里都为 root） 123456789master 节点配置本机免密登录以及移动公钥到子节点ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsacat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 0600 ~/.ssh/authorized_keysscp ~/.ssh/id_rsa.pub root@slave:~/slave 节点配置 master 节点免密登录cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keys 修改 etc/hadoop/core-site.xml 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;!--配置访问 nameNode 的 URI--&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;!--指定临时目录，MapReduce 和 HDFS 的许多路径配置依赖此路径--&gt; &lt;value&gt;/home/hadoop/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 etc/hadoop/hdfs-site.xml 12345678910111213141516&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;!--配置文件的副本数量--&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;!--关闭防火墙--&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;slave:50090&lt;/value&gt; &lt;!-- 指定secondarynamenode位置 --&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 etc/hadoop/mapred-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;!--表明运行在 YARN 上--&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 etc/hadoop/yarn-site.xml 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;&lt;!--设置resourcemanager的hostname--&gt; &lt;value&gt;master&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;!--指定 nodemanager 获取数据的方式--&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 etc/hadoop/hadoop-env.sh 12export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386 //master 和 slave 填入各自路径export HADOOP_LOG_DIR=/root/hadoop/hadoop-2.9.2/logs //可以自己选定 修改 etc/hadoop/mapred-env.sh 1export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386 修改 etc/hadoop/yarn-env.sh 12export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386 export YARN_LOG_DIR=/root/hadoop/hadoop-2.9.2/logs 修改 etc/hadoop/slaves 12masterslave 启动 HDFS 和 YARN 123bin/hdfs namenode -format //首次运行时格式化sbin/start-dfs.shsbin/start-yarn.sh 在 master 和 slave 节点分别输入 jps 后有 此时可以通过 http://152.136.76.12:8080 (ip 为 master 的公网 ip) 以及 http://152.136.76.12:50070 分别访问 HDFS 的 web 界面和 YARN 的 web 界面，可以看到 HDFS 下有一个 slave 节点，YARN 下有两个节点 运行 wordcount（与伪分布式中一致） 123456bin/hdfs dfs -mkdir /userbin/hdfs dfs -mkdir /user/&lt;username&gt;bin/hdfs dfs -mkdir /user/&lt;username&gt;/inputbin/hdfs dfs -put LICENSE.txt /user/&lt;username&gt;/input bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar wordcount input outputbin/hdfs dfs -cat output/part-r-00000 继续用 jps 查看两台主机的进程 可以看到集群模式中的进程与伪集群模式中的进程没有区别，唯一的区别在于进程在不同的主机上运行。 错误 这里主要记录配置过程中遇到的一部分错误 Container exited with a non-zero exit code 1. Error file: prelaunch.err. 该错误是在腾讯云主机上配置的伪集群模式运行 wordcount 时出现的，尝试了网上的一些办法都没有解决。最后采用自己电脑配置再运行一遍成功，可能是因为云主机的配置问题。 在 YARN 上运行 Java.net.ConnectException: Connection refused 可能是防火墙的原因，根据 🔗 中的提示解决 无法外网访问VM中的 Hadoop YARN 的8088端口 无法通过云主机 ip:8088 访问 YARN 的 Web 页面时，不妨通过 netstat -nlp | grep java 查看当前提供 web 服务的端口，如果 ip 是 127.0.0.1 证明存在问题，需要修改 hosts，具体过程见 🔗。 slave: bash: line 0: cd: /root/hadoop/hadoop-2.9.2: No such file or directory 配置集群模式时出现，主要原因是手动配置 slave 时 Hadoop 存放路径与 master 不一致，只需要将 slave 的 Hadoop 放在与 master 的同一路径下即可解决。 Thanks Hadoop完全分布式部署 Hadoop三种模式介绍 hadoop的三种运行模式区别及配置详解]]></content>
      <categories>
        <category>Hadoop 基础</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop 基础之生态圈]]></title>
    <url>%2F2019%2F04%2F21%2FHadoop%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%94%9F%E6%80%81%E5%9C%88%2F</url>
    <content type="text"><![CDATA[前言 本文主要目的是介绍 Hadoop 的基本架构以及衍生出来的各种工具，以期对 Hadoop 有个整体的认识。 Hadoop 生态系统 Hadoop 生态系统是指以 分布式的文件系统 HDFS、分布式的计算框架 MapReduce 以及资源管理器 YARN为基础构成的分布式数据处理系统，其结构图如下图所示： 下面将对图中各项组件做一个介绍 HDFS HDFS 是 Google 于 2003 发表的 分布式文件系统 GFS 论文的开源实现版本，主要目的是使用普通商业电脑解决大量数据的存储以及读取速度问题，在 GFS 出现之前一般主要在单台计算机用 RAID 来提高数据存储量和读取速度。但是采用 RAID 一方面成本比较高（需求太高时可能只有超级计算机才能满足），另一方面数据量过大时可能超级计算机也无法满足需求。所以这个时候就需要采取分布式的方式去满足扩大存储（多台机器多个磁盘）和增加读取速度的需求（多台机器可以同时读）。 MapReduce MapReduce 是一个分布式的计算框架，在 MapReduce 出现之前就已经有了分布式计算这个概念。但是大多数分布式计算只能专门用于处理一类运算，而 Google 在大量实践中总结出了一个通用的编程模型： map 和 reduce。其中 map 是指分开计算的过程，而 reduce 是指合并结果的过程。而在这一编程模型添加的一系列机制和操作构成了 MapReduce。MapReduce 大大降低了分布式计算的门槛，对于开发人员而言只需要编写一系列 map 和 reduce 函数即可完成所需的分布式计算过程。 YARN YARN 是一个资源管理框架，主要作用是负责集群的资源调度和作业任务管理。YARN 的出现源于 Hadoop 不能满足统一使用集群资源的需求，因为 Hadoop1 中集群的资源调度和任务管理与 MapReduce 的执行过程是耦合在一起的，而后续出现的 Spark、Storm 等分布式计算系统其架构和执行过程与 MapReduce 不同，无法直接向 Hadoop 申请集群资源。所以为了实现集群资源的统一管理，在 Hadoop2 中对 MapReduce 进行了一个解耦，抽离出了 YARN 这个框架。 ZooKeeper Zookeeper 主要作用是提供一个分布式、高可用的协调服务，解决分布式环境下的数据管理问题：统一命名，状态同步，集群管理，配置同步等。 Pig 虽然 MapReduce 极大的简化了分布式计算编程的门槛，但是 Yahoo 的工程师依然觉得 MapReduce 编程太过麻烦，所以他们便开发了 Pig 这个脚本语言用于描述对大数据集的操作。这样就可以通过编译 Pig 脚本生成对应的 MapReduce 程序。 Hive 为了方便使用 SQL 的工程师使用 MapReduce，Facebook 的工程师开发了 Hive，通过 Hive 熟悉数据库的工程师可以无门槛的使用 MapReduce。 Mahout Mahout 的主要目标是创建一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便快捷地创建智能应用程序。Mahout 现在已经包含了聚类、分类、推荐引擎（协同过滤）和频繁集挖掘等广泛使用的数据挖掘方法。 Tez Tez 是 Apache 最新开源的支持 DAG 作业的计算框架，它直接源于 MapReduce 框架，核心思想是将 Map 和 Reduce 两个操作进一步拆分，即 Map 被拆分成 Input、Processor、Sort、Merge和Output， Reduce 被拆分成 Input、Shuffle、Sort、Merge、Processor 和 Output 等。 Hase HBase 是一个建立在 HDFS 之上，面向列的针对结构化数据的可伸缩、高可靠、高性能、分布式和面向列的动态模式数据库。 Flume Cloudera 开源的日志收集系统，具有分布式、高可靠、高容错、易于定制和扩展的特点。 Sqoop Sqoop 是 SQL-to-Hadoop 的缩写，主要用于传统数据库和 Hadoop 之前传输数据。数据的导入和导出本质上是Mapreduce 程序，充分利用了 MR 的并行化和容错性。 Ambari Ambari 的作用来说，就是创建、管理、监视 Hadoop 的集群，是为了让 Hadoop 以及相关的大数据软件更容易使用的一个 web 工具。 总结 总的来说 HDFS 、MapReduce 以及 YARN 是 Hadoop 的核心组件，而我们学习 Hadoop 最好从核心组件开始学习其原理机制，再逐渐往上层进行了解。 Thanks Hadoop生态圈总结——大数据 hadoop生态圈各个组件简介 大数据技术Hadoop入门理论系列之一----hadoop生态圈介绍 从0开始学大数据---极客时间]]></content>
      <categories>
        <category>Hadoop 基础</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础之集合框架(一)：集合框架]]></title>
    <url>%2F2018%2F03%2F17%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题 集合类应该是平时使用的非常频繁的类了，但是对其内部构成却一直不太清晰，所以希望通过本篇文章尝试去理解集合框架的整体设计以及集合存在的必要性。在开始分析之前首先让我们思考以下问题： 集合存在的意义，集合和数组的区别 集合框架的设计意图 集合的常用操作 集合存在的意义以及与数组的区别 想要了解 Java 为什么会设计集合，就得先明白集合的出现解决了什么问题，关于这一问题「Java 编程思想」中是这么描述的 如果一个程序中只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序。 通常，程序总是根据运行时才知道的某些条件去创建新对象。在此之前，不会知道所需对象的数量，甚至不知道确切的类型。 所以之所以需要集合是因为在编程的过程中会需要保存数量不定、类型不定的数据。 针对数量不定考虑下面这种情况 123456789101112131415161718public class Demo &#123; private static final int COUNT = 10; private static final String STOP_FLAG = "s"; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String collection[] = new String[COUNT]; System.out.println("输入即将保存的数据"); int i = 0; while (!(collection[i] = scanner.next()).equals(STOP_FLAG)) &#123; i++; &#125; scanner.close(); for (i = 0; i &lt; collection.length; i++) &#123; System.out.print(collection[i] + " "); &#125; &#125;&#125; 作为一个简单的输入程序，采用数组的形式去保存用户的输入，当用户的输入超过数组可容纳的数量的时候便会抛出异常，这个问题如何解决呢？一种方式是将数组的数量分配的足够大，但是采取这种方式极有可能浪费内存空间。另一种方式则是动态扩展大小，通过动态扩展大小既能够容纳足够多的元素，又能够节约内存空间。而集合正具备动态扩展大小这一特性，所以在这种情况下，集合就体现出了它的作用。 至于类型不定，考虑另一种情况 123456789101112131415161718192021222324252627282930313233package com.rookieyang.collections;public class DataArray &#123; private String datas[]; private int index; private static final int COUNT = 5; public DataArray() &#123; datas = new String[COUNT]; &#125; //也可自行对数组进行动态扩展，这里只是测试 public void addData(String data)&#123; try &#123; datas[index] = data; index++; &#125; catch (IndexOutOfBoundsException e) &#123; System.out.println("超出最大的存储范围"); &#125; &#125;&#125;package com.rookieyang.collections;import java.util.List;public class DataCollection&lt;T&gt; &#123; private List&lt;T&gt; datas; public void addData(T data) &#123; datas.add(data); &#125;&#125; 可以看出对于数组而言在动态添加数据会略显麻烦，而且只能保存 String 类型数据，但对于采用集合而言，使用起来不仅简单而且其扩展性也强，我们可以根据自己的需求决定集合中保存何种类型数据，这就实现了代码的复用。 对于集合和数组而言，其主要区别如下 数组是静态的，一个数组实例具有固定的大小，集合是动态的，可以根据实际需要动态扩展大小 数组既可以保存基本类型，也可保存引用类型，集合只能保存引用类型，在保存基本类型的时候会自动装箱 集合整体框架分析 首先看下集合的整体框架图，对于集合而言主要分为两个部分：Collection 和 Map，其中 Collection 主要保存的是单个元素，而 Map 则可以将某些对象与其它一些对象存在的关系用 key-value 方式保存下来。接下来我们将就这两个部分展开分析。 Collection 接口 结构分析 这里为了方便分析只展示了接口的继承结构 首先查看 Iterable 123456789101112131415public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; Itrable 接口中拥有一个 iterator 方法以及两个 1.8 添加的默认方法： iterator：返回一个迭代器用于遍历 forEach：根据给定的 action 处理每个元素 spliterator：提供了一个用于并行遍历的迭代器，由于这里主要探讨结构设计，所以暂且不展开说明 看到这里我产生了第一个疑问，为什么 Collection 不直接继承 Iterator 接口，而需要用 Iterable 进行包装之后再继承呢？ 这里假设存在一个 CustomizeCollection 接口在包含了 Collection 接口方法的基础上继承了 Iterator 接口而不是 Iterable（或者是直接包含了 Collection 接口方法以及 Iterator 接口方法），那么当我们实现 CustomizeCollection 接口的时候所得到的 CustomizeClass 类结构将如下图所示： 可以看到如果想实现 CustomizeCollection 则必须要实现 Iterator 接口方法，很显然采用这种方式可能导致在不同的 CustomizeCollection 接口实现类中存在相同的 Itrator 接口方法实现（遍历这一操作某些时候可能是通用的），这样一来就降低了代码的复用性，另外从单一职责的角度来考虑，CustomizeCollection 接口中揉合了集合元素的管理功能以及迭代器的功能，而采用 Iterable 包装之后则可以将这两个功能进行一定程度上的分割。 接着从 Collection 又延展出三个接口，这三个接口是对集合功能的具体化： Set 表示的是无序、不存在重复元素的集合 List 表示的是一种有序、可重复元素的集合 Queue 表示的是一种队列，其实队列也是一种有序的集合，但之所以会单独设计出一个接口的原因在于，Queue 接口去除了很多不需要的功能，使得接口本身更符合单一职责以及接口隔离原则。 功能分析 Collection 接口的功能大致概括如下（暂不介绍 1.8 引入的默认方法） 增加 boolean add(E e) 增加单元元素 boolean addAll(Collection&lt;? extends E&gt; c) 增加集合 c 的元素 删除 boolean remove(Object o) 移除元素 boolean removeAll(Collection&lt;?&gt; c) 移除集合 c 的元素 void clear() 清空集合 查询 boolean contains(Object o) 查询集合是否存在元素 o boolean containsAll(Collection&lt;?&gt; c)查询当前集合是否存在集合 c 中的所有元素 boolean isEmpty() 查询是否集合为空 int size() 查询集合的大小 其它 Iterator iterator() 返回迭代器 boolean retainAll(Collection&lt;?&gt; c) 取当前集合和集合 c 的交集 Set 接口与 Colleciton 接口定义的方法完全一致 List 接口在 Collectiion 接口基础上新增了一些与索引有关的方法 增加 void add(int index, E element) 在 index 处插入元素 删除 E remove(int index) 删除 index 处的元素 修改 E set(int index, E element) 修改 index 的元素为 element 查询 E get(int index) 获取 index 处的元素 int indexOf(Object o) 获取元素 o 第一次出现的 index int lastIndexOf(Object o) 获取元素 o 最后一次出现的 index 其它 ListIterator listIterator() 返回 ListIterator 类型的迭代器 ListIterator listIterator(int index) 返回从 index 开始的 ListIterator 类型的迭代器 Queue 接口新增的方法如下 出队 E peek() 出队但是不删除元素，在队列为空的时候返回 null E element() 出队但是不删除元素，在队列为空的时候抛出异常 E poll() 出队并且删除元素，在队列为空的时候返回null E remove() 出队并且删除元素，在队列为空的时候抛出异常 入队 boolean offer(E e) Map 接口 结构分析 Map 是一个单一的接口，并没有在此基础上进行扩展，但在 Map 接口的内部有一个 Entry 接口： 1234567891011121314interface Entry&lt;K,V&gt; &#123; K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); .....&#125; 可以看到 Entry 里面封装的都是和 Map 中元素有关的操作，这一接口主要用来规定 Map 中用来存储 key-value 所需要提供的功能 功能分析 Map 接口的功能大致如下： 增加或修改 V put(K key, V value) 存储 key 和 value，如果 key 已经存在则会将原来的 value 替换为新的 value void putAll(Map&lt;? extends K, ? extends V&gt; m) 将 m 中的 key 和 value 添加到当前 Map 中 删除 V remove(Object key) 移除指定的 key 以及关联的 value void clear() 清空 Map 查找 V get(Object key) 获取 key 关联的 value boolean containsKey(Object key) 判断当前 Map 是否包含指定的 key boolean containsValue(Object value) 判断当前Map 是否包含指定的 value boolean isEmpty() 判断当前 Map 是否为空 int size() 获取当前 Map 的大小 其它 Set keySet() 将 key 生成 Set 集合 Collection values() 将 value 生成集合 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 将 Map 中保存的元素生成 Set 集合，一般用于遍历集合 从 Map 接口所提供的方法来看，大部分方法其实与 Collection 接口中无异，只是在 Collection 中是对单个元素进行操作，但是在 Map 接口中是对 key-value 这种关联元素进行操作。 总结 Java 集合框架以 Colleciton 和 Map 为基础，高度抽象了对单个元素以及键值对的操作，而在此基础上为了减轻业务开发难度，集合框架又提供了多个实现类以供使用，尽管看起来错综复杂，但是只要了解核心的接口之间的继承关系便可对集合框架有个较为清晰的认识。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android启动过程简析（四）之Lanucher的启动]]></title>
    <url>%2F2018%2F02%2F28%2FAndroid%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E7%AE%80%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 通过Android启动过程简析（三）这篇文章我们已经大致了解了服务是如何被启动的，接着本文将会分析系统启动的最后一步，即 Launcher 的启动。 Lanucher的启动流程 在 SystemServer 中启动的这么多服务当中 ActivityManagerService 是负责四大组件的启动、切换、调度的，所以 Launcher 的启动与 ActivityManagerService 离不开关系 frameworks/base/services/java/com/android/server/SystemServer.java 1234567891011121314151617181920private void startOtherServices() &#123; .... // We now tell the activity manager it is okay to run third party // code. It will call back into us once it has gotten to the state // where third party code can really run (but before it has actually // started launching the initial applications), for us to complete our // initialization. mActivityManagerService.systemReady(new Runnable() &#123; @Override public void run() &#123; .... try &#123; startSystemUi(context); &#125; catch (Throwable e) &#123; reportWtf("starting System UI", e); &#125; ... &#125;);&#125; 可以看到在 startOtherServices 中调用了 mActivityManagerService 的 systemReady 方法，并在传入的 Runnable 对象中启动了 SystemUi，接着继续查看 systemReady 方法 frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void systemReady(final Runnable goingCallback) &#123; synchronized(this) &#123; //第一次为false不会进入 if (mSystemReady) &#123; // If we're done calling all the receivers, run the next "boot phase" passed in // by the SystemServer if (goingCallback != null) &#123; goingCallback.run(); &#125; return; &#125; .... mSystemReady = true; &#125; ... synchronized(this) &#123; // Make sure we have no pre-ready processes sitting around. if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; .... &#125; &#125; ... //执行传入的Runnable对象 if (goingCallback != null) goingCallback.run(); ... synchronized (this) &#123; // Only start up encryption-aware persistent apps; once user is // unlocked we'll come back around and start unaware apps startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE); // Start up initial activity. mBooting = true; // Enable home activity for system user, so that the system can always boot ... //启动Lanucher的主Activity startHomeActivityLocked(currentUserId, "systemReady"); ... mStackSupervisor.resumeFocusedStackTopActivityLocked(); mUserController.sendUserSwitchBroadcastsLocked(-1, currentUserId); &#125;&#125; 在 systemReady 方法中会调用 startHomeActivityLocked 123456789101112131415161718192021222324252627282930boolean startHomeActivityLocked(int userId, String reason) &#123; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) &#123; // We are running in factory test mode, but unable to find // the factory test app, so just sit around displaying the // error message and don't try to start anything. return false; &#125; //构建启动Lanucher主Activity的Intent对象 Intent intent = getHomeIntent(); ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being // instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //启动Lanucher主Activity mActivityStarter.startHomeActivityLocked(intent, aInfo, reason); &#125; &#125; else &#123; Slog.wtf(TAG, "No home screen found for " + intent, new Throwable()); &#125; return true;&#125; 进入 startHomeActivityLocked 方法之后可以看到调用了 getHomeIntent 返回了一个 Intent，我们都知道启动一个 Activity 的信息都是通过 Intent 进行传递的，所以继续查看 getHomeIntent 看看 Intent 包含的信息 12345678910Intent getHomeIntent() &#123; //mTopAction 是 android.intent.action.MAIN Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null); intent.setComponent(mTopComponent); intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; intent.addCategory(Intent.CATEGORY_HOME); &#125; return intent;&#125; 在 getHomeIntent 中首先创建了一个 Intent 对象，然后给这个对象增加了一个 category，category 对应的信息是 android.intent.category.HOME，查找 Lanucher3 的 AndroidManifest.xml 可以看见 12345678910111213141516171819&lt;activity android:name="com.android.launcher3.Launcher" android:launchMode="singleTask" android:clearTaskOnLaunch="true" android:stateNotNeeded="true" android:theme="@style/Theme" android:windowSoftInputMode="adjustPan" android:screenOrientation="nosensor" android:configChanges="keyboard|keyboardHidden|navigation" android:resumeWhilePausing="true" android:taskAffinity="" android:enabled="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.HOME" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.MONKEY"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 这说明即将启动的 Activity 是 com.android.launcher3.Launcher，现在回到 startHomeActivityLocked 方法中，继续往下看可以知道在得到 Intent 对象之后，最后是通过 ActivityStarter 的 startHomeActivityLocked 启动了 Launcher。之后的部分由于涉及到 Lanucher 源码和 Activity 启动的细致流程，所以就暂时不做分析了。 总结 通过四篇文章的分析对系统启动的过程有了一个大致的了解，但是限于水平有限，有些部分分析的比较粗糙，希望之后在水平提升之后能够对各个部分进行进一步的完善，例如：Binder、ActivityManagerService、Acitvity 的启动过程等等。 最后借用 Gityuan Android系统开篇中的一张图片说明系统启动的过程 Thanks Android系统启动流程（四）Launcher启动过程与系统启动流程]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白话深度学习-基础篇]]></title>
    <url>%2F2018%2F01%2F28%2F%E7%99%BD%E8%AF%9D%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[收获 「白话深度学习与TensorFlow」的基础篇主要内容为“机器学习是什么”、“深度学习是什么”以及“TensorFlow”框架特性与安装，通过阅读基础篇的内容大致了解了以下几个部分： 机器学习与深度学习的概念 机器学习与深度学习的区别 机器学习的常用方法 安装TensorFlow框架 第一章 机器学习是什么 机器学习是人类定义一定的计算机算法，让计算机根据输入的样本和一些人类的干预来总结并归纳其特征和特点，并用这些特征和特点与一定的学习目标形成映射关系，进而自动化地做出相应反应的过程。 机器学习的目的 人类学习的目的是掌握知识、掌握能力、掌握技巧然后最终能够进行比较复杂的或者高要求的工作。相似的机器学习的最终目的在于让计算机能够独立或者半独立的进行相对复杂或者高要求的工作。 机器学习与非机器学习的区别在于过去的计算机在程序给定的情况下，其行为逻辑就已经确定了，而机器学习则需要通过样本进行统计归纳然后才会确定其行为逻辑。所以通过机器学习可以进行相片识别信息、新闻的自动分类等工作。因为计算机事先是不会知道需要提取的信息在给定的相片中所具备的特征，只有通过机器学习不断的统计归纳才能得出适合识别大多数相片中所需提取的信息的模型。 机器学习的分类 从学习的种类来说，机器学习一般分为两种：有监督学习和无监督学习有监督学习是指先对给予的样本进行总结得出分类规则，之后根据这个规则进行分类操作，对于有监督学习而言基本分为三个过程： 训练 训练的过程主要是拿一定具有标签的样本进行统计和归纳总结出一个模型 验证 验证的过程主要是拿一些未分类的样本对这个模型进行验证，判断其是否具有泛化性(generalization)。 测试 测试则是用一定量的样本判断模型的识别能力 无监督学习则是在获得训练的向量数据后在没有标签的情况下尝试找出其内部蕴含关系的一种挖掘工作。 有监督学习和无监督学习的区别在于前者的输入数据具有标签，而后者的输入数据没有标签 机器学习的常用方法 聚类 聚类是指将物理对象或抽象对象的集合分组为由彼此类似的对象组成多个类的分析过程 特征形态的相同或近似的划在一个概念下，特征形态不同的划在不同概念下 聚类常用的算法有 K-Means、DBSCAN 等几种，其基本思路都是利用每个向量之间的距离，从远近判断是否从属于同一类别。 回归 回归是一个「由果索因」的过程，是一种归纳的思想，当我们看到大量的事实所呈现的样态去推断原因或客观蕴含的关系是如何的。 回归的训练过程一般如下： 根据观察和归纳样本（训练集）的结果推断向量和最终的函数值呈现如下映射关系 \[ y=f(x)=wx+b \] 这里的 \(w\) 和 \(x\) 分别是 \(1*n\) 和 \(n*1\) 的矩阵，也就是说接下来的问题是求解 w 和 b 代入样本值（验证集）得到误差和 \(Loss\) \[ Loss=\sum_{i=1}^n|wx_i+b-y_i| \] 这里的 \(wx_i+b\) 是根据第一步推断关系计算出的值，\(y_i\) 是实际观测到的值，将所有测试的误差相加之后即可得到总的误差，\(Loss\) 越小则代表映射关系越精确 这里以线性回归为例，至于非线性回归过程是一致的，只是映射关系和 \(Loss\) 函数有些不同。 分类 分类这个概念一直都很熟悉，具体到机器学习当中则是利用我们编写的分类器对样本进行分类，而判断这种分类器是否合理的原则在于召回率和精确率这两个指标 召回率是检索出的相关样本和样本库中所有的相关样本的比率，衡量的是分类器的查全率 精确率是检索出的相关样本数与检索出样本总数的比率，衡量的是分类器的查准率 分类的训练过程和回归的训练过程基本一致： 输入样本和分类标签 建立映射假说的某个\(y=f(x)\) 求解出全局的损失函数\(Loss\)和待定系数\(w\)的映射关系，\(Loss=g(w)\) 通过迭代优化逐步降低\(Loss\)，最终找到一个\(w\)能使召回率和精确率满足当前场景需要 第二章 深度学习是什么 深度学习是指基于深度神经网络「deep neural networks」的学习，也就是深度人工神经网络所进行的学习过程。 深度神经网络的组成 深度神经网络由多个神经元组成，而神经元是人类受到生物神经细胞结构启发而研究出的一种算法体系，一个完整的神经元由线性模型和激励函数两部分首尾相接组成。基本模型如下：其中\(wx+b\)是线性模型，\(\int\)表示激励函数 常见的激励函数有如下几种： Sigmoid 函数 \[ f(x)={1 \over 1+e^{-(wx+b)}} \] Tanh 函数 \[ tanh(x)={e^x-e^{-x}\over e^x+e^{-x}} \] ReLu 函数 \[ y=max(x,0) \] Linear 函数 \[ f(x)=x \] 对于神经网络而言主要分为三层：输入层 (input layer)、隐藏层 (hidden layer)、输出层 (output layer) 输入层直接接收输入的向量，不对数据进行任何处理 隐藏层可以有一层或者多层 输出层是最后一层，用于输出整个网络处理的值，这个值可能是一个分类向量值，也可能是一个类似线性回归产生的连续的值 深度学习和机器学习的区别 深度学习是机器学习的子集，当深度学习和传统的机器学习的区别在于，传统的机器学习通常是需要人提前进行特征提取，把提取过的特征向量化后再丢给模型去训练，这里人要做相当的前置工作。而深度学习通常可以采用 End-to-End 的学习方式，输入的内容只需要做很少的一些归一化 (normalization)、白化 (whitening) 等处理就可以丢给模型去训练，通常不需要人做特征提取的工作。 第三章 安装 TensorFlow 框架 本次安装环境是 macos、Python3 安装 Anaconda 在 Anaconda 官网 下载 Python3.6 版本 pkg 文件进行安装 建立 TensorFlow 运行环境 12conda create -n tensorflow python=3.6source activate tensorflow 安装 TensorFlow 1pip3 install tensorflow 测试 TensorFlow 12345678910&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant('Hello,TensorFlow!')&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; print(sess.run(hello))b'Hello,TensorFlow!'&gt;&gt;&gt; a = tf.constant(10)&gt;&gt;&gt; b = tf.constant(32)&gt;&gt;&gt; print(sess.run(a + b))42]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>白话深度学习与TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android启动过程简析（三）之 SystemServer 进程]]></title>
    <url>%2F2018%2F01%2F22%2FAndroid%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E7%AE%80%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 在Android启动过程简析（二）中已经大致分析了 zygote 进程的启动过程当中所做的主要工作，本篇将继续对 SystemServer 的启动过程进行分析。 SystemServer 启动过程 上文说到 SystemServer 进程在 ZygoteInit.java 中被创建，然后便会在 SystemServer 进程调用 handleSystemServerProcess 方法处理 SystemServer 进程的剩余工作 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 1234567891011121314151617181920212223242526272829303132333435private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; //SystemServer 进程不需要进行Socket通信，所以关闭 closeServerSocket(); ... //设置进程名为system_server if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125; final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH"); ... //这里 parsedArgs.invokeWith 为 null if (parsedArgs.invokeWith != null) &#123; .... &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; //创建 SystemServer 的类加载器对象 cl = createSystemServerClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion); Thread.currentThread().setContextClassLoader(cl); &#125; //将剩余参数传递给 SystemServer RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; /* should never reach here */&#125; 在 handleSystemServerProcess 方法中首先会关闭掉 Socket 连接，然后会根据传递过来的参数设置进程名称，在设置完进程名称之后，由于 parseArgs 的成员 invokeWith 为 null，所以会利用 systemServerClasspath 创建对应的类加载器对象，最后会通过 RuntimeInit 的 zygoteInit 方法将剩余参数传递给 SystemServer。 RuntimeInit 分析 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 1234567891011public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, "RuntimeInit: Starting application from zygote"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "RuntimeInit"); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125; zygoteInit 中依次调用了 nativeZygoteInit 和 applicationInit，其中前者启动了一个线程池，而后者则会调用了 SystemServer 类的 main 方法。 启动线程池 nativeZygoteInit 实际上对应着 com_android_internal_os_RuntimeInit_nativeZygoteInit frameworks/base/core/jni/AndroidRuntime.cpp 1234567891011121314static const JNINativeMethod gMethods[] = &#123; &#123; "nativeFinishInit", "()V", (void*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;, &#123; "nativeZygoteInit", "()V", (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;, &#123; "nativeSetExitWithoutCleanup", "(Z)V", (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,&#125;;int register_com_android_internal_os_RuntimeInit(JNIEnv* env)&#123; return jniRegisterNativeMethods(env, "com/android/internal/os/RuntimeInit", gMethods, NELEM(gMethods));&#125; 继续查看 com_android_internal_os_RuntimeInit_nativeZygoteInit 可以知道最终调用了 gCurRuntime 的 onZygoteInit 方法，而 gCurRuntime 实际上是一个 AndroidRuntime 的指针 1234static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123; gCurRuntime-&gt;onZygoteInit();&#125; onZygoteInit 的具体实现在 AndroidRuntime 的子类 AppRuntime 中，可以看到最终通过 startThreadPool 启动了线程池 frameworks/base/cmds/app_process/app_main.cpp 123456virtual void onZygoteInit()&#123; sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV("App process: starting thread pool.\n"); proc-&gt;startThreadPool();&#125; 调用 SystemServer 的 main 方法 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 1234567891011121314151617181920private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; ... //根据 argv 构建 RuntimeInit.Arguments，这里的 argv[] 实际上是 “com.android.server.SystemServer” final Arguments args; try &#123; args = new Arguments(argv); &#125; catch (IllegalArgumentException ex) &#123; Slog.e(TAG, ex.getMessage()); // let the process exit return; &#125; // The end of of the RuntimeInit event (see #zygoteInit). Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // Remaining arguments are passed to the start class's static main invokeStaticMain(args.startClass, args.startArgs, classLoader);&#125; 在 applicationInit 方法中会对 argv 进行解析创建 RuntimeInit.Arguments 参数，然后会调用 invokeStaticMain 12345678910111213141516171819202122232425262728293031323334353637383940private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; //获取SystemServer的Class对象 cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( "Missing class when invoking static main " + className, ex); &#125; Method m; try &#123; //获取 main 方法 m = cl.getMethod("main", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( "Missing static main on " + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( "Problem getting static main on " + className, ex); &#125; //获取方法修饰符，判断是否是入口 main 方法 int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( "Main method is not public and static on " + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 在 invokeStaticMain 方法中会通过方法签名获取到 SystemServer 的 main 方法，之后会抛出 MethodAndArgsCaller 异常，然后在 ZygoteInit 的 main 方法中进行捕获，捕获之后会执行 MethodAndArgsCaller 的 run 方法，而在 run 方法中会完成对 SystemServer 的 main 方法的调用 1234567891011121314151617181920212223242526//MethodAndArgsCaller 的 run 方法public void run() &#123; try &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125;&#125;//ZygoteInit 捕获异常//frameworks/base/core/java/com/android/internal/os/ZygoteInit.javapublic static void main(String argv[]) &#123; ... &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; ....&#125; SystemServer 分析 123public static void main(String[] args) &#123; new SystemServer().run();&#125; SystemServer 的 main 方法中创建了一个 SystemServer 对象，并调用了其 run 方法，所以继续看 run 方法部分 123456789101112131415161718192021222324252627282930313233343536373839private void run() &#123; try &#123; ... //创建 SystemServer 主线程的 Looper Looper.prepareMainLooper(); // 初始化 mSystemContext createSystemContext(); // 创建 SystemServiceManager 对象 mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; // 启动服务 try &#123; Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartServices"); startBootstrapServices(); startCoreServices(); startOtherServices(); &#125; catch (Throwable ex) &#123; Slog.e("System", "******************************************"); Slog.e("System", "************ Failure starting system services", ex); throw ex; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, "Enabled StrictMode for system server main thread."); &#125; // Loop forever. Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 在 run 方法中，首先调用 Looper.prepareMainLooper() 创建了当前主线程的 Looper，之后会调用 createSystemContext 初始化 mSystemContext 实例，这里的 mSystemContext 是一个 ContextImpl 实例，主要用于初始化一些 Service，最后则是启动系统各项服务。 启动系统服务 从启动服务的过程中看，系统将服务分为三类： 引导服务----------startBootstrapServices() Installer、ActivityManagerService、PackageManagerService 等 核心服务----------startCoreServices() BatteryService、UsageStatsService、WebViewUpdateService 其它服务----------startOtherServices() AlarmManagerService、VibratorService 等 而对于服务的启动方式而言也分为三种（启动方式与服务类别并不对应）： mSystemServiceManager.startService() 12345678910111213141516171819202122232425262728public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; try &#123; final String name = serviceClass.getName(); ... //创建Service实例 final T service; try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; catch (InstantiationException ex) &#123; .... &#125; // 加入 List&lt;SystemService&gt; 当中 mServices.add(service); //回调 Service 的 onStart 方法 try &#123; service.onStart(); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException("Failed to start service " + name + ": onStart threw an exception", ex); &#125; return service; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125;&#125; 从这里可以看出 startService 启动的服务都是 SystemService 的子类，启动的过程是先对服务类进行加载，加载之后进行实例化，实例化之后则会调用实例的 onStart 方法。 xxxService.main() 这种方式主要在启动以下三个服务中用到 PackageManagerService OtaDexoptService WindowManagerService 这里以 PackageManagerService 为例进行分析 12345678910111213public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; // Self-check for initial settings. PackageManagerServiceCompilerMapping.checkProperties(); PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); m.enableSystemUserPackages(); //注册启动服务 ServiceManager.addService("package", m); return m;&#125; 可以看到在 main 方法中直接创建了 PackageManagerService 的实例，然后通过 ServiceManager 进行注册启动。 ServiceManager.addService() 1ServiceManager.addService("scheduling_policy", new SchedulingPolicyService()); ServiceManager 涉及到 Binder 暂不做分析 上文中提到了服务的注册，对于服务的注册而言实际上分为两种：一是 ServiceManager.addService，二是 LocalServices.addService 12345678910111213141516171819202122232425262728293031/** * This class is used in a similar way as ServiceManager, except the services registered here * are not Binder objects and are only available in the same process. * * Once all services are converted to the SystemService interface, this class can be absorbed * into SystemServiceManager. * * &#123;@hide&#125; */public final class LocalServices &#123; private LocalServices() &#123;&#125; private static final ArrayMap&lt;Class&lt;?&gt;, Object&gt; sLocalServiceObjects = new ArrayMap&lt;Class&lt;?&gt;, Object&gt;(); ... /** * Adds a service instance of the specified interface to the global registry of local services. */ public static &lt;T&gt; void addService(Class&lt;T&gt; type, T service) &#123; synchronized (sLocalServiceObjects) &#123; if (sLocalServiceObjects.containsKey(type)) &#123; throw new IllegalStateException("Overriding service registration"); &#125; sLocalServiceObjects.put(type, service); &#125; &#125; ...&#125; 查看 LocalServices 的类描述可以知道 LocalServices 与 ServiceManager 用处类似，不同点在于ServiceManager 用于不同进程间获取 Service，而 LocalServices 只能够用于同一进程中获取 Service。 总结 至此大概就能知道在 SystemServer 启动过程中主要做了三件事 开启线程池 创建 SystemServerManager 对象负责继承自 SystemService 的服务的创建、启动以及生命周期的管理 启动系统的服务 Thanks Android系统启动-SystemServer上篇 Android系统启动-SystemServer下篇 Android系统服务的注册方式 Android系统启动流程（三）解析SyetemServer进程启动过程]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之注解]]></title>
    <url>%2F2018%2F01%2F15%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[问题 关于注解首先请思考一下以下问题： 注解是什么？ 注解的主要使用场景？ 注解可以分为哪些类型？ 注解的处理过程？ 接下来我们将对这几个问题进行探讨 注解简介 Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate. 上述是官方给出的关于注解的定义，大致意思是注解是元数据（MetaData）的一种形式，它用于提供一些和程序元素有关的元数据，这些数据本身不属于程序，并且也不会直接影响程序的操作。 为了更直观的理解注解的概念，我们还需要进一步了解元数据这个概念，关于元数据 Wiki 上的描述如下： Metadata is &quot;data [information] that provides information about other data&quot;，For example, a digital image may include metadata that describes how large the picture is, the color depth, the image resolution, when the image was created, the shutter speed, and other data. 元数据是描述数据的数据，对于一张相片而言元数据包括相片的大小、色彩深度、图片的分辨率、图片建立时间以及快门速度等相关数据。 结合两者可以得到：注解是一种用于描述程序元素信息的修饰符，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量。 这里再结合具体的场景进行理解： 12@BindView(R.id.toolbar)public Toolbar mToolbar; 对于成员变量 mToolbar 而言，其基本的信息包含 width、heigth、id，通过注解我们能够很明确的描述它的 id 信息。 注解的主要使用场景 要明白注解的使用场景，首先需要了解的是注解的主要作用： Information for the compiler— Annotations can be used by the compiler to detect errors or suppress warnings. Compile-time and deployment-time processing— Software tools can process annotation information to generate code, XML files, and so forth. Runtime processing— Some annotations are available to be examined at runtime. 接下来举几个常见的例子说明： 为编译器提供信息用于检测错误或者抑制警告 12345@SuppressWarnings("unchecked")public void addItems(@NonNull String item) &#123; List list = new ArrayList(); list.add(item);&#125; 编译时和部署时通过对注解进行处理生成代码、XML 文件等 比较常见的如butterknife，butterknife 能够通过注解自动生成 findViewById 的代码，有助于减轻样板代码的负担。 12@BindView(R.id.toolbar)public Toolbar mToolbar; 运行时通过注解进行检查处理 在运行时我们可以通过反射机制对注解提供的信息进行处理，然后实现需要的功能。 在明确了注解的主要作用之后，注解的使用场景就已经呼之欲出了，当我们需要为程序中的元素提供信息，并且这些信息需要得到处理的时候，就可以考虑使用注解。 注解的分类 基本注解 Java 提供了 5 个基本的 Annotation 注解名 作用 @Override 限定重写父类方法 @Deprecated 表示某个程序元素已经过时 @SuppressWarnings 抑制编译器的警告 @SafeVarargs 抑制堆污染警告 @FunctionalInterface 指定某个接口必须是函数式接口 接下来聊聊它们的使用 Override 123456789101112public class FatherClass &#123; public void overridedMethod() &#123; &#125; &#125;public class BaseAnnotationUse extends FatherClass&#123; @Override public void overridedMethod() &#123; super.overridedMethod(); &#125;&#125; Override的主要作用是： 帮助检查是否正确的复写了父类中的已有方法（如果不小心拼写错误或者方法签名对不上被覆盖的方法，编辑器都会发出警告信息） 表示当前方法定义将覆盖超类的方法。 如果没有正确的复写父类中的方法则会提示 Method does not override method from its superclass。 Deprecated 在 FatherClass 增加如下方法： 1234@Deprecatedpublic void deprecatedMethod() &#123;&#125; 然后在 BaseAnnotationUse 中增加： 123public void useDeprecatedMethod() &#123; deprecatedMethod();&#125; 这个时候将会看到 deprecatedMethod() 显示红色，并且编辑器提示deprecatedMethod() 已经过时了 SuppressWarning 对 BaseAnnotationUse 中的 useDeprecatedMethod 方法进行如下修改 1234@SuppressWarnings("deprecation")public void useDeprecatedMethod() &#123; deprecatedMethod();&#125; 通过增加 SuppressWarning 抑制了 Deprecated 的警告，deprecatedMethod() 的红色将会消失 SafeVarargs 1234@SafeVarargspublic static void faultyMethod(List&lt;String&gt;... listStrArray) &#123; List[] listArray = listStrArray;&#125; 当把一个不带泛型的对象赋给一个带泛型的变量的时候，往往将会导致”堆污染“，所以在 Java 7 中增加了 SafeVarargs 用于抑制堆污染的警告，SafeVarargs 只能用在参数长度可变的方法或构造方法上，且方法必须声明为static或final，否则会出现编译错误。 FunctionalInterface 1234@FunctionalInterfacepublic interface BaseInterface &#123; int add(int x, int y);&#125; FunctionalInterface 是 Java 8 专门为 Lambda 表达式新增的，通过 FunctionalInterface 可以限制接口中只能存在一个抽象方法，如果在 BaseInterface 接口中新增抽象方法，编译时将会提示 BaseInterface 不是函数式接口。 元注解 JDK 在 java.lang.annotation 中内置了 6 种元注解，除了 Native 之外都用于修饰其它的 Annotation 定义 注解名 作用 @Retention 指定被修饰的注解的保留时间 @Target 指定被修饰的注解可以修饰的程序元素 @Documented 指定被修饰的注解可以被 javadoc 提取成文档 @Inherited 指定被修饰的注解具有继承性，如果某个类使用了被 @Inherited 修饰的注解，那么其子类将自动被该注解修饰 @Repeatable 用于定义重复注解 @Native 表示定义常量值的字段可以从本地代码引用。 接下来主要介绍前五种，@Native 实在是不常用 Retention 12345678910@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; /** * Returns the retention policy. * @return the retention policy */ RetentionPolicy value();&#125; Retention的定义如上，其拥有一个 RetentionPolicy 类型的成员变量，RetentionPolicy 是枚举类，主要有三个枚举值： RetentionPolicy.SOURCE 注解只能保留在源文件当中，编译器不会编译这种注解 RetentionPolicy.CLASS 注解能够保留在 class 文件当中，但是当程序运行的时候，JVM 不能够获取到注解信息 RetentionPolicy.RUNTIME 注解能够保留在 class 文件当中，程序运行的时候，JVM 也能够获取到注解信息，程序能够通过反射去获取到 Annotation 信息 Target 123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125; ElementType 也是一个枚举类，其枚举值和意义是： ElementType.TYPE 表明注解可以修饰类、接口或者枚举定义 ElementType.FIELD 表明注解可以修饰成员变量 ElementType.METHOD 表明注解可以修饰方法定义 ElementType.PARAMETER 表明注解可以修饰参数 ElementType.CONSTRUCTOR 表明注解可以修饰构造函数 ElementType.LOCAL_VARIABLE 表明注解可以修饰局部变量 ElementType.ANNOTATION_TYPE 表明注解可以修饰注解 ElementType.PACKAGE 表明注解可以修饰包定义 ElementType.TYPE_PARAMETER 表明注解只能定义程序元素的修饰 ElementType.TYPE_USE 表明注解不仅可以在定义程序元素的时候使用，还可以在创建对象、类型转换、使用 implements 实现接口、使用 throws 声明抛出异常的时候使用 Documented 对于使用被 @Documented 修饰的注解和不带 @Documented 修饰的注解，其区别如下： annotation_1 annotation_2 Inherited Inherited 的继承作用可以通过以下例子来体现，首先创建一个 Interitable 注解 12345@Retention(RetentionPolicy.CLASS)@Target(ElementType.TYPE)@Inheritedpublic @interface Inheritable &#123;&#125; 然后创建一个由 Inheritable 修饰的 Base 类 123@Inheritablepublic class Base &#123;&#125; 最后创建一个继承自 Base 类的 InheritableTest 类 1234567public class InheritableTest extends Base &#123; public static void main(String[] args) &#123; //判断是否被 Inheritable 注解 System.out.println(InheritableTest.class.isAnnotationPresent(Inheritable.class)); &#125;&#125; 运行之后可以发现结果为 true Repeatable Repeatable 是 Java8 新增的注解，用于定义重复注解，在 Java8 之前的重复注解只能写成以下形式 123456789@Infos(&#123;@Info(name = &quot;zhangsan&quot;), @Info(name = &quot;lisi&quot;)&#125;)private Person mPerson;public class Person &#123; private String mName; private int mAge; private int mHeight; private int mWeight;&#125; 其中 Info 和 Infos 分别是 12345678910111213@Target(ElementType.FIELD)@Retention(RetentionPolicy.CLASS)public @interface Info &#123; String name();&#125;@Retention(RetentionPolicy.CLASS)@Target(ElementType.FIELD)public @interface Infos &#123; Info[] value();&#125; 由于 Infos 中保留了 Info 的信息，所以 Infos 的保留时间不能比 Info 少，否则编译器将会报错。如果 Info 的保留时间是 RUNTIME，而 Infos 的保留时间是 SOURCE，那么 JVM 最终会丢弃 Infos 以及 Infos 中的 Info 信息，这与 Info 期望的保留时间相矛盾。 自定义注解 JDK 内置的注解并不能完全满足我们的需求，大多数情况下我们还需要学会自定义注解，定义一个注解需要用到 @Interface 关键字 12345678910111213141516171819@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface BindView &#123; /** * @return View 的 Id */ int value();&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface BindOnClickListener &#123; /** * @return 实现 OnClickListener 接口的类 */ Class&lt;? extends OnClickListener&gt; value();&#125; 上面定义了两个注解用于绑定 View 的 id 以及 点击事件，并且指定了注解可以修饰的元素以及保留时间，可以看到定义一个注解与定义一个接口非常类似，而实际上每个注解都是继承自 Annotation 接口的接口，反编译 BindView 生成的 class 文件可以看到 1234Compiled from "BindView.java"public interface com.rookieyang.runtimeannotation.customizeannotation.BindView extends java.lang.annotation.Annotation &#123; public abstract int value();&#125; 这里自定义的注解都是含有成员变量的，而注解除了按照基本注解、元注解、自定义注解进行分类之外，我还可以根据是否包含成员变量将它分为两类： 标记注解：这种注解没有成员变量，它仅仅通过是否存在来提供信息，如@Override、@Deprecated 元数据注解：这种注解包含成员变量，它通过成员变量提供更多的信息，如@Retention、@Target 注解的处理 在使用自定义的注解的时候，如果不提供注解的处理工具，注解是不会自动生效的，注解的处理方法主要有两种，一种是运行时处理注解，一种是编译时处理注解。 运行时处理注解 运行时处理注解主要利用 Java 的反射机制，接下来将结合具体实例说明如何通过反射处理注解。 首先利用自定义注解部分定义的两个注解 BindView 和 BindOnClickListener 对 View 进行注解 123@BindView(R.id.hello_world)@BindOnClickListener(CustomizeOnClickListener.class)private Button mHelloWorld; 然后在 Activity 中定义一个 CustomizeOnClickListener 内部类 12345678class CustomizeOnClickListener implements OnClickListener &#123; @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this, R.string.hello_world, Toast.LENGTH_SHORT).show(); &#125;&#125; 接着定义一个处理注解的类 12345678910111213141516171819202122232425262728293031323334353637383940public class AnnotationProcess &#123; public static void process(Object obj) &#123; Field[] fields = obj.getClass().getDeclaredFields(); Activity activity; if (!(obj instanceof Activity)) &#123; throw new RuntimeException("传入的参数不是Activity"); &#125; activity = (Activity) obj; for (Field field : fields) &#123; try &#123; View view = null; field.setAccessible(true ); BindView bindView = field.getAnnotation(BindView.class); BindOnClickListener bindOnClickListener = field .getAnnotation(BindOnClickListener.class); //判断是否是 View boolean isView = View.class.isAssignableFrom(field.getType()); if (bindView != null &amp;&amp; isView) &#123; view = activity.findViewById(bindView.value()); //设置 obj 对象当中的 field 值为 view field.set(obj, view); &#125; if (bindOnClickListener != null &amp;&amp; isView &amp;&amp; view != null) &#123; Class&lt;? extends OnClickListener&gt; listener = bindOnClickListener.value(); //实例化 CustomizeOnClickListener 内部类 OnClickListener onClickListener = listener.getConstructor( obj.getClass()).newInstance(activity); view.setOnClickListener(onClickListener); &#125; &#125; catch (Exception e) &#123; Log.i(obj.getClass().getSimpleName(), e.getMessage()); &#125; &#125; &#125;&#125; 最后在 Activity 中调用即可： 1AnnotationProcess.process(this); 编译时处理注解 相对与运行时利用反射处理注解会有性能损失而言，编译时处理注解利用 APT（Annotation Processing Tool）对注解进行处理然后生成代码、XML 文件，利用 APT 去处理注解性能更好。参照 JDK 文档中对于 Processor 接口的描述，我们可以大致知道注解处理器的工作流程 If an existing Processor object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class. Next, the tool calls the init method with an appropriate ProcessingEnvironment. Afterwards, the tool calls getSupportedAnnotationTypes, getSupportedOptions, and getSupportedSourceVersion. These methods are only called once per run, not on each round. As appropriate, the tool calls the process method on the Processor object; a new Processor object is not created for each round. 编译工具将会通过注解处理器的无参构造函数实例化一个注解处理器对象，然后调用注解处理器的 init 方法并传入 ProcessingEnvironment，之后则调用 getSupportedAnnotationTypes，getSupportedOptions和getSupportedSourceVersion，最后将会调用 process 方法。 接下来将说明如何利用 APT 生成一个类文件用于显示 HelloWorld： 首先需要明确希望生成的类文件： 123456789101112package com.rookieyang.myannotationtwo;import android.content.Context;import android.widget.Toast;public class MainActivity_HelloWorld &#123; public static void show(Context context) &#123; Toast.makeText(context, "HelloWorld", Toast.LENGTH_SHORT).show(); &#125;&#125; 想要生成这个类文件需要获取到两点信息：包名和类名，通过包名可以使类文件生成在使用注解的包下，便于解析注解的时候加载类文件，通过类名加上 &quot;_HelloWorld&quot; 确保生成的类文件唯一存在，同时也达到了使用注解的类和生成的类绑定的效果。 接下来需要创建两个 Module，其中一个定义了所有的注解，另外一个定义了 APT，之所以需要定义两个 Module 的原因，其一为了让工程结构更清晰，另一方面定义 APT 需要用到 javax 包。整体的工程结构如下图所示： 之后需要为 annotations-compiler 和 app 模块引入相关依赖 1234567annotations-compiler 模块compile 'com.google.auto.service:auto-service:1.0-rc3'compile project(path: ':annotations')app 模块compile project(path: ':annotations')annotationProcessor project(':annotations-compiler') 其中 auto-service 的作用是帮助我们生成下列文件，主要作用是声明注解处理器。 annotationProcessor 则是为模块指定注解处理器 配置之后首先在 annotations 模块定义一个 HelloWorld 注解 1234@Target(ElementType.FIELD)@Retention(RetentionPolicy.CLASS)public @interface HelloWorld &#123;&#125; 然后在 annotations-compiler 模块编写对应注解处理器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//标识一个注解处理器@AutoService(Processor.class)public class AnnotationsCompiler extends AbstractProcessor &#123; private Elements mElements; private Filer mFiler; private Messager mMessager; /* * 用于初始化 mElements、mFiler、mMessager */ @Override public synchronized void init(ProcessingEnvironment processingEnvi) &#123; super.init(processingEnvi); mElements = processingEnvi.getElementUtils(); mFiler = processingEnvi.getFiler(); mMessager = processingEnvi.getMessager(); &#125; /** * * @param elements 实际上传入的都是 &#123;@link #getSupportedAnnotationTypes()&#125; * 中支持的并且被扫描到（使用过）注解元素，例如这里获取到的类元素就是 HelloWorld 注解 * @param roundEnvi 一个注解处理工具框架，通过它可以查询到使用了注解的元素 * @return 返回处理结果 */ @Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment roundEnvi) &#123; String packageName; String className; //获取使用了 HelloWorld 注解的元素 for (Element element : roundEnvi.getElementsAnnotatedWith(HelloWorld.class)) &#123; //通过 Elements 去获取包名 packageName = mElements.getPackageOf(element).toString(); //HelloWorld 注解只能被用在成员变量，所以通过获取外层元素就可以获取到使用注解的元素所在的类 className = element.getEnclosingElement().getSimpleName() + "_HelloWorld"; try &#123; //通过 Filer 指定的路径下创建一个 java 源文件，然后写入对应的代码 JavaFileObject javaFileObject = mFiler.createSourceFile( packageName + "." + className); Writer writer = javaFileObject.openWriter(); writer.write("package " + packageName + ";\n\n"); writer.write("import android.content.Context;\n"); writer.write("import android.widget.Toast;\n\n"); writer.write("public class " + className + " &#123;\n\n"); writer.write("\tpublic static void show(Context context) &#123;\n"); writer.write("\t\tToast.makeText(context," + " \"HelloWorld\", Toast.LENGTH_SHORT).show();\n"); writer.write("\t&#125;\n"); writer.write("\n&#125;"); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; /** * * @return 返回注解处理器支持的 Java 版本 */ @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; /** * * @return 返回注解处理器支持的注解集合 */ @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; annotationTypes = new LinkedHashSet&lt;&gt;(); for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123; annotationTypes.add(annotation.getCanonicalName()); &#125; return annotationTypes; &#125; /** * * @return 返回支持的注解类型集合 */ private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123; Set&lt;Class&lt;? extends Annotation&gt;&gt; annotationSet = new LinkedHashSet&lt;&gt;(); annotationSet.add(HelloWorld.class); return annotationSet; &#125;&#125; 接下来说下几个有助于理解注解处理器的点： Elements 是一个获取程序元素信息的接口，例如获取元素的包名、判断是否是重写方法，例如 Filer 则是一个支持通过注解处理器创建文件的接口，可以用于创建 Class文件、源文件、资源文件 Messager 则是为注解处理器提供的输出错误信息的接口。 Element 与 Elements 区别在于 Element 是获取单个程序元素信息的接口，而 Elements 可以获取整个程序的元素信息。除了 Element 之外，上述程序还可以看到 TypeElement，而 TypeElement 是一个继承了 Element 接口的接口，用于表示类元素。实际上 JDK 还提供了很多继承自 Element 的接口用于表示程序中的各项元素，具体的 Element 继承结构如下图所示： 在编写完注解处理器之后，最后在 App 模块中编写对应的调用代码即可 123456789101112private void show() &#123; try &#123; //获得生成的类的 Class 对象 Class&lt;?&gt; helloClass = Class.forName(getPackageName() + "." + getClass().getSimpleName() + "_HelloWorld"); //利用反射取得 show 方法，然后执行对应的方法即可 Method showMethod = helloClass.getMethod("show", Context.class); showMethod.invoke(this, this); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 实际上编译时注解的整个处理过程是利用注解处理器对程序中使用了注解的元素进行遍历，从元素中提取所需的信息，然后生成类文件，最后在程序中加载生成的类并调用其中的方法。 最后给出本次测试的工程链接 Annotation 测试 总结 最后让我们回答开始的几个问题 注解是一种用于描述程序元素信息的修饰符，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量。 当我们需要为程序中的元素提供信息，并且这些信息得到处理的时候，就可以考虑使用注解。 按照系统内置的注解，可以分为基本注解、元注解、自定义注解。按照是否有成员变量可以分为标记注解、元数据注解。按照处理方式，可以分为运行时注解、编译时注解。 注解的处理过程主要为运行时通过反射处理和编译时通过注解处理器进行处理。 Thanks 《Java 编程思想》 《疯狂 Java 讲义》 Annotation Tutorials 自己动手实现Java注解（Java Annotation in Action） 注解处理器（Annotation Processor）原理简析 Android注解使用之通过annotationProcessor注解生成代码实现自己的ButterKnife框架 Android注解使用之注解编译android-apt如何切换到annotationProcessor]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年年终总结]]></title>
    <url>%2F2018%2F01%2F07%2F2018%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[2017 快结束了，正好趁这个时间对过去一年做个总结，过去一年上半年的表现应该能有 70 分，毕竟在做毕设期间劲头足，而且也学习到了不少东西，而参加工作的下半年则恐怕连 30 分都不到。大致分析了一下问题所在 问题 缺乏一个明确的学习路线和执行力 没有根据自身的实际需求做一个详细的规划，并根据规划一步一步的扎实推进学习计划，反而是各个方面都想要进行学习，异常的急功近利，从而导致能够深入的部分比较少 实践问题 对于实践而言一个问题是太过于将重心放在 UI 效果上，并且在一些原理性的知识点没有掌握的很好的情况下导致在 UI 方面浪费了很多时间也消磨了大部分的精力，所以导致自己实践过少 博客的问题 博客经常断断续续，问题在于没有规划性，不论是要写的文章还是文章本身的结构都没有一个完整的思路，所以从以前的博客可以看到杂乱无章 新的规划 制定合理可行的学习计划表 目前大致思路如下 制定关于基础方面的计划，目前大致分为：Java 基础、Android 基础、数据结构和算法、网络协议、设计模式、读书笔记、常用框架。计划需要在持续更新的过程中进行细化 以周为单位尽可能解决一个大的知识点，并整理成文章发表出去（多平台希望接受别人的指正） 其余的小知识点和进阶知识点会将整理在 Gitbook 上 最后需要对笔记和文章进行良好的分类 实践问题 今年可能会完成两个 APP，一个是关于单词记忆的（之前留下的烂摊子，需要进行重构），另外一个是网络壁纸的，除此之外希望每个星期能安排半天给自己单纯的编码时间，主要是和自己做的 APP 相关或者模仿别人的 Demo 博客问题 目前主要需要进行整理，之前的博客已经修正了分类，博客的分类大致与整理出来的计划表相对应，后续写博客的时候希望精益求精，养成一个良好的行文思路 不管如何，新的一年需要 GO FIGHTING！ 2018-3-4 更新 学习计划]]></content>
      <categories>
        <category>新年计划</category>
      </categories>
      <tags>
        <tag>新年计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 启动过程简析（二）之 zygote 进程]]></title>
    <url>%2F2017%2F11%2F05%2FAndroid%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E7%AE%80%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 在 Android启动过程简析（一）中我们已经分析过了 init 进程是如何被启动的，本篇文章将会继续分析 zygote 启动过程以及作用。 zygote 启动过程 zygote 进程创建之后会首先进入到 app_main.cpp 的 main 函数当中去，所以首先对 app_main 进行分析 app_main 分析 frameworks/base/cmds/app_process/app_main.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192int main(int argc, char* const argv[])&#123; ... //创建 AppRuntime 对象 AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); ... // 解析运行时参数，当遇到无法识别的选项时停止 bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; ++i; // Skip unused "parent dir" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; //如果传入的参数有 ”--zygote“ 则将 zygote 置为 true if (strcmp(arg, "--zygote") == 0) &#123; zygote = true; niceName = ZYGOTE_NICE_NAME; //如果传入的参数有 "--start-system-server" 则将 startSystemServer 置为 true &#125; else if (strcmp(arg, "--start-system-server") == 0) &#123; startSystemServer = true; &#125; else if (strcmp(arg, "--application") == 0) &#123; application = true; &#125; else if (strncmp(arg, "--nice-name=", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, "--", 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; //非 zygote 模式处理 if (!className.isEmpty()) &#123; // We're not in zygote mode, the only argument we need to pass // to RuntimeInit is the application argument. // // The Remainder of args get passed to startup class main(). Make // copies of them before we overwrite them with the process name. args.add(application ? String8("application") : String8("tool")); runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; //zygote 模式下的处理 maybeCreateDalvikCache(); //如果 startSystemServer 为 true 则将 "start-system-server" 添加到 args if (startSystemServer) &#123; args.add(String8("start-system-server")); &#125; char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123; LOG_ALWAYS_FATAL("app_process: Unable to determine ABI list from property %s.", ABI_LIST_PROPERTY); return 11; &#125; String8 abiFlag("--abi-list="); abiFlag.append(prop); args.add(abiFlag); // In zygote mode, pass all remaining arguments to the zygote // main() method. for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); &#125; //如果 zygote 为 true 则启动 zygote if (zygote) &#123; //通过 runtime 对象启动 zygote runtime.start("com.android.internal.os.ZygoteInit", args, zygote); &#125; else if (className) &#123; runtime.start("com.android.internal.os.RuntimeInit", args, zygote); &#125; else &#123; fprintf(stderr, "Error: no class name or --zygote supplied.\n"); app_usage(); LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied."); return 10; &#125;&#125; 可以看到在 main 函数中首先创建了一个 AppRuntime 对象，然后就会根据传入的参数对一些标志位进行相应的置位，这里值得注意的一个标志位是 startSystemServer，上文说过 Android 5.0 之后系统可能会启动两个 zygote 进程，而 SystemServer 只需要启动一次，所以通过这个标志位控制只在启动主 zygote 进程的时候将 &quot;start-system-server&quot; 增加到 args，然后则会通过 AppRuntime 的 start 函数调用 Java 层的 zygote 代码。 AndroidRuntime 分析 由于 AppRuntime 继承自 AndroidRuntime，所以想要了解系统是如何调用 Java 层的 zygote 代码则需要继续了解 AndroidRuntime 的 start 函数 1class AppRuntime : public AndroidRuntime AndroidRuntime 位于 frameworks/base/core/jni 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* * Start the Android runtime. This involves starting the virtual machine * and calling the "static void main(String[] args)" method in the class * named by "className". * * Passes the main function two arguments, the class name and the specified * options string. */void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... static const String8 startSystemServer("start-system-server"); /* * 'startSystemServer == true' means runtime is obsolete and not run from * init.rc anymore, so we print out the boot start event here. */ for (size_t i = 0; i &lt; options.size(); ++i) &#123; //只有 startSystemServer == true，options 才会有 start-system-server if (options[i] == startSystemServer) &#123; /* track our progress through the boot sequence */ const int LOG_BOOT_PROGRESS_START = 3000; LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC))); &#125; &#125; ... //const char* kernelHack = getenv("LD_ASSUME_KERNEL"); //ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack); /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; //创建启动 DVM if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return; &#125; onVmCreated(env); /* * Register android functions. */ //注册 JNI 方法 if (startReg(env) &lt; 0) &#123; ALOGE("Unable to register all android natives\n"); return; &#125; /* * We want to call main() with a String array with arguments in it. * At present we have two arguments, the class name and an option string. * Create an array to hold them. */ //将 options 转化为 java 中的 String 数组 jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass("java/lang/String"); assert(stringClass != NULL); //创建对象数组，类型为 stringClass（即 String 类型），长度为 options.size() + 1 strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); //将 options 逐个增加到对象数组当中 for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className); //寻找类名为 slashClassName 的类 jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE("JavaVM unable to locate class '%s'\n", slashClassName); /* keep going */ &#125; else &#123; //查找 main 方法，([Ljava/lang/String;)V 是 main 方法的签名 jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, "main", "([Ljava/lang/String;)V"); if (startMeth == NULL) &#123; ALOGE("JavaVM unable to find main() in '%s'\n", className); /* keep going */ &#125; else &#123; //调用 startClass 类当中的 main 方法，传入参数 strArray env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env);#endif &#125; &#125; ...&#125; 通过 start 函数的注释我们可以大致了解到 start 函数的主要作用是启动虚拟机和名为 classname 的 main 方法。 而上文可以知道，传入的 classname 是 &quot;com.android.internal.os.ZygoteInit&quot; 。那么整个的执行流程就是： 首先会判断传递进来的参数是否存在 &quot;start-system-server&quot; ，如果存在则会输出启动日志，然后会通过 startVm 函数创建启动 DVM，在启动 DVM 之后会通过 startReg 函数注册 JNI 方法，在注册完毕之后会将传入的 options 参数转换为 Java 的对象数组，而之所以需要转换成对象数组是因为在于 options 需要作为 main 方法的参数传入，之后再通过传入的 className 去获得 jclass 对象，并根据 main 方法的 JNI 签名得到 jmethodID，最终通过CallStaticVoidMethod 方法完成 main 方法的调用。 ZygoteInit 分析 frameworks/base/core/java/com/android/internal/os 1234567891011121314151617181920212223242526272829303132public static void main(String argv[]) &#123; ... String socketName = "zygote"; ... try &#123; ... //注册 socket registerZygoteSocket(socketName); ... //预加载类和资源 preload(); ... if (startSystemServer) &#123; //创建 SystemServer 进程 startSystemServer(abiList, socketName); &#125; ... //等待客户端请求 runSelectLoop(abiList); ... closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, "Zygote died with exception", ex); closeServerSocket(); throw ex; &#125;&#125; 整个 main 方法的执行流程是：首先通过 registerZygoteSocket 方法对 socket 进行了注册，注册的 socket 用于和 ActivityManagerService 进行通信，然后调用 preload 方法对类和资源进行加载，之后则会调用 startSystemServer 创建 SystemServer 进程，最后通过 runSelectLoop 等待来自 ActivityManagerService 的请求。 这里最为关键的是 socket 以及创建 SystemServer 进程，所以我们需要进一步了解这两个部分。 注册 Socket 过程 首先是注册 Socket 部分， registerZygoteSocket 主要是利用文件描述符创建了一个 LocalServerSocket 对象 1234567891011121314151617181920212223private static void registerZygoteSocket(String socketName) &#123; if (sServerSocket == null) &#123; int fileDesc; //socket 名为 ANDROID_SOCKET_zygote final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(fullSocketName + " unset or invalid", ex); &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); //创建 LocalServerSockt sServerSocket = new LocalServerSocket(fd); &#125; catch (IOException ex) &#123; throw new RuntimeException( "Error binding to local socket '" + fileDesc + "'", ex); &#125; &#125;&#125; 启动 SystemServer startSystemServer 主要工作是对设置的参数进行解析，然后通过 forkSystemServer 创建 SystemServer 进程，最后在 SystemServer 进程中调用 handleSystemServerProcess 方法处理剩余工作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123;... /* Hardcoded command line to start the system server */ //设置 uid 为 1000,设置 gid 为 1000，启动 com.android.server.SystemServer String args[] = &#123; "--setuid=1000", "--setgid=1000", /// M: ANR mechanism for system_server add shell(2000) group to access /// /sys/kernel/debug/tracing/tracing_on "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,2000," + "3001,3002,3003,3006,3007,3009,3010", "--capabilities=" + capabilities + "," + capabilities, "--nice-name=system_server", "--runtime-args", "com.android.server.SystemServer", &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; //对 args 进行解析 parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); /* Request to fork the system server process */ //创建 SystemServer 进程 pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; //处理 SystemServer 进程剩余工作 handleSystemServerProcess(parsedArgs); &#125; return true;&#125; 监听客户端的请求 runSelectLoop 的主要工作是通过 ZygoteConnection 的 acceptCommandPeer 方法监听客户端的请求，然后调用 runOnce 方法对来自客户端的请求进行处理。 123456789101112131415161718192021222324252627282930313233343536373839private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(sServerSocket.getFileDescriptor()); peers.add(null); //循环处理连接请求 while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; Os.poll(pollFds, -1);//无限等待能够进行 I/O 操作 &#125; catch (ErrnoException ex) &#123; throw new RuntimeException("poll failed", ex); &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; //说明没有来自客户端的连接请求或数据处理请求 if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123;//处理来自客户端的连接请求 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; boolean done = peers.get(i).runOnce();//处理客户端数据处理请求，创建对应的进程 if (done) &#123;//处理完毕则进行移除 peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 处理客户端请求 对于 runOnce 而言主要做的工作是从连接中读取参数，然后根据参数创建相应的进程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; ... try &#123; args = readArgumentList();//读取参数 descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; Log.w(TAG, "IOException on command socket " + ex.getMessage()); closeSocket(); return true; &#125; if (args == null) &#123; // EOF reached. closeSocket(); return true; &#125; ... try &#123; parsedArgs = new Arguments(args);//构造 Arguments 对象 ... //创建进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125; catch (ErrnoException ex) &#123; logAndPrintError(newStderr, "Exception creating pipe", ex); &#125; catch (IllegalArgumentException ex) &#123; logAndPrintError(newStderr, "Invalid zygote arguments", ex); &#125; catch (ZygoteSecurityException ex) &#123; logAndPrintError(newStderr, "Zygote security policy prevents request: ", ex); &#125; try &#123; if (pid == 0) &#123; // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; //进入子进程的处理流程 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; 总结 到这里我们大致能够知晓 Zygote 进程的启动过程和主要作用了： 系统在启动 Zygote 的过程中首先启动了虚拟机，然后通过 JNI 调用了 ZygoteInit 中的 main 方法，由此系统从 C++ 的 FrameWork 层到了 Java 的 FrameWork 层，之后在则注册了用于和 ActvityManagerService 通信的 Socket，完成注册之后则会调用 startSystemServer 启动 SystemServer 进程，最后 Zygote 进程将会通过 runSelectLoop 对来自客户端的连接进行监听。 总的来说 Zygote 的主要作用启动 SystemServer 进程以及根据客户端的连接创建相应的进程。 Thanks Android系统启动流程（二）解析Zygote进程启动过程 Android系统启动-zygote篇]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 启动过程简析（一）之 init 进程]]></title>
    <url>%2F2017%2F10%2F28%2FAndroid%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E7%AE%80%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题 在进入到 Android 启动过程之前先让我们思考以下几个问题 1. Android 系统的启动过程是怎样的？ 2. init 、zygote 进程是什么？在系统启动的过程中各自发挥了什么作用？ 3. AMS、PMS 等这些服务是如何被启动的？ 4. Launcher 是如何被启动的？ 此篇文章将针对 init 部分给出分析 启动流程简述 在了解 init 部分之前，首先简单介绍下系统的启动流程以便抓住主线，当我们通过电源键开启系统的时候，系统首先会加载 bootloader 程序到 RAM 中，然后通过 bootloader 将内核程序加载到 RAM 中，之后内核程序会创建init 进程，在 init 进程中会创建 zygote 进程，而 zygote 进程则会创建 DVM 并且启动 SystemServer 进程，通过SystemServer 系统会启动一系列的服务，包括常见的 AMS、PMS 等，最后再通过 AMS 进入到我们熟知的 Launcher 程序。 所以整个流程的关键点在于 init 进程如何创建 zygote、zygote 进程如何创建 SystemServer、SystemServer 进程如何启动 AMS、AMS 如何启动 Launcher。 init 启动流程分析 由于 bootloader 和内核不是关心的重点，所以这里只是简单介绍它们的作用。 加载运行 BootLoader 在电源上电之后，CPU 中的操作控制器将发出控制信号，将程序计数器（PC）的内容送至地址寄存器（AR），之后启动对主存的读操作，最终将 BootLoader 加载到 RAM 当中。然后 BootLoader 开始执行，主要负责硬件的初始化，将内核程序加载到内存。 init 进程的启动 内核启动之后将会初始化软硬件环境，加载驱动程序，挂载根文件系统，然后创建 init 进程，init 作为系统中的第一个用户进程，其进程号为 1，在创建 init 进程之时，系统会执行位于 system/core/init 下的 init.cpp 程序 123456789101112131415161718192021222324252627282930313233343536int main(int argc, char** argv) &#123; ... //创建用户空间目录并挂载 if (is_first_stage) &#123; mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"); mkdir("/dev/pts", 0755); mkdir("/dev/socket", 0755); mount("devpts", "/dev/pts", "devpts", 0, NULL); #define MAKE_STR(x) __STRING(x) mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC)); mount("sysfs", "/sys", "sysfs", 0, NULL); &#125; ... signal_handler_init(); property_load_boot_defaults(); export_oem_lock_status(); //启动属性服务 start_property_service(); ... const BuiltinFunctionMap function_map; Action::set_function_map(&amp;function_map); Parser&amp; parser = Parser::GetInstance(); parser.AddSectionParser("service",std::make_unique&lt;ServiceParser&gt;()); parser.AddSectionParser("on", std::make_unique&lt;ActionParser&gt;()); parser.AddSectionParser("import", std::make_unique&lt;ImportParser&gt;()); //解析 init.rc 文件 parser.ParseConfig("/init.rc"); ... return 0;&#125; 可以看到 init 进程主要做了三件事情：创建用户空间文件夹并挂载、启动属性服务、解析位于 system文件夹下的 init.rc 文件。 这里我们主要关注解析 init.rc 文件的过程，因为 zygote 进程就是在这个过程中创建的。 Android Init Language 由于 init.rc 是一个用 Android 初始化语言（AIL）编写的文件，为了更好的理解 rc 文件的解析过程需要了解一部分 AIL 语法。 AIL 主要有五种类型语句 Actions、Commands、Services、Options、Imports，在 AIL 中每个部分(语句块)表示为一个 Section，比如： 1234on boot ifup lo hostname localhost domainname localdomain 五种语句中只有 Actions、Services、Import 可以用于确定一个 Section。其中 Actions 由一系列 command 组成，Actions 拥有一个 trigger 用于确定何时执行这些命令。 12345678on &lt;trigger&gt; &lt;command&gt; &lt;command&gt; &lt;command&gt; on early-init //触发器 early-init write /proc/1/oom_score_adj -1000 //command write /proc/sys/kernel/sysrq 0 Services 由一些 option 组成，其在初始化的时候启动，并可以在退出后重启（可选）。 12345678service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* //服务名、执行路径、参数 &lt;option&gt; &lt;option&gt; service ueventd /sbin/ueventd class core critical seclabel u:r:ueventd:s0 Services 定义了自身的服务名、执行路径以及执行时传入的参数，option 用于指定何时和怎样启动 service，关于何时启动这里进行一下说明，Actions 中有一条命令是 class_start 用于启动所有未运行的相同类别的 service，而 option 可以通过 class 对 service 的类别名进行指定。所以 service 的启动一般是通过 action 触发之后执行 class_start 命令进行启动的。 AIL 的介绍就到这了，如果想要详细了解请阅读 system/core/init 下的 readme.txt 文件 init.rc 解析 system/core/rootdir/init.rc 现在接着分析 init.rc 文件，在文件的首部可以看到 12345import /init.environ.rcimport /init.usb.rcimport /init.$&#123;ro.hardware&#125;.rcimport /init.usb.configfs.rcimport /init.$&#123;ro.zygote&#125;.rc 在这里可以看到需要启动的 zygote，但是与其它引入的 rc 文件相比 zygote 部分并没有使用确定的值，而是使用 ${ro.zygote} 变量去替代，这是因为从 Android 在 5.0 以后开始支持 64 位程序，所以需要根据系统中 ro.zygote 属性的值动态引入。ro.zygote 的值可以通过 adb shell getprop 进行查询，我的手机查询结果是： 这说明手机会启动两个 zygote 进程，对应的执行程序分别是 app_process64 (主模式)、app_process32，通过 adb shell ps | grep zygote 可以看到确实存在两个 zygote 进程 接着查看与 init.rc 同一目录下的 init.zygote64_32.rc 文件 system/core/rootdir/init.zygote64_32.rc 12345678910111213141516service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasks /sys/fs/cgroup/stune/foreground/tasksservice zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary class main socket zygote_secondary stream 660 root system onrestart restart zygote writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks 前文说过 service 的启动和类别名相关，这里两个 zygote service 的类别名都是 main，所以要想知道 zygote 怎么被启动的我们可以在 init.rc 中搜索 class_start main，可以发现 12345on nonencrypted # A/B update verifier that marks a successful boot. exec - root -- /system/bin/update_verifier nonencrypted class_start main class_start late_start 从这里我们可以了解到当 nonencrypted 这个触发器被触发的时候 zygote 就会被启动，所以启动 zygote 的问题就转变为这个触发器什么时候执行？class_start 对应的处理函数是什么？要想知道答案，必须回到 init.cpp 的解析过程当中 12345Parser&amp; parser = Parser::GetInstance();parser.AddSectionParser("service",std::make_unique&lt;ServiceParser&gt;());parser.AddSectionParser("on", std::make_unique&lt;ActionParser&gt;());parser.AddSectionParser("import", std::make_unique&lt;ImportParser&gt;());parser.ParseConfig("/init.rc"); init.rc 交由一个 Parser 对象进行解析，而 Parser 的实现在 system/core/init/init_parser.cpp 文件中，让我们进入到 init_parser.cpp 中查看 AddSectionParser 的实现 1234567void Parser::AddSectionParser(const std::string&amp; name, std::unique_ptr&lt;SectionParser&gt; parser) &#123; section_parsers_[name] = std::move(parser);&#125;//init_parser.h 中 section_parsers_ 的定义std::map&lt;std::string, std::unique_ptr&lt;SectionParser&gt;&gt; section_parsers_; 可以看到每一个 parser 最终被保存在 section_parsers_ 中，section_parsers_ 是什么？查看 init_parser.h 中的定义可以知道，section_parsers_ 是一个 map 集合，所以 section_parsers_ 的作用是将 parser 与对应的 Section 进行绑定。 在添加完所有的 parser 之后就会调用 Parser 的 ParseConfig 方法 123456bool Parser::ParseConfig(const std::string&amp; path) &#123; if (is_dir(path.c_str())) &#123; return ParseConfigDir(path); &#125; return ParseConfigFile(path);&#125; ParseConfig 中会对 path 进行判断，如果是目录则调用 ParseConfigDir 进行递归然后再通过 ParseConfigFile 进行解析。 1234567891011121314151617181920bool Parser::ParseConfigDir(const std::string&amp; path) &#123; INFO("Parsing directory %s...\n", path.c_str()); std::unique_ptr&lt;DIR, int(*)(DIR*)&gt; config_dir(opendir(path.c_str()), closedir); if (!config_dir) &#123; ERROR("Could not import directory '%s'\n", path.c_str()); return false; &#125; dirent* current_file; while ((current_file = readdir(config_dir.get()))) &#123; std::string current_path = android::base::StringPrintf("%s/%s", path.c_str(), current_file-&gt;d_name); // Ignore directories and only process regular files. if (current_file-&gt;d_type == DT_REG) &#123; if (!ParseConfigFile(current_path)) &#123; //调用 ParseConfigFile 进行解析 ERROR("could not import file '%s'\n", current_path.c_str()); &#125; &#125; &#125; return true;&#125; 最终在 ParseConfigFile 中通过 ParseData 进行解析 1234567891011121314bool Parser::ParseConfigFile(const std::string&amp; path) &#123; INFO("Parsing file %s...\n", path.c_str()); Timer t; std::string data; //从 rc 文件中读取内容保存在 data 中 if (!read_file(path.c_str(), &amp;data)) &#123; return false; &#125; data.push_back('\n'); // TODO: fix parse_config. ParseData(path, data); //调用 ParseData 进行解析 ... return true;&#125; ParseData 解析过程如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void Parser::ParseData(const std::string&amp; filename, const std::string&amp; data) &#123; //TODO: Use a parser with const input and remove this copy std::vector&lt;char&gt; data_copy(data.begin(), data.end()); //将 rc 中的内容保存在 vector 中便于逐个字符进行解析 data_copy.push_back('\0'); parse_state state; state.filename = filename.c_str(); state.line = 0; state.ptr = &amp;data_copy[0]; state.nexttoken = 0; SectionParser* section_parser = nullptr; std::vector&lt;std::string&gt; args; //存放的是每行的内容 for (;;) &#123; switch (next_token(&amp;state)) &#123; case T_EOF: if (section_parser) &#123; section_parser-&gt;EndSection(); &#125; return; case T_NEWLINE: state.line++; //如果 args 为空则不进行解析（rc 文件中间存在空行，所以需要判断） if (args.empty()) &#123; break; &#125; //判断是不是一个 section 的起始位置（通过能不能获得解析器，可以判断 args[0] 是不是 service、on、import 其中一个） if (section_parsers_.count(args[0])) &#123; if (section_parser) &#123; //如果上次存在解析则结束解析 section_parser-&gt;EndSection(); &#125; //取出对应的解析器 section_parser = section_parsers_[args[0]].get(); std::string ret_err; //进行 Section 解析 if (!section_parser-&gt;ParseSection(args, &amp;ret_err)) &#123; parse_error(&amp;state, "%s\n", ret_err.c_str()); section_parser = nullptr; &#125; &#125; else if (section_parser) &#123; //不是的话说明 args 中是一个 section 的子块，则进行 Line 解析 std::string ret_err; if (!section_parser-&gt;ParseLineSection(args, state.filename, state.line, &amp;ret_err)) &#123; parse_error(&amp;state, "%s\n", ret_err.c_str()); &#125; &#125; //解析完成后清空 args.clear(); break; case T_TEXT: args.emplace_back(state.text); break; &#125; &#125;&#125; ParseData 中通过调用 system/core/init/parser.cpp 中的 next_token 函数对 rc 内容进行分析，如果是 T_TEXT 则会保存在 args 中，如果是 T_NEWLINE 则会交由对应的解析器进行解析。init.rc 的大致解析过程如此，但是到这里我们依旧没能找到所需要的答案，所以需要继续查看 ActionParser 和 ServiceParser 的解析过程。 ActionParser 解析过程 ActionParser 位于 system/core/init/action.cpp 中，从前面的解析过程来看，最后的解析总是调用了对应 parser 的 ParseSection、ParseLineSection 以及 EndSection，所以我们主要看下这两个部分 ParseSection 的主要工作是创建 Action 对象，为对象添加触发器，并将 action_ 移动至当前 Action 对象 12345678910111213141516171819bool ActionParser::ParseSection(const std::vector&lt;std::string&gt;&amp; args, std::string* err) &#123; std::vector&lt;std::string&gt; triggers(args.begin() + 1, args.end()); ... auto action = std::make_unique&lt;Action&gt;(false); //为 action 增加触发器 if (!action-&gt;InitTriggers(triggers, err)) &#123; return false; &#125; //将 aciton_ 指针移动到当前的 action action_ = std::move(action); return true;&#125;//action_ 在 action.h 中的定义private: std::unique_ptr&lt;Action&gt; action_; ParseLineSection 的主要工作为查找对应 command 的处理函数，将创建的 Command 对象添加到到commands_，由于 commands_ 是 Action 的一个域，所以实际上 ParseLineSection 在填充当前 Action 对象的域。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546bool ActionParser::ParseLineSection(const std::vector&lt;std::string&gt;&amp; args, const std::string&amp; filename, int line, std::string* err) const &#123; //将解析的 command 增加到当前 action 的 commands_ 中 return action_ ? action_-&gt;AddCommand(args, filename, line, err) : false;&#125;bool Action::AddCommand(const std::vector&lt;std::string&gt;&amp; args, const std::string&amp; filename, int line, std::string* err) &#123; ... //查找对应的 command 的处理函数 auto function = function_map_-&gt;FindFunction(args[0], args.size() - 1, err); if (!function) &#123; return false; &#125; AddCommand(function, args, filename, line); return true;&#125;void Action::AddCommand(BuiltinFunction f, const std::vector&lt;std::string&gt;&amp; args, const std::string&amp; filename, int line) &#123; //commands_ 增加 command 和对应的处理函数 commands_.emplace_back(f, args, filename, line);&#125;//commands_ 在 action.h 中的定义std::vector&lt;Command&gt; commands_;//Command 在 action.h 中的定义class Command &#123;public: Command(BuiltinFunction f, const std::vector&lt;std::string&gt;&amp; args, const std::string&amp; filename, int line); int InvokeFunc() const; std::string BuildCommandString() const; std::string BuildSourceString() const;private: BuiltinFunction func_; std::vector&lt;std::string&gt; args_; std::string filename_; int line_;&#125;; EndSection 的主要工作是将解析完成的 action （域填充完毕的 Action 对象）添加到 ActionManager 的 acitons_ 中 123456789101112131415161718192021222324252627282930313233343536373839404142void ActionParser::EndSection() &#123; if (action_ &amp;&amp; action_-&gt;NumCommands() &gt; 0) &#123; ActionManager::GetInstance().AddAction(std::move(action_)); &#125;&#125;void ActionManager::AddAction(std::unique_ptr&lt;Action&gt; action) &#123; ... if (old_action_it != actions_.end()) &#123; (*old_action_it)-&gt;CombineAction(*action); &#125; else &#123; //将解析之后的 action 对象增加到 actions_ 链表中，用于遍历执行。 actions_.emplace_back(std::move(action)); &#125;&#125;//ActionManager 在 action.h 中的定义class ActionManager &#123;public: static ActionManager&amp; GetInstance(); void AddAction(std::unique_ptr&lt;Action&gt; action); void QueueEventTrigger(const std::string&amp; trigger); void QueuePropertyTrigger(const std::string&amp; name, const std::string&amp; value); void QueueAllPropertyTriggers(); void QueueBuiltinAction(BuiltinFunction func, const std::string&amp; name); void ExecuteOneCommand(); bool HasMoreCommands() const; void DumpState() const;private: ActionManager(); ActionManager(ActionManager const&amp;) = delete; void operator=(ActionManager const&amp;) = delete; std::vector&lt;std::unique_ptr&lt;Action&gt;&gt; actions_; //actions_ 的定义 std::queue&lt;std::unique_ptr&lt;Trigger&gt;&gt; trigger_queue_; std::queue&lt;const Action*&gt; current_executing_actions_; std::size_t current_command_;&#125;; 通过以上分析我们能够知道 class_start 的处理函数和 function_map_ 相关，查看 function_map_ 在 action.h 中的定义可以看到 12345static const KeywordMap&lt;BuiltinFunction&gt;* function_map_;static void set_function_map(const KeywordMap&lt;BuiltinFunction&gt;* function_map) &#123; function_map_ = function_map;&#125; 所以要想知道处理函数是什么只需要知道 set_function_map 在哪里调用？让我们再次回到 init.cpp 中，可以看到 12const BuiltinFunctionMap function_map;Action::set_function_map(&amp;function_map); 接下来需要找到 BuiltinFunctionMap，BuiltinFunctionMap 的实现我们可以在 builtins.cpp 中找到，其具体的实现 system/core/init/builtins.cpp 12345678910BuiltinFunctionMap::Map&amp; BuiltinFunctionMap::map() const &#123; constexpr std::size_t kMax = std::numeric_limits&lt;std::size_t&gt;::max(); static const Map builtin_functions = &#123; ... &#123;"class_start", &#123;1, 1, do_class_start&#125;&#125;, &#123;"class_stop", &#123;1, 1, do_class_stop&#125;&#125;, ... &#125;; return builtin_functions;&#125; 到这里就可以确定 class_start 对应的处理函数是 do_class_start，do_class_start 也可在 builtins.cpp 中找到。 简单总结下解析 Action 的过程，实际上是创建一个 Action 对象，然后为 Action 对象添加 Trigger 以及对应的 Command，其中在添加 Command 的过程中还为 Command 指定了处理函数，最后在将 Action 对象增加到 ActionManager vector 类型的 actions_ 链表当中去。 ServiceParser 解析过程 与前文一致，接着看那三个函数 ParseSection 的主要工作是创建 Service 对象，将 service_ 移动至当前 Service 对象 123456789101112131415bool ServiceParser::ParseSection(const std::vector&lt;std::string&gt;&amp; args, std::string* err) &#123; ... //获取服务名 const std::string&amp; name = args[1]; ... //保存服务名外的参数（如执行路径等） std::vector&lt;std::string&gt; str_args(args.begin() + 2, args.end()); //将 service_ 指针指向当前 Service 对象 service_ = std::make_unique&lt;Service&gt;(name, "default", str_args); return true;&#125;//service_ 在 service.h 中的定义std::unique_ptr&lt;Service&gt; service_; ParseLineSection 的主要工作是为 Service 中每个 option 指定处理函数 123456789101112131415161718bool ServiceParser::ParseLineSection(const std::vector&lt;std::string&gt;&amp; args, const std::string&amp; filename, int line, std::string* err) const &#123; //为 Service 中的每一个 Option 指定处理函数 return service_ ? service_-&gt;HandleLine(args, err) : false;&#125;bool Service::HandleLine(const std::vector&lt;std::string&gt;&amp; args, std::string* err) &#123; ... static const OptionHandlerMap handler_map; //寻找对应 option 的处理函数 auto handler = handler_map.FindFunction(args[0], args.size() - 1, err); ... return (this-&gt;*handler)(args, err);&#125; EndSection 的主要工作是将解析完成的 service （域填充完毕的 Service 对象）添加到 ServiceManager 的 services_ 中 123456789101112131415161718192021222324252627282930313233343536373839404142void ServiceParser::EndSection() &#123; if (service_) &#123; ServiceManager::GetInstance().AddService(std::move(service_)); &#125;&#125;void ServiceManager::AddService(std::unique_ptr&lt;Service&gt; service) &#123; Service* old_service = FindServiceByName(service-&gt;name()); if (old_service) &#123; ERROR("ignored duplicate definition of service '%s'", service-&gt;name().c_str()); return; &#125; //将解析之后 service 对象增加到 services_ 链表中 services_.emplace_back(std::move(service));&#125;//ServiceManager 在 service.h 中的定义class ServiceManager &#123;public: static ServiceManager&amp; GetInstance(); void AddService(std::unique_ptr&lt;Service&gt; service); Service* MakeExecOneshotService(const std::vector&lt;std::string&gt;&amp; args); Service* FindServiceByName(const std::string&amp; name) const; Service* FindServiceByPid(pid_t pid) const; Service* FindServiceByKeychord(int keychord_id) const; void ForEachService(std::function&lt;void(Service*)&gt; callback) const; void ForEachServiceInClass(const std::string&amp; classname, void (*func)(Service* svc)) const; void ForEachServiceWithFlags(unsigned matchflags, void (*func)(Service* svc)) const; void ReapAnyOutstandingChildren(); void RemoveService(const Service&amp; svc); void DumpState() const;private: ServiceManager(); bool ReapOneProcess(); static int exec_count_; // Every service needs a unique name. std::vector&lt;std::unique_ptr&lt;Service&gt;&gt; services_; //services_ 的定义&#125;; 对应的可以看下 option 的处理函数，虽然 OptionHandlerMap 与启动 zygote 无关，但是还是看下 1234567891011121314151617181920Service::OptionHandlerMap::Map&amp; Service::OptionHandlerMap::map() const &#123; constexpr std::size_t kMax = std::numeric_limits&lt;std::size_t&gt;::max(); static const Map option_handlers = &#123; &#123;"class", &#123;1, 1, &amp;Service::HandleClass&#125;&#125;, &#123;"console", &#123;0, 0, &amp;Service::HandleConsole&#125;&#125;, &#123;"critical", &#123;0, 0, &amp;Service::HandleCritical&#125;&#125;, &#123;"disabled", &#123;0, 0, &amp;Service::HandleDisabled&#125;&#125;, &#123;"group", &#123;1, NR_SVC_SUPP_GIDS + 1, &amp;Service::HandleGroup&#125;&#125;, &#123;"ioprio", &#123;2, 2, &amp;Service::HandleIoprio&#125;&#125;, &#123;"keycodes", &#123;1, kMax, &amp;Service::HandleKeycodes&#125;&#125;, &#123;"oneshot", &#123;0, 0, &amp;Service::HandleOneshot&#125;&#125;, &#123;"onrestart", &#123;1, kMax, &amp;Service::HandleOnrestart&#125;&#125;, &#123;"seclabel", &#123;1, 1, &amp;Service::HandleSeclabel&#125;&#125;, &#123;"setenv", &#123;2, 2, &amp;Service::HandleSetenv&#125;&#125;, &#123;"socket", &#123;3, 6, &amp;Service::HandleSocket&#125;&#125;, &#123;"user", &#123;1, 1, &amp;Service::HandleUser&#125;&#125;, &#123;"writepid", &#123;1, kMax, &amp;Service::HandleWritepid&#125;&#125;, &#125;; return option_handlers;&#125; 与解析 Action 类似，在整个过程中先创建 Service 对象，解析出 Service 的名字和对应的参数添加到对象当中，并且给每个 Option 指定了相应的处理函数 到这里 rc 文件的解析就结束了，通过 rc 文件的解析使得每个 action 都有了对应的执行函数，所以接下来的问题是这些 action 是如何被触发的（也即是 command 命令是如何被执行的）？ Actions 的触发 让我们继续回到 init.cpp 中 12345678910ActionManager&amp; am = ActionManager::GetInstance();....while (true) &#123; if (!waiting_for_exec) &#123; am.ExecuteOneCommand(); restart_processes(); &#125;...&#125; 可以看到 action 的 command 的执行是通过 ActionManager 的 ExecuteOneCommand 函数，而ActionManager 的 ExecuteOneCommand 最终调用了 Action 的 ExecuteOneCommand system/core/init/action.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142void ActionManager::ExecuteOneCommand() &#123; //循环等待，直到队列中不为空 while (current_executing_actions_.empty() &amp;&amp; !trigger_queue_.empty()) &#123; //遍历 actions_ for (const auto&amp; action : actions_) &#123; if (trigger_queue_.front()-&gt;CheckTriggers(*action)) &#123; //将 action 加入到 current_executing_actions_ 中 current_executing_actions_.emplace(action.get()); &#125; &#125; trigger_queue_.pop(); &#125; ... //每次只执行一个 action auto action = current_executing_actions_.front(); if (current_command_ == 0) &#123; std::string trigger_name = action-&gt;BuildTriggersString(); INFO("processing action (%s)\n", trigger_name.c_str()); &#125; //执行 action 的 command action-&gt;ExecuteOneCommand(current_command_); ++current_command_; ...&#125;void Action::ExecuteOneCommand(std::size_t command) const &#123; //执行 action 对象中保存的 command ExecuteCommand(commands_[command]);&#125;void Action::ExecuteCommand(const Command&amp; command) const &#123; Timer t; //调用 command 对应的处理函数 int result = command.InvokeFunc(); ...&#125; 通过上述分析可以知道，init 进程最终进入到无限循环中，然后按照 ActionManager 中 actions_ 保存的 action 顺序依次对每个 Action 进行处理，而在这个过程中 system/core/init/builtins.cpp 下用于启动 zygote 的 do_class_start 函数将会被执行 12345static int do_class_start(const std::vector&lt;std::string&gt;&amp; args) &#123; ServiceManager::GetInstance(). ForEachServiceInClass(args[1], [] (Service* s) &#123; s-&gt;StartIfNotDisabled(); &#125;); return 0;&#125; do_class_start 函数中调用 Service 的 StartIfNotDisabled，StartIfNotDisabled 在 service.cpp 的实现如下 12345678bool Service::StartIfNotDisabled() &#123; if (!(flags_ &amp; SVC_DISABLED)) &#123; return Start(); &#125; else &#123; flags_ |= SVC_DISABLED_START; &#125; return true;&#125; StartIfNotDisabled 最终调用了 Service 的 Start 函数，Start 函数创建了 zygote 的进程，并且执行了 init.zygote64_32.rc 中定义的执行路径下的文件 1234567891011121314151617bool Service::Start() &#123; .... //创建子进程 pid_t pid = fork(); if (pid == 0) &#123; ... //执行对应 service 对应的执行文件，args_[0].c_str() 就是执行路径 if (execve(args_[0].c_str(), (char**) &amp;strs[0], (char**) ENV) &lt; 0) &#123; ERROR("cannot execve('%s'): %s\n", args_[0].c_str(), strerror(errno)); &#125; _exit(127); &#125; .... return true;&#125; 在完成这一切之后将会进入 frameworks/base/cmds/app_process/app_main.cpp 中 12345678910111213141516int main(int argc, char* const argv[])&#123; .... if (zygote) &#123; //启动 zygote runtime.start("com.android.internal.os.ZygoteInit", args, zygote); &#125; else if (className) &#123; runtime.start("com.android.internal.os.RuntimeInit", args, zygote); &#125; else &#123; fprintf(stderr, "Error: no class name or --zygote supplied.\n"); app_usage(); LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied."); return 10; &#125;&#125; 可以看到 zygote 最终在 app_main 的 main 函数中被启动。 总结 到这里我们就能够回答对 init 部分相关的问题了 1. init 的作用 init 是系统中的第一个用户进程，它的主要作用是创建用户空间文件夹并挂载、启动属性服务、解析 init.rc 文件并启动 zygote 进程。 2. init 启动 zygote 的过程 init 进程通过解析 init.rc 文件将 action 保存在 ActionManager 的 actions_ 链表中，然后通过遍历 actions_ 链表，执行 action 命令对应的处理函数，从而转至 builtins.cpp 的 do_class_start 函数，之后通过 Service 的 StartIfNotDisabled 调用 Service 的 Start 函数，最终通过 Start 函数创建 zygote 进程，执行对应的 app_main.cpp 文件启动 zygote。 Thanks Android7.0 init进程源码分析 Android Init Language(android初始化语言) Android系统启动流程（一）解析init进程启动过程]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 基础之 Selector 的用法]]></title>
    <url>%2F2017%2F09%2F24%2FSelector%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 Selector（选择器）常常被用作控件的背景，是一种状态列表，一般分为 Drawable-selector 和 Color-selector，接下来分别说说这两者的使用方法。 Drawable-selector 首先需要在 res/drawable 文件夹下新建一个 Drawable Resource File 文件，填入文件名即可，创建之后的文件内容如下： 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;/selector&gt; 在 selector 标签下新建一个 item 标签，item 标签表示一种状态，如果不指明状态，那么控件在任何状态下都会加载 item 内的 样式，常用的状态设置如下所示： android:state_pressed 设置为 true 时代表按压控件的时候使用 item 样式 android:state_selected 设置为 true 时代表控件被选中的时候使用 item 样式 android:state_checked 设置为 true 时代表控件处于 checked 状态的时候使用 item 样式 接下来在 item 内部创建 shape 标签用于指定绘制的图形类别，总共有四种图形可以选择分别是：rectangle、oval、line、ring。在确定需要绘制的 shape 类型之后，就可以在 shape 标签内部对 shape 的各项属性进行配置，总共有六种标签属性。 size 用来设置 shape 的大小 solid 用来设置填充 shape 的颜色 corners 用来设置 shape 的角度 stroke 用来给 shape 描边，可以描成虚线或实线 padding 设置内边距 gradient 设置 shape 的渐变颜色 设置好相应的属性之后就可以通过设置控件的 android:drawble 属性进行使用了，这里给出一个例子 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;shape android:shape="rectangle"&gt; &lt;corners android:radius="5dp" /&gt; &lt;stroke android:width="1dp" android:color="#00faff" android:dashGap="10dp" android:dashWidth="10dp" /&gt; &lt;size android:width="150dp" android:height="150dp" /&gt; &lt;solid android:color="#bcb7b7" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:state_pressed="false"&gt; &lt;shape android:shape="oval"&gt; &lt;corners android:radius="360dp" /&gt; &lt;stroke android:width="1dp" android:color="#00fcb5" android:dashGap="10dp" android:dashWidth="10dp" /&gt; &lt;size android:width="300dp" android:height="300dp" /&gt; &lt;solid android:color="#ffff" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; 上述代码绘制了两种状态，一种是默认状态下的圆，白色填充、虚线描边、半径是 300dp。另一种是被按下的状态，灰色填充、虚线描边、长和宽与圆一致。具体效果如下图所示： Color-selector Color-selector 定义在 res文件夹下，使用过程基本与 Drawable-selector 一致，不同在于 Color-selector 只是用于定义控件的颜色，所以只需要配置 item 标签的 color 属性即可，具体的例子如下： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:color="#000000" android:state_pressed="false" /&gt; &lt;item android:color="#ffff" android:state_pressed="true" /&gt;&lt;/selector&gt; 通过指定 item 的状态和颜色，即可做到按压和松开时控件的颜色变化。]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Drawble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的六大原则及单例模式]]></title>
    <url>%2F2017%2F09%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E5%8F%8A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[面向对象的六大原则 单一职责原则 单一职责原则 (SRP) 是指就一个类而言，应该仅有一个引起它变化的原因 简单而言就是一个类应该只有一项职责，而不是具有多项职责，比如一个类既负责图片缓存的处理同时还负责显示图片，实际上应该拆分成两个类，一个类负责图片的缓存，另外一个类负责图片显示。如果一个类兼具太多的职责不仅导致了耦合性，而且在一个职责发生变化的时候还可能削弱其它的职责功能。 开闭原则 开闭原则 (OCP) 是指软件中的对象对于修改应该是封闭的，对于扩展应该是开放的。 如果一个类为了实现新的功能不断的对类中的原有代码进行修改和增加，不仅可能引入 Bug，还有可能会导致类越来越庞大，比如一个图片的缓存类需要实现内存缓存、SD 卡缓存、两种方式混合的缓存方法，在图片显示类中需要自由选择何种方式进行缓存显示。比较好的一种方式是：由于三种缓存方式实际上基本功能一致，所以可以定义一个接口，然后在图片显示类中义一个接口用于指向三个类实例化的对象，那么当需要采用哪种方式去进行缓存的时候，只需要使用 set 方法进行依赖注入将接口指向相应方式的对象即可，并且如果要实现其它不同的缓存方式只需要对接口进行实现即可。这样实现的代码耦合性弱扩展性强。 里氏替换原则 里氏替换原则是指所有引用基类的地方必须能透明地使用其子类的对象 一个基类的子类拥有基类的属性和方法（私有的除外），所以在大多数情况下基类能干的子类都能做，这样可以保证很好的扩展性，因为可以在基类的基础上进行扩展实现不同功能的子类。因此里氏替换原则有利于提高扩展性，同时为开闭原则提供了保障。 依赖倒置原则 依赖倒置原则是用于解耦的一种方式，主要有以下几个关键点： 高层模块不应该依赖底层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 第一点是指当高层的模块使用底层的模块时候，不应该直接使用底层模块类的具体对象，而应该使用其接口或者是抽象类，这样可以保证其扩展性，也就是说高层模块与底层模块之间应该通过接口发生联系，而不应该存在直接关联。 接口隔离原则 接口隔离原则是指类间的关系应该建立在最小的接口上 最小的接口实际上就是抽象的一种表达，一个接口下面可能可能会实现很多种接口，或者是很多层级接口，要对这些接口相同的功能部分进行操作的时候只需要对最顶层的接口操作即可，譬如当关闭输入输出流的时候，Java 中有很多种流，字节流、字符流、缓冲流。这个时候为了减少依赖、耦合性以及增加扩展性，我们只需要利用 Cloaseable 接口指向各种流的对象进行关闭操作即可。 迪米特原则 迪米特原则是指一个对象应该对其它对象有最少的了解 一个类应该尽可能少的利用到其它类完成相同的任务，这样可以降低耦合性 单例模式 定义 所谓单例也就是说在一个类在系统中只存在一个实例，并且可以自行实例化向系统提供这个实例 使用场景 适用于某个类有且仅有一个对象的场景，避免创建多个对象消耗过多的资源。 构造函数不对外开放，一般为 private 通过一个静态方法或者枚举返回单例类对象 确保单例类对象有且只有一个，尤其是在多线程环境下 确保单例类对象在反序列化时不会重新构建对象 也即是说单例模式的对象必须由该类的静态方法进行实例化和提供，并且不能出现多个对象。 优缺点 优点 单例模式在内存中只存在一个实例，减少了内存的开支。 减少了系统的性能开销，当一个对象的产生需要较多的资源的时候，这个时候可以通过产生一个单例对象，然后永驻内存来解决。 单例模式可以避免对资源的多重占用。 单例模式可以在系统设置全局的访问点，优化和共享资源访问 缺点 单例模式一般没有接口，扩展很困难。 单例对象如果持有 Context，那么很容易引发内存泄漏，此时传递给单例对象的 Context 最好是 Application Context 常用的实现方式 饿汉模式 1234567891011public class CEO &#123; private static CEO sCeo = new CEO(); private CEO() &#123; super(); &#125; public static CEO newInstance() &#123; return sCeo; &#125;&#125; 该种方式实现的单例模式当类被加载的时候就会初始化一个 CEO 对象，然后外部可以通过 newInstance 静态方法进行获取。 由于单例模式需要类能够自行进行实例化，所以返回值一定是类变量以及通过静态方法进行返回。 懒汉模式 1234567891011121314public class SingleInstance &#123; private static SingleInstance sSingleInstance; private SingleInstance() &#123; super(); &#125; public static synchronized SingleInstance newInstance() &#123; if (sSingleInstance != null) &#123; sSingleInstance = new SingleInstance(); &#125; return sSingleInstance; &#125;&#125; 采用懒汉模式实现的单例模式可以在使用的时候才将对象实例化，但是由于每次调用 newInstance 方法的时候都会进行同步（比不需要同步的慢 100 倍），所以造成了不必要的同步开销，不建议使用。 Double Check Lock 123456789101112131415161718public class SingleInstance &#123; private static SingleInstance sSingleInstance = null; private SingleInstance() &#123; super(); &#125; public static SingleInstance newInstance() &#123; if (sSingleInstance != null) &#123; synchronized (SingleInstance.class) &#123; if (sSingleInstance != null) &#123; sSingleInstance = new SingleInstance(); &#125; &#125; &#125; return sSingleInstance; &#125;&#125; 第一次的判断避免了在对象非空情况下进行同步导致不必要开销的问题，第二次判断是由于可能存在线程 A，B 同时判断了对象为空，然后依次进入同步块中，如果这个时候不进行判断则可能导致创建出两个对象出来，所以需要进行第二次判断。 这个模式存在的一个问题是 mSingleInstance = new SingleInstance() 不是原子操作，其分为三个部分：给实例对象分配内存；调用构造函数，初始化成员字段；将实例对象指向分配的内存空间。并且后两步的执行顺序是不确定的，所以可能出现 A 线程执行完第三步，没有执行完第二步的情况下，程序切换至 B 线程，B 线程判断当前对象非空取走对象，但由于对象的成员字段没有初始化完成，所以可能出现错误。 解决办法是在 sInstance 前加上 volatile 关键字。 静态内部类 12345678910111213public class SingleInstance &#123; private SingleInstance() &#123; super(); &#125; public static SingleInstance newInstance() &#123; return SingleHolder.sSingleInstance; &#125; private static class SingleHolder &#123; private static final SingleInstance sSingleInstance = new SingleInstance(); &#125;&#125; 采用这种方式实现的单例模式很好的避免了 DCL 中可能出现的问题，由于内部类只有在使用它的成员以及方法的时候才会进行载入，所以可以做到使用的时候才实例化对象，而且能够确保线程安全。 枚举单例 1234567public enum SingletonEnum &#123; INSTANCE; public void doSomething() &#123; System.out.println("do sth."); &#125;&#125; 在任何情况下枚举实例都是一个单例，而且创建过程是线程安全的。 容器实现单例 12345678910111213141516public class SingletonManager &#123; private static Map&lt;String, Object&gt; objectMap = new HashMap&lt;&gt;(); private SingletonManager() &#123; &#125; public static void registerService(String key, Object instance) &#123; if (!objectMap.containsKey(key)) &#123; objectMap.put(key, instance); &#125; &#125; public static Object getService(String key) &#123; return objectMap.get(key); &#125;&#125; 采用容器实现的单例模式可以对多种对象的单例进行管理，例如 Android 当中的 getSystemService 就是这样实现的单例模式。 总结 前四种方式实现的单例模式存在在反序列化（反射执行无参构造函数）的情况下可能会重新创建一个对象，为了避免这种情况的发生，我们需要重写 readResolve 方法，这样在进行反序列化的时候就会执行这个方法获取对象实例。 123private Object readResolve()throws ObjectStreamException&#123; return sSingleInstance;&#125; 单例模式的核心在于将构造函数进行私有化，并且通过一个静态方法返回唯一的对象实例，在这个获取的过程当中需要保证线程安全、防止反序列化导致生成实例对象等问题。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android源码设计模式解析与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义控件之百分比圆环]]></title>
    <url>%2F2017%2F09%2F10%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%99%BE%E5%88%86%E6%AF%94%E5%9C%86%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[前言 最近做一个简单的测试 APP 的时候需要将手机的存储空间使用情况显示出来，刚好看见 360 清理大师的存储空间是以百分比圆环的方式实现的，所以大致模仿了一下它的实现过程。 效果图 首先放上效果图，然后我们再根据效果图进行分析 实现思路 从上图我们可以看到，绘制一个这样的百分比圆环主要有涉及到三个元素： 背景空心圆：代表着总的进度 圆弧：代表着当前进度 文字：需要居中，表示具体的进度 在了解到涉及到的元素之后，我们还需要了解绘制各个元素需要哪些参数，由于绘制都通过 onDraw 方法中的 canvas 对象，所以我们可以通过 canvas 对象的方法去确定所需要的参数。 绘制圆：查看 drawCircle 可以知道总共需要四个参数：圆心 X、Y 坐标、半径长度以及画笔 Paint； 绘制圆弧：查看 drawArc 可以知道总共需要四个参数：Recf、圆弧的起始角度、从起始角度顺时针扫过的角度以及必须的 Paint，这里的 Recf 确定了一个矩形区域，然后确定了一个内接椭圆，而圆弧的绘制实际上是在椭圆上面进行截取； 绘制文本：查看 drawText 可以知道，需要四个参数：文本内容、进行绘制的 X、Y 坐标点以及Paint。 实现过程 在了解了绘制元素所需要的参数，这个时候就可以一步步进行绘制了： 首先是绘制圆，这里我们定义了四个参数分别表示圆心 X，Y 的坐标、半径以及绘制所需要的画笔，然后对这些参数进行初始化，最终在 onDraw 进行绘制。 123456789101112131415161718192021222324252627282930public class RingPercentDemo extends View &#123; private int mCircleX; private int mCircleY; private int mRadius; private Paint mCirclePaint; public RingPercentDemo(Context context) &#123; super(context); &#125; public RingPercentDemo(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mCircleX = 300; mCircleY = 300; mRadius = 260; mCirclePaint = new Paint(); mCirclePaint.setColor(Color.BLUE); mCirclePaint.setStrokeWidth(10); mCirclePaint.setStyle(Style.STROKE); //绘制空心圆所以不需要填充 &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(mCircleX, mCircleY, mRadius, mCirclePaint); &#125;&#125; 接下来是绘制圆环，从效果图上可以看出来，圆环实际上是在圆上截取一段圆弧表示，所以绘制圆环的矩形区域可以确定下来，在确定了矩形区域之后只需要自己设定起始的角度和扫过的角度即可以绘制出在圆上的圆弧。 123456789101112131415161718192021222324252627282930313233343536public class RingPercentDemo extends View &#123; ... private RectF mRecF; private float mStartAngle; private float mSweepAngle; private Paint mRingPaint; public RingPercentDemo(Context context) &#123; super(context); &#125; public RingPercentDemo(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); ... mRecF = new RectF(mCircleX - mRadius, mCircleY - mRadius, mCircleX + mRadius, mCircleY + mRadius); mStartAngle = -90f; mSweepAngle = 120f; mRingPaint = new Paint(); mRingPaint.setColor(Color.RED); mRingPaint.setStrokeWidth(20); mRingPaint.setStyle(Style.STROKE); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); ... canvas.drawArc(mRecF, mStartAngle, mSweepAngle, false, mRingPaint); //设置为 false 不与中心点进行连接 &#125;&#125; 最后是绘制文本，由于要绘制在圆的中心，所以文本的坐标我们首先设置为圆的中心，然后绘制的风格选为 Align.CENTER，这样文本将以设定的坐标点向两边延伸保证了 X 处于中心位置。 123456789101112131415161718192021222324252627282930313233343536public class RingPercentDemo extends View &#123; ... private int mTextX; private int mTextY; private Paint mTextPaint; private String mTextStr; public RingPercentDemo(Context context) &#123; super(context); &#125; public RingPercentDemo(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); ... mTextPaint = new Paint(); mTextPaint.setColor(Color.BLACK); mTextPaint.setStyle(Style.FILL); mTextPaint.setTextSize(40); mTextPaint.setTextAlign(Align.CENTER); mTextPaint.setTextSize(mRadius / 2); mTextX = mCircleX; mTextY = mCircleY; mTextStr = "33%"; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); ... canvas.drawText(mTextStr, mTextX, mTextY, mTextPaint); &#125;&#125; 实际效果图： 这个时候我们能够发现文本实质上不在中心位置，这是为什么呢？因为我们在设定的坐标是用于确定绘制的基准线而不是绘制的中心点，所以自然文本不可能绘制在正中心，具体可以借用下图来进行描述： 从这就可以很明显的看到，文本的中心和设定的坐标之间是存在一个偏移量的，所以为了使文本处于真正的中心，我们需要计算得到这个偏移量，然后将之前设定的基准线下移。在计算偏移量之前首先需要了解字体是如何进行测量的，具体如下图所示： 其中 Top 表示基准线以上可绘制的最大距离（负数），Bottom 表示基准线以下可绘制的最大距离（正数），Ascent 表示基准线以上推荐的可绘制的距离，Descent 表示基准线以下推荐的可绘制的距离。 了解完这一切之后如何计算偏移量就很简单了，通过 FontMetrics 获取 Bottom 和 Top，然后通过 ((Bottom - Top) / 2) - Bottom 最终取得偏移量。代码做如下修改： 123456789101112131415161718192021public class RingPercentDemo extends View &#123; ... private int mTextX; private int mTextY; private Paint mTextPaint; private String mTextStr; public RingPercentDemo(Context context) &#123; super(context); &#125; public RingPercentDemo(Context context, @Nullable AttributeSet attrs) &#123; ... FontMetrics fontMetrics = mTextPaint.getFontMetrics(); float offsetY = ((fontMetrics.bottom - fontMetrics.top) / 2) - fontMetrics.bottom; mTextY = (int) (mCircleY + offsetY); ... &#125;&#125; 修改之后的效果： 改进 自定义属性 经过上述过程，虽然圆环百分比的效果已经实现，但是跟效果图中的还是差的很远，而且也不能够灵活，所以我们需要借助自定义属性去改进我们的圆环。 首先需要在 values 文件夹下创建 attrs.xml 文件在里面声明我们需要定义的属性： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="RingPercentDemo"&gt; &lt;attr format="integer" name="radius" /&gt; &lt;attr format="color" name="circleColor" /&gt; &lt;attr format="integer" name="circleStrokeWidth" /&gt; &lt;attr format="integer" name="circleStyle" /&gt; &lt;attr format="color" name="ringColor" /&gt; &lt;attr format="integer" name="ringStrokeWidth" /&gt; &lt;attr format="integer" name="startAngle" /&gt; &lt;attr format="integer" name="sweepAngle" /&gt; &lt;attr format="integer" name="rate" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 然后在构造函数获取到自定义的属性的属性值 12345678910111213141516171819202122232425262728public RingPercentDemo(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes( attrs, R.styleable.RingPercentDemo); mRadius = typedArray.getInteger(R.styleable.RingPercentDemo_radius, 60); mCircleColor = typedArray.getColor( R.styleable.RingPercentDemo_circleColor, Color.GREEN); mCircleStrokeWidth = typedArray.getInteger( R.styleable.RingPercentDemo_circleStrokeWidth, 5); mCircleStyle = typedArray.getInteger( R.styleable.RingPercentDemo_circleStyle, 0); mRingColor = typedArray.getColor( R.styleable.RingPercentDemo_ringColor, Color.RED); mRingStrokeWidth = typedArray.getColor( R.styleable.RingPercentDemo_ringStrokeWidth, 10); mStartAngle = typedArray.getInteger( R.styleable.RingPercentDemo_startAngle, -90); mSweepAngle = typedArray.getInteger( R.styleable.RingPercentDemo_sweepAngle, 90); mRate = typedArray.getInteger(R.styleable.RingPercentDemo_rate, 100); typedArray.recycle(); init(); &#125; 在获取到这些属性值之后只需要给对应的 Paint 和变量设置对应的值即可。 固定圆心和动态变化 圆心的位置我们希望能够一直处于 View 的中心，所以需要重写 onMeasure 方法，在 onMeasure 方法通过获取 View 的高度和宽度得到了 View 的中心点坐标，从而使得圆心一直在 View 的中心。 123456789101112131415161718192021222324@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measuse(widthMeasureSpec), measuse(heightMeasureSpec)); mCircleX = getMeasuredWidth() / 2; mCircleY = getMeasuredHeight() / 2; //判断设定的圆是否超出显示范围，如果超出需要缩小 if (mCircleX &lt; mRadius) &#123; mRadius = mCircleX - mCircleStrokeWidth - mRingStrokeWidth; mTextPaint.setTextSize(mRadius / 2); &#125; else if (mCircleY &lt; mRadius) &#123; mRadius = mCircleY - mCircleStrokeWidth - mRingStrokeWidth; mTextPaint.setTextSize(mRadius / 2); &#125; FontMetrics fontMetrics = mTextPaint.getFontMetrics(); int offsetY = (int) (((fontMetrics.bottom - fontMetrics.top)) / 2 - fontMetrics.bottom); mTextX = mCircleX; mTextY = mCircleY + offsetY; mRecF = new RectF(mCircleX - mRadius, mCircleY - mRadius, mCircleX + mRadius, mCircleY + mRadius);&#125; 在解决了圆心的问题之后，还需要为圆弧提供动态变化的效果，这里可以通过不断重绘达成目标。 1234567891011121314@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(mCircleX, mCircleY, mRadius, mCirclePaint); canvas.drawArc(mRecF, mStartAngle, mCurrentAngle, false, mRingPaint); canvas.drawText(mTextStr, mTextX, mTextY, mTextPaint); if (mCurrentAngle &lt; mSweepAngle) &#123; mCurrentAngle += 3.6; mTextStr = mCurrentAngle * 100 / 360 + "%"; postInvalidateDelayed(mRate); &#125;&#125; 相关测试工程 总结 涉及到 View 的绘制需要对元素进行拆分，然后进行单独处理，这样思路会比较清晰 Thanks android canvas drawText()文字居中 Android自定义控件之百分比圆环进度条]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 进阶之 Binder 浅解]]></title>
    <url>%2F2017%2F09%2F03%2FAndroid%E8%BF%9B%E9%98%B6%E4%B9%8BBinder%E6%B5%85%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是 Binder Binder 是 Android 中一种跨进程通信（IPC）方式。 #### Binder 的原理 Binder通信采用C/S架构，从组件视角来说，包含 Client、Server、ServiceManager 以及 binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。架构图如下所示： 此处的 Service Manager 是指 Native 层的 ServiceManager（C++） 注册服务(addService)：Server 进程要先注册 Service 到 ServiceManager。该过程：Server 是客户端，ServiceManager 是服务端。 获取服务(getService)：Client 进程使用某个 Service 前，须先向 ServiceManager 中获取相应的 Service。该过程：Client 是客户端，ServiceManager 是服务端。 使用服务：Client 根据得到的 Service 信息建立与 Service 所在的 Server 进程通信的通路，然后就可以直接与 Service 交互。该过程：Client 是客户端，Server 是服务端。 Binder 的结构 在学习 Binder 的结构的时候，可以利用 AIDL 去生成 Binder，这里我们首先需要创建一个实现了 Parcelable 接口的 Book 类，然后在 main 文件夹下创建 AIDL 文件夹，分别创建 Book.aidl、IBookManager.aidl。三个文件的代码分别如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Book.javapackage com.rookieyang.aidltest;import android.os.Parcel;import android.os.Parcelable;/** * Created by firstdream on 2017/9/4. */public class Book implements Parcelable &#123; private int mBookId; private String mBookName; public Book(int mBookId, String mBookName) &#123; this.mBookId = mBookId; this.mBookName = mBookName; &#125; @Override public void writeToParcel(Parcel parcel, int i) &#123; parcel.writeInt(mBookId); parcel.writeString(mBookName); &#125; @Override public int describeContents() &#123; return 0; &#125; public static final Parcelable.Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel parcel) &#123; Book book = new Book(parcel.readInt(), parcel.readString()); return book; &#125; @Override public Book[] newArray(int size) &#123; return new Book[size]; &#125; &#125;;&#125;// Book.aidlpackage com.rookieyang.aidltest;// Declare any non-default types here with import statementsparcelable Book;// IBookManager.aidlpackage com.rookieyang.aidltest;//需要导入 Book 类import com.rookieyang.aidltest.Book;// Declare any non-default types here with import statementsinterface IBookManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; 在经过上述的过程之后，点击编译即可生成 Binder 文件，以 IBookManager.aidl 生成的 IBookManager.java 为例， IBookManager.java 中定义了一个继承自 IInterface 的 IBookManager 接口，在 IBookManager 内包含了继承自 Binder 实现了 IBookManager 接口的内部类 Stub 和 实现了 IBookManager 接口的 Stub 的内部类 Proxy。整体结构如下图所示： 下面针对 IBookManager.java 进行具体的分析： IBookManager 接口，这个接口与在 IBookManager.aidl 中一致 getBookList() addBook(Book book) 12345678910public interface IBookManager extends IInterface &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ public List&lt;Book&gt; getBookList() throws RemoteException; public void addBook(Book book) throws RemoteException;&#125; Stub 类 DESCRIPTOR Binder 的唯一标识，一般用当前 Binder 的类名表示 TRANSACTION_getBookList 和 TRANSACTION_addBook 两个id用于标识在transact过程中客户端所请求的到底是哪个方法 asInterface(IBinder obj) 用于将服务端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的 Stub 对象本身，否则返回的是系统封装后的 Stub.proxy 对象。 asBinder 此方法用于返回当前 Binder 对象。 onTransact 这个方法运行在服务端中的 Binder 线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。 服务端通过 code 可以确定客户端所请求的目标方法是什么，接着从 data 中取出目标方法所需的参数（如果目标方法有参数的话），然后执行目标方法。当目标方法执行完毕后，就向 reply 中写入返回值（如果目标方法有返回值的话），onTransact 方法的执行过程就是这样的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public static abstract class Stub extends Binder implements IBookManager &#123; private static final String DESCRIPTOR = "com.rookieyang.binderdemo.IBookManager"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an IBookManager interface, * generating a proxy if needed. */ public static IBookManager asInterface(IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof IBookManager))) &#123; return ((IBookManager) iin); &#125; return new IBookManager.Stub.Proxy(obj); &#125; @Override public IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); List&lt;Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); Book _arg0; if ((0 != data.readInt())) &#123; //反序列化 _arg0 = Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; static final int TRANSACTION_getBookList = (IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (IBinder.FIRST_CALL_TRANSACTION + 1);&#125; Proxy 类 getBookList 这个方法运行在客户端，当客户端远程调用此方法时，它的内部实现是这样的：首先创建该方法所需要的输入型 Parcel 对象 _data 、输出型 Parcel 对象 _reply 和返回值对象 List；然后把该方法的参数信息写入 _data 中（如果有参数的话）；接着调用 transact 方法来发起 RPC（远程过程调用）请求，同时当前线程挂起；然后服务端的 onTransact 方法会被调用，直到 RPC 过程返回后，当前线程继续执行，并从 _reply 中取出 RPC 过程的返回结果；最后返回 _reply 中的数据。 addBook 这个方法运行在客户端，它的执行过程和 getBookList 是一样的，addBook 没有返回值，所以它不需要从 _reply 中取出返回值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private static class Proxy implements IBookManager &#123; private IBinder mRemote; Proxy(IBinder remote) &#123; mRemote = remote; &#125; @Override public IBinder asBinder() &#123; return mRemote; &#125; public String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); java.util.List&lt;Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(Book book) throws RemoteException &#123; Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125;&#125; Binder 的工作机制 &gt; 以上述为例，客户端调用 getBookList 方法时，在方法内部定义了 Parcel 对象，然后通过调用 transact 发起远程请求，服务器端接收到后调用 onTransact 方法，根据传递过来的 Code 进行相应的处理，将结果写入 Parcel 对象当中，处理完成之后在 客户端的 transact 将结果取出来并返回。 Binder 使用的一些注意点 Binder 一般和 Service 配合使用，作为 bindService 执行时的返回，最后在 ServiceConnect 当中获取返回的 Binder： 1234567891011private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; mCalcAidl = ICalcAIDL.Stub.asInterface(iBinder); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; mCalcAidl = null; &#125;&#125;; 不同进程时返回的 iBinder 是 ICalcAIDL.Stub.Proxy，而相同进程中则是 ICalcAIDL.Stub。是返回 Stub 还是返回 Proxy 在底层已经做了判断，不是在 onServiceConnected 方法中进行的判断 在服务中使用时，定义的 AIDL 文件包名必须相同，不然将无法找到对应的 AIDL，从而导致无法进行通信，并且使用时需要通过 ICalcAIDL.Stub 实现在 AIDL 中定义的接口，从而为客户端提供服务。 1234567891011private final ICalcAIDL.Stub mBinder = new Stub() &#123; @Override public int add(int x, int y) throws RemoteException &#123; return x + y; &#125; @Override public int min(int x, int y) throws RemoteException &#123; return x - y; &#125;&#125;; 总结 粗略的说，Client 通过 Binder 当中的 Proxy 进行了 IPC 的请求，而 Server 则通过 Stub 当中的 onTransact 对跨进程请求进行处理，之所以能进行跨进程请求的原因在于底层能够通过可序列化的数据，上述的 Book 类实现了 Parcelable 接口，而基本类型是被看作可序列化的，所以这些数据在底层能够进行传输，自然就可以通过 Binder 完成 IPC。 参考 Android 开发艺术探索-IPC 机制 Android aidl Binder框架浅析 Binder学习指南]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 基础之 Service]]></title>
    <url>%2F2017%2F08%2F27%2FAndroid%E5%9F%BA%E7%A1%80%E4%B9%8BService%2F</url>
    <content type="text"><![CDATA[Service 的含义及作用 Service 是一个可以在后台执行长时间运行操作而不需要提供用户界面的应用组件，也就是说 Service 是为了去处理那些不需要和用户交互但又耗时的操作。但是如果 Service 只是为了执行那些耗时的操作的话，其实只用线程也可以达到同样的目的，之所以需要单独用 Service 来进行实现的原因在于 Service 相较之线程而言优先级比较高，并且 Service 通过绑定启动的时候是可控的，如果系统不是极端不够用，一般而言是不会杀死 Service，但是线程可能存在被系统回收的可能性，所以 Service 的可靠性要比线程高。 另外关于 Service，官网上还有如下的提示： &gt; 服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互 Service 的生命周期 Service 的生命周期主要和服务的使用方式有关，使用服务主要分为启动和绑定两种方式，其生命周期如下图所示： Service 的基本使用 创建服务 系统提供了一个 Service 抽象类，所以我们自己实现一个继承自 Service 的类，然后在 AndroidManifest.xml 注册即可。 运行服务 运行服务主要方法有两种，一种是调用 startService()，第二种则是 bindService()。实际上这两个方法可以同时调用。 服务中处理事件 startService 启动服务，事件的处理一般在服务的 onStartCommand 方法进行的，bindService 绑定服务之后，将会在 ServiceConnection 的 onServiceConnected 中返回一个 Binder 对象，利用返回的 Binder 对象可以调用相关的事件处理方法。 停止服务 服务的运行条件是服务被绑定或者被启动，所以想让服务不运行则需要破坏这两个条件，可以通过调用 stopService 和 unbindService 实现。]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 基础之 BroastCasts]]></title>
    <url>%2F2017%2F08%2F26%2FAndroid%E4%B9%8BBroastCastReceiver%2F</url>
    <content type="text"><![CDATA[BroadCasts 定义及其作用 BroadCasts 是一种广播机制，类似于发布-订阅这种机制，当发生一些事件的时候，系统或程序就会发送（发布）一些相关的广播，而注册（订阅）了这些广播的程序就会通过广播接收器去响应这些广播。 #### BroadCasts 的分类 1. 按作用范围来分： * 全局广播 * 本地广播 本地主要为了解决全局广播的安全性问题，由于全局广播是面向系统中所有应用的，所以当携带一些关键数据时可能会导致数据的泄漏。 2. 按接收顺序来分： * 标准广播 标准广播在发出之后，所有相关的广播接收器几乎能够一次性接收到该条广播。 * 有序广播 有序广播发出后，同一时间只有一个广播接收器能够接收到这条广播消息，只有当该广播接收器当中的处理逻辑处理完成之后，广播才能向下传递，并且优先级高的广播能够截断正在传递的广播。如果多个应用程序设置的优先级别相同，则谁先注册的广播，谁就可以优先接收到广播。 BroadCasts 的使用 广播机制的使用方法大体按照如下步骤： 创建广播接收器 Android 系统提供了一个 BroadCastReciver 的抽象类，所以需要创建自己的广播接收器，然后重写当中的 onReceive 方法，在当中编写事件的处理逻辑。 123456789101112131415161718class ForceReceiver extends BroadcastReceiver &#123; @Override public void onReceive(final Context context, Intent intent) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle("提示"); builder.setMessage("已经被退出"); builder.setCancelable(false); builder.setPositiveButton("OK", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; ActivityCollector.finishActivities(); Intent intent = new Intent(context, LoginActivity.class); context.startActivity(intent); &#125; &#125;).show(); &#125;&#125; 注册广播 为了进行广播的接收还需要对需要接收的广播进行注册，注册方式可以分为两种： 第一种是动态注册，如果是全局广播则在 Activity 中直接调用 registerReceiver 方法即可，该方法主要接收两个参数，一个是 BroadCastReceiver，第二个则是 IntentFilter。如果是本地广播则需要借助系统提供的 LocalBroadCastManager 去进行注册，方法名与注册全局广播的方法名一致。 全局广播： 123IntentFilter intentFilter = new IntentFilter("com.rookieyang.forcelogin");forceReceiver = new ForceReceiver();registerReceiver(forceReceiver, intentFilter); 本地广播： 1234IntentFilter intentFilter = new IntentFilter("com.rookieyang.forcelogin");forceReceiver = new ForceReceiver();LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(this);localBroadcastManager.registerReceiver(forceReceiver, intentFilter); 第二种是静态注册，静态注册可以实现在程序未启动的情况下接收到广播，静态注册的广播是全局广播。 123456789&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt;&lt;receiver android:name=".BootCompleteReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 监听系统的开机广播是需要添加权限的，动态注册相比较于静态注册而言更为灵活，但是静态注册能够实现在应用未启动的情况下接收广播。而且动态注册的广播最后必须要取消注册。 发送广播 发送广播需要主要通过 Intent 传递信息，如果是是系统广播则不需要我们去编码去发送广播，如果是自定义的广播，发送标准广播则调用 sendBroadCast 方法，发送有序广播则调用 sendOrderedBroadcast 方法。如果是本地广播则和上文一致需要借助 LocalBroadCastManager 进行发送，本地广播没有有序广播。 1234Intent intent = new Intent("com.rookieyang.forcelogin");sendBroadcast(intent);//sendOrderedBroadcast(intent);localBroadcastManager.sendBroadcast(); 接收处理 接收处理在广播接收器的 onReceive 方法中进行，创建广播接收器中已经说明，在此不再赘述。 取消注册 静态注册的不需要我们编码去取消注册，对于动态注册的则需要编码去取消注册，如果是全局广播则调用 unregisterReceiver 方法即可，如果是本地广播则调用 LocalBroadCastManager 对象的该方法即可。 12unregisterReceiver(forceReceiver);localBroadcastManager.unregisterReceiver(forceReceiver);]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BroatCasts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 14.04下AVD的创建以及闪退问题]]></title>
    <url>%2F2017%2F08%2F24%2FAndroid%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B9%8BAVD%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%8F%8A%E9%97%AA%E9%80%80%2F</url>
    <content type="text"><![CDATA[在 Ubuntu 14.04 下创建 Android 虚拟机时可能会出现下列错误： An error occurred while creating the AVD. See idea.log for details 在网上查找之后很多人建议使用 sudo apt-get install lib32stdc++6 这条命令，但是实际上采用这条命令去安装会出现依赖冲突的问题，所以需要借助 sudo aptitude -f install lib32stdc++6 去解决依赖问题，这条语句使用一次可能并不能解决问题，实际当中我运行了三次才解决了依赖的冲突的问题，每一次运行的时候依次选择 no-&gt;yes-&gt;yes。具体要运行几次，必须看 lib32stdc++6 库是否安装成功。 在经过上述的操作之后，虽然 AVD 可能能成功创建，但实际可能还是无法启动，无法启动的原因可能是需要安装 Intel's KVM，具体步骤可以参考Setting Up Android Studio on Ubuntu当中的 Install Intel's KVM for Better AVD Performance 部分，在这部分当中只需做到第七步即可，由于我使用的 AndroidStudio 2.3，无法找到第八步所说的选项。 在安装好所需要的一切库之后，接下来的步骤如下： 1. 创建虚拟机，记下虚拟机名称 2. 进入到 Sdk 路径下的 tools 目录，执行以下指令 &gt; sudo chmod +x emulator &gt; ./emulator -avd 虚拟机名称 -qemu -m 2047 -enable-kvm 在经过上述的两个步骤之后基本上是能够成功启动了的。]]></content>
      <categories>
        <category>Android问题记录</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程简述]]></title>
    <url>%2F2017%2F08%2F22%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[线程的作用 线程（英语：Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 简而言之，线程的存在是为了实现程序的并发操作，提高执行效率。 线程的生命周期 线程的主要生命周期如上图所示，主要分为五个状态： 新建态（New）：Java 中使用 new 关键字创建线程之后，这时线程即处于新建态。 就绪态（Runnable）：在线程调用 start() 方法之后，线程即处于就绪态。 运行态（Running）：当就绪态的线程获得 CPU 并且开始执行 run() 方法之后，线程就会处于运行状态。 阻塞态（Blocked）：在处于运行态的线程调用了 sleep() 或 wait() 又或者是调用了一个阻塞式的 IO 方法之后，线程将会处于阻塞状态。 死亡态（Dead）：在线程中的 run() 方法执行完毕、线程抛出异常、调用线程的 stop() 这几种情形下线程将会进入死亡态。 线程的实现方法 Java 中线程的实现主要是通过 Thread 类和 Runnable 接口。 通过 Thread 类实现： 123456Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; /** do some things **/ &#125;&#125;); 通过 Runnable 接口实现： 12345678public class MyThread implements Runnable &#123; @Override public void run() &#123; /** do some things **/ &#125;&#125;MyThread myThread = new MyThread();Thread thread = new Thread(myThread); 相对而言第二种方式更为合理一些，第二种方式创建的线程类只实现了 Runnable 接口，还可以再继承其它的父类。 参考资料 【Java并发编程】之六：Runnable和Thread实现多线程的区别（含代码）]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 基础之 LayoutInflater 总结]]></title>
    <url>%2F2017%2F07%2F22%2FAndroid%E5%9F%BA%E7%A1%80%E4%B9%8BLayoutInflater%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[LayoutInflater 的获取 获取 LayoutInflater 的方式一般有三种： getLayoutInflater() LayoutInflater.from(Context context) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) 这三种获取方式本质上都是一样的 getLayoutInflater() 通过 getWindow().getLayoutInflater() 进行获取，getWindow() 获取的是 PhoneWindow，然后 PhoneWindow 通过 mLayoutInflater = LayoutInflater.from(context) 获取 LayoutInflater。 LayoutInflater.from(Context context) 内部通过以下代码获取 LayoutInflater。 12345678public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError("LayoutInflater not found."); &#125; return LayoutInflater;&#125; 结论：所以这三种方式最终都调用了 Context.getSystemService() LayoutInflater 的 inflater 方法 inflater 作为 LayoutInflater 中最常用的方法，用于从 xml 的布局文件得到一个 View 对象，加载到 Activity 用于动态创建布局。inflater 总共重载了 4 种调用方式： 1. public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) 2. public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) 3. public View inflate(XmlPullParser parser, @Nullable ViewGroup root) 4. public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) 对于构造函数的使用而言，有如下注意事项： root 填充的根视图 attachToRoot 决定是否将载入的视图附加到根视图上，如果为 false 则仅用于为 XML 中的根视图创建正确的 LayoutParams 的子类 前三个 inflater 方法最终都会调用第四个 inflater 方法，采用了 pull 解析 避免将 null 作为 ViewGroup 传入 当不需要将返回的 View 添加入 ViewGroup 时应该设置attachToRoot 为 false 避免在 View 已经被添加入 ViewGroup 时将 attachToRoot 设置为 True 自定义 View 时非常适合将 attachToRoot 设置为 True LayoutInflater 基本使用 由于 LayoutInflater 主要用于布局填充，所以主要涉及到的是 inflater 方法，inflater 返回了一个 View，其调用方式是： 12LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);View view = inflater.inflate(R.layout.first_fragment, container, false); 参考资料 深入理解 LayoutInflater.inflate() Android LayoutInflater 原理分析，带你一步步深入了解 View (一) LayoutInflater——80%的Android程序员对它并不了解甚至错误使用]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>LayoutInflater</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask 总结]]></title>
    <url>%2F2017%2F07%2F11%2FAndroid%E5%9F%BA%E7%A1%80%E4%B9%8BAsyncTask%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AsyncTask 的作用 AsyncTask 允许对用户界面执行异步操作。 它会先阻塞工作线程中的操作，然后在 UI 线程中发布结果，而无需您亲自处理线程和/或处理程序。 AsyncTask 基于异步消息处理机制进行实现，通过 AsyncTask 能够很简单的从子线程切换至主线程。 AsyncTask 的基本使用 由于 AsyncTask 是抽象类，所以首先需要创建一个继承它的子类。 1public class MyAsyncTask extends AsyncTask&lt;Void, Integer, Boolean&gt; 其中可以为 AsyncTask 指定三个泛型参数 Params：执行 Task 时传递的参数，在后台任务中使用，这里指定为 Void Progress：指定进度单位，这里指定为 Integer Result：执行完任务后返回的类型，这里指定为 Boolean 重写 AsyncTask 的一些方法，主要是下面四个： 12345678910111213141516171819202122232425262728293031323334353637383940@Overrideprotected void onPreExecute() &#123; progressDialog.show();&#125;@Overrideprotected Boolean doInBackground(Void... voids) &#123; while (true) &#123; int percent = doDownload(); publishProgress(percent); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; return false; &#125; if (percent &gt;= 100) &#123; break; &#125; &#125; return true;&#125;@Overrideprotected void onProgressUpdate(Integer... values) &#123; progressDialog.setMessage("Downloaded " + values[0] + "%");&#125;@Overrideprotected void onPostExecute(Boolean result) &#123; progressDialog.dismiss(); if (result) &#123; Toast.makeText(MainActivity.getCurrentContext(), "Download Succeeded", Toast.LENGTH_LONG).show(); &#125; else &#123; Toast.makeText(MainActivity.getCurrentContext(), "Download Failed", Toast.LENGTH_LONG).show(); &#125;&#125; onPreExecute()：任务执行之前在 UI 线程当中进行调用，通常用于进行一些界面的初始化工作，譬如显示一个进度条。 doInBackground(Params...)：必须实现的方法，在 onPreExecute() 方法执行完毕之后运行在子线程上，通常用于执行耗时任务，Params 参数将会传递至该方法。执行完任务之后将会通过 return 语句返回执行结果，如果 Result 设定为 Void 则可以不进行返回。同时在该方法中可以通过 publishProgress(Progress...) 方法对任务执行进度进行反馈。 onProgressUpdate(Progress...)：publishProgress(Progress...) 被调用之后执行在 UI 线程当中，在该方法中可以展示任务执行的进度及对进度进行更新，譬如可以对进度条进行动画处理。 onPostExecute(Result)：任务执行完之后的返回结果将会传递至该方法，可以利用返回的结果进行一些 UI 操作，譬如提醒任务执行的结果，该方法运行在 UI 线程中。 AsyncTask 源码浅解 执行过程图 执行过程 首先通过调用 execute(Params... params) 方法执行任务 内部执行了 executeOnExecutor(sDefaultExecutor, params)，sDefaultExecutor 是内部定义的 SerialExecutor 类的对象，主要的方法是 execute(final Runnable r) 用于启动一个线程。 executeOnExecutor(Executor exec, Params... params) 作为第一步中执行的方法，首先会判断任务的运行状态，如果是 PENDING 则表明没有运行，然后便会执行 onPreExecute() 方法，之后将 params 传递给 mWorker 对象，mWorker 是一个实现了 Callable 接口的 WorkerRunnable 对象，最后调用 exec.execute(mFuture) 去启动线程。其中 mWorker 和 mFuture 对象在构造函数中完成了初始化过程。mFuture 是一个实现了 RunnableFuture 接口的 FutureTask 对象，FutureTask 的 run() 方法将会调用 Callable 接口的 call() 方法。也即是说 exec.execute(mFuture) 调用了 mFuture 的 run() 方法从而调用了 mWorker 的 call() 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//execute 的执行过程exec.execute(mFuture);private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125;//mFuture 调用 mWorker.call() 的过程mFuture = new FutureTask&lt;Result&gt;(mWorker)//将 mWorker 保存至 mFuture 的 callablepublic FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125;public void run() &#123; if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return; try &#123; //callable 赋值给 c Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; //相当于调用 mWorker 的 call 方法 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 执行完上述两步之后 mWorker.call() 得到了调用，任务开始启动。 在 call() 方法中调用了 doInBackground(mParams) 并将结果保存在 result 变量当中，然后在 postResult(result) 中通过 getHandler() 获取到 InternalHandler 对象，通过 obtainMessage() 方法将结果发送出去，之后在 handleMessage(Message msg) 中调用了 finish() 方法。finish() 方法中最终调用了 onPostExecute(result) 方法。 如果在 doInBackground(mParams) 调用了 publishProgress(Progress... values)，则在 publishProgress(Progress... values) 中也会通过 getHandler() 发送 Message，然后在 handleMessage(Message msg) 中调用 onProgressUpdate(Progress... values) 方法。 12345678910111213141516171819202122232425262728293031323334353637private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125;@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125;public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125;&#125;private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; ​]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gallery 的三种实现方式]]></title>
    <url>%2F2017%2F05%2F08%2FAndroid%E4%B9%8BGallery%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Gallery 主要内容： 目标效果： 需求分析 从目标效果上来看主要考虑以下几个点： 图片如何切换和切换动画 ImageSwitcher 提供了 setImageResource (int resid) 方法对下一个 ImageView 进行图片加载和切换，切换的动画效果需要自定义 ViewPager 的切换和切换动画内部处理 HorizontalScrollView 可以通过 smoothScrollBy (int dx, int dy) 方法进行平滑切换 图片的切换方向 ImageSwitcher 的切换方向需要自己判断 HorizontalScrollView 的切换方向虽然不用判断，但是滑动距离需要自己控制 ViewPager 的切换方向无需处理 确定切换时应该加载的图片 ImageSwitcher 和 HorizontalScrollView 加载图片需要自己判断 ViewPager 的加载图片无需处理 图片下方的圆点效果，与图片数量一致 圆点和图片的同步切换 ImageSwitcher 实现 ImageSwitcher 的特点 首先查看 ImageSwitcher 和 ViewSwitcher 的官方 API： ViewSwitcher that switches between two ImageViews when a new image is set on it. The views added to an ImageSwitcher must all be ImageViews. ViewAnimator that switches between two views, and has a factory from which these views are created. You can either use the factory to create the views, or add them yourself. A ViewSwitcher can only have two child views, of which only one is shown at a time. 官方给出的 API 说明了，ImageSwitcher 里最多只能由两个 ImageView，同一时间只能显示一个，在两个 ImageView 之间能够设置视图切换动画，并且提供了 factory 用于创建两个 ImageView（当然也可以选择自行添加）。 实现过程 首先我们需要在布局文件中添加 ImageSwitcher 控件： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.rookieyang.gallerytest.ImageSwitcherTest"&gt; &lt;ImageSwitcher android:id="@+id/imageSwitcher" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="match_parent" android:layout_marginBottom="30dp"&gt; &lt;LinearLayout android:id="@+id/tipsLayout" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:gravity="center_horizontal" android:orientation="horizontal"/&gt; &lt;/RelativeLayout&gt;&lt;/FrameLayout&gt; 采用 FrameLayout 将圆点部分置于图片的上方，RelativeLayout 用于控制原点部分在底部，LinearLayout 中的属性设置用于将圆点水平居中放置。 在添加完 ImageSwiter 之后，通过 setFactory(ViewFactory factory) 函数为 ImageSwiter 添加 ImageView： 1234567891011mImageSwitcher.setFactory(new ViewFactory() &#123; @Override public View makeView() &#123; ImageView imageView = new ImageView(ImageSwitcherTest.this); ImageSwitcher.LayoutParams layoutParams = new ImageSwitcher.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); imageView.setScaleType(ScaleType.CENTER_CROP); imageView.setLayoutParams(layoutParams); return imageView; &#125;&#125;); 这里为 ImageSwitcher 设置了一个 factory，在 setFactory(ViewFactory factory) 内部会执行两次 obtainView() 完成 View 的增加。 上述过程只是完成了 ImageView 的添加，实际的图片还没有被加载，由于 ImageSwitcher 的限制，所以我们不能直接将 ImageView 一次性添加进去（这样性能也不高），可以选择用一个数组对图片资源进行保存，在调用 setImageResource() 时进行加载： 12private int[] mImageId = new int[]&#123;R.drawable.pic1, R.drawable.pic2, R.drawable.pic3&#125;;mImageSwitcher.setImageResource(mImageId[0]); 在解决了如何加载图片之后，还需要为图片下方添加圆点效果，圆点的个数由图片的个数决定，代码如下： 12345678910111213141516171819202122232425private ImageView[] mTips;mTips = new ImageView[mImageId.length];LinearLayout tipsLinearLayout = (LinearLayout) findViewById(R.id.tipsLayout);for (int i = 0; i &lt; mImageId.length; i++) &#123; mTips[i] = new ImageView(this); LinearLayout.LayoutParams layoutParams = new LayoutParams( new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)); layoutParams.leftMargin = 5; layoutParams.rightMargin = 5; tipsLinearLayout.addView(mTips[i], layoutParams);&#125;setTipsImage(0);private void setTipsImage(int position) &#123; for (int i = 0; i &lt; mImageId.length; i++) &#123; if (i == position) &#123; mTips[i].setImageResource(R.drawable.page_indicator_focused); &#125; else &#123; mTips[i].setImageResource(R.drawable.page_indicator_unfocused); &#125; &#125;&#125; 在完成上述步骤之后我们还需要完成的是让图片和圆点同时进行切换、确定切换方向和应该加载的图片以及切换的动画，对于图片的切换方向可以依据第一次按住屏幕和离开屏幕这两点的位置进行判断，而切换时加载的图片则可以用一个变量对当前图片序号进行保存，动画效果则可以定义四个动画（左进，左出，右进、右出）文件： 1234567891011121314151617181920212223242526272829303132&lt;!--left_in--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:fromXDelta="-100%p" android:toXDelta="0" android:duration="500"/&gt;&lt;/set&gt;&lt;!--left_out--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:fromXDelta="0" android:toXDelta="-100%p" android:duration="500"/&gt;&lt;/set&gt;&lt;!--right_in--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:fromXDelta="100%p" android:toXDelta="0" android:duration="500"/&gt;&lt;/set&gt;&lt;!--right_out--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:fromXDelta="0" android:toXDelta="100%p" android:duration="500"/&gt;&lt;/set&gt; 123456789101112131415161718192021222324252627282930313233343536373839private int mDownX;private int mCurrentPosition = 0;mImageSwitcher.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = (int) event.getX(); break; case MotionEvent.ACTION_UP: int upX = (int) event.getX(); if (upX &gt; mDownX) &#123; if (mCurrentPosition &gt; 0) &#123; mImageSwitcher.setInAnimation(ImageSwitcherTest.this, R.anim.left_in); mImageSwitcher.setOutAnimation(ImageSwitcherTest.this, R.anim.right_out); mCurrentPosition--; mImageSwitcher.setImageResource(mImageId[mCurrentPosition]); setTipsImage(mCurrentPosition); &#125; &#125; else if (upX &lt; mDownX) &#123; if (mCurrentPosition &lt; mImageId.length - 1) &#123; mImageSwitcher.setInAnimation(ImageSwitcherTest.this, R.anim.right_in); mImageSwitcher.setOutAnimation(ImageSwitcherTest.this, R.anim.left_out); mCurrentPosition++; mImageSwitcher.setImageResource(mImageId[mCurrentPosition]); setTipsImage(mCurrentPosition); &#125; &#125; break; &#125; return true; &#125;&#125;);​ ViewPager 实现 ViewPager 的特点 ViewPager is most often used in conjunction with Fragment, which is a convenient way to supply and manage the lifecycle of each page. There are standard adapters implemented for using fragments with the ViewPager, which cover the most common use cases. These are FragmentPagerAdapter and FragmentStatePagerAdapter; each of these classes have simple code showing how to build a full user interface with them. ViewPager 一般结合 Fragment 使用，每个页面就是一个 Fragment，系统提供了 FragmentPagerAdapter 和 FragmentStatePagerAdapter 用于填充 ViewPager。 实现过程 首先向布局文件中添加 ViewPager 控件： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.rookieyang.gallerytest.ViewPagerTest"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="match_parent" android:layout_marginBottom="30dp"&gt; &lt;LinearLayout android:id="@+id/tipsFragmentLayout" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:gravity="center_horizontal" android:orientation="horizontal"/&gt; &lt;/RelativeLayout&gt;&lt;/FrameLayout&gt; 布局基本与 ImageSwitcher 一致，只是将 ImageSwitcher 控件替换为 ViewPager。 接下来需要将图片加载到 ViewPager 中去，可以利用 FragmentPagerAdapter 达到这一目的，由于 FragmentPagerAdapter 返回的是 Fragment，所以创建了 ImageFragment 类，用于将 Image 放置到 Fragment中，代码布局如下： 12345678910111213141516171819202122232425public class ImageFragment extends Fragment &#123;private View view;private int imageViewRes;@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment view = inflater.inflate(R.layout.fragment_image, container, false); return view;&#125;@Overridepublic void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); ImageView imageView = (ImageView) view.findViewById(R.id.viewPageImage); imageView.setScaleType(ScaleType.CENTER_CROP); imageView.setImageResource(imageViewRes);&#125;public void setImageView(int imageViewRes) &#123; this.imageViewRes = imageViewRes;&#125;&#125; 12345678910&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.rookieyang.gallerytest.ImageFragment"&gt; &lt;ImageView android:id="@+id/viewPageImage" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/FrameLayout&gt; 接下来实现继承自 FragmentPagerAdapter 的 ImagePagerAdapter 类，代码如下： 1234567891011121314151617181920public class ImagePagerAdapter extends FragmentPagerAdapter &#123; private List&lt;ImageFragment&gt; mFragments; public ImagePagerAdapter(FragmentManager fm, List&lt;ImageFragment&gt; fragments) &#123; super(fm); mFragments = fragments; &#125; @Override public ImageFragment getItem(int position) &#123; Log.i("getItem", "getItem: " + mFragments.get(position).getId()); return mFragments.get(position); &#125; @Override public int getCount() &#123; return mFragments.size(); &#125;&#125; 在完成上述的步骤之后，利用保存图片资源的数组创建对应个数的 ImageFragment 并保存到 List 中，然后创建一个 ImagePagerAdapter 对象，替 ViewPager 设置适配器即可实现图片的加载和滑动。由于 ViewPager 内部处理了滑动方向和下一张图片加载判断的问题，所以只剩下图片与圆点的同步切换需要进行处理，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748mImageIds = new int[]&#123;R.drawable.pic1, R.drawable.pic2, R.drawable.pic3&#125;;mTips = new ImageView[mImageIds.length];mViewPager = (ViewPager) findViewById(R.id.viewPager);ViewGroup viewGroup = (ViewGroup) findViewById(R.id.tipsFragmentLayout);LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams( new ViewGroup.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));layoutParams.rightMargin = 5;layoutParams.leftMargin = 5;for (int i = 0; i &lt; mImageIds.length; i++) &#123; ImageFragment imageFragment = new ImageFragment(); imageFragment.setImageView(mImageIds[i]); mImageFragments.add(imageFragment); if (mImageIds.length &gt; 1) &#123; mTips[i] = new ImageView(this); mTips[i].setImageResource(R.drawable.page_indicator_unfocused); viewGroup.addView(mTips[i], layoutParams); mTips[mCurrentPosition].setImageResource(R.drawable.page_indicator_focused); &#125;&#125;ImagePagerAdapter imagePagerAdapter = new ImagePagerAdapter( getSupportFragmentManager(), mImageFragments);mViewPager.setAdapter(imagePagerAdapter);mViewPager.addOnPageChangeListener(new OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; if (mImageIds.length &gt; 1) &#123; for (int i = 0; i &lt; mImageIds.length; i++) &#123; if (i == position) &#123; mTips[i].setImageResource(R.drawable.page_indicator_focused); &#125; else &#123; mTips[i].setImageResource(R.drawable.page_indicator_unfocused); &#125; &#125; &#125; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125;&#125;); HorizontalScrollView 实现 HorizontalScrollView 特点 A HorizontalScrollView is a FrameLayout, meaning you should place one child in it containing the entire contents to scroll; this child may itself be a layout manager with a complex hierarchy of objects. A child that is often used is a LinearLayout in a horizontal orientation, presenting a horizontal array of top-level items that the user can scroll through. 从这里可以了解到如果要实现上面的效果，那么应该在 HorizontalScrollView 放置一个 LinearLayout，然后 LinearLayout 内加载的是要显示的图片，由于是水平滑动，所以 LinearLayout 的方向也要是水平的。 实现过程 依旧是添加了 HorizontalScrollView 控件，把放置 ImageSwwitcher 的部分替换为： 1234567891011&lt;HorizontalScrollView android:id="@+id/horizontalScrollView" android:layout_width="match_parent" android:layout_height="match_parent" android:scrollbars="none"&gt; &lt;LinearLayout android:id="@+id/imageLayout" android:layout_width="wrap_content" android:layout_height="match_parent" android:orientation="horizontal" /&gt; &lt;/HorizontalScrollView&gt; 为了效果一致去掉了滚动条。 添加完控件之后，就需要填充 HorizontalScrollView ，为了扩展性，所以创建了一个 HorizontalViewAdapter 类，代码如下： 1234567891011121314151617181920212223242526272829303132333435public class HorizontalViewAdapter&#123; private int[] mImageResIdList; private Context mContext; public HorizontalViewAdapter(Context context, int[] imageResIdList) &#123; mContext = context; mImageResIdList = imageResIdList; &#125; public int getCount() &#123; return mImageResIdList.length; &#125; public ImageView getItem(int position) &#123; ImageView imageView = new ImageView(mContext); WindowManager wm = (WindowManager) mContext. getSystemService(Context.WINDOW_SERVICE); DisplayMetrics displayMetrics = new DisplayMetrics(); wm.getDefaultDisplay().getMetrics(displayMetrics); int width = displayMetrics.widthPixels; int height = displayMetrics.heightPixels; Log.i("Adpter: ", String.valueOf(width)); LinearLayout.LayoutParams layoutParams = new LayoutParams( new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT)); layoutParams.width = width; layoutParams.height = height; imageView.setLayoutParams(layoutParams); imageView.setScaleType(ScaleType.CENTER_CROP); imageView.setImageResource(mImageResIdList[position]); return imageView; &#125;&#125; 这里图片的长和宽会根据设备的分辨率进行指定，之所以不用 match_parent 的原因是这样会导致显示效果出问题。 在创建完适配器之后，由于 HorizontalScrollView 没有设置适配器的方法，所以需要实现 setAdapter() 方法，代码如下： 123456789101112131415161718public void setAdapter(HorizontalViewAdapter horizontalViewAdapter) &#123; mTips = new ImageView[mImageId.length]; LinearLayout imageLayout = (LinearLayout) findViewById(R.id.imageLayout); LinearLayout tipsLinearLayout = (LinearLayout) findViewById(R.id.horizontalTipsLayout); int size = horizontalViewAdapter.getCount(); for (int i = 0; i &lt; size; i++) &#123; ImageView imageView = horizontalViewAdapter.getItem(i); imageLayout.addView(imageView); mTips[i] = new ImageView(this); LinearLayout.LayoutParams layoutParams = new LayoutParams( new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)); layoutParams.leftMargin = 5; layoutParams.rightMargin = 5; tipsLinearLayout.addView(mTips[i], layoutParams); &#125;&#125; 实现 setAdapter() 方法之后，就可以在 onCreate() 方法中调用了，调用之后图片会被加载到布局中，这时候也可以滑动，但是由于滑动距离没有控制，所以并没有达到想要的效果，由于图片的长度取决于设备的分辨率，所以可以获取设备的长度作为滑动距离，为 HorizontalScrollView 设置监听事件，当触摸屏幕之后进行判断，确定实际滑动的方向，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637//获取图片滑动距离WindowManager wm = (WindowManager) getApplicationContext(). getSystemService(Context.WINDOW_SERVICE);DisplayMetrics displayMetrics = new DisplayMetrics();wm.getDefaultDisplay().getMetrics(displayMetrics);mScrollX = displayMetrics.widthPixels;//确定的滑动方向final HorizontalScrollView horizontalScrollView = (HorizontalScrollView) findViewById( R.id.horizontalScrollView);horizontalScrollView.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = (int) event.getX(); break; case MotionEvent.ACTION_UP: int upX = (int) event.getX(); if (upX &gt; mDownX) &#123; if (mCurrentPosition &gt; 0) &#123; mCurrentPosition--; horizontalScrollView.smoothScrollBy(-mScrollX, 0); setTipsImage(mCurrentPosition); &#125; &#125; else if (upX &lt; mDownX) &#123; if (mCurrentPosition &lt; mImageId.length - 1) &#123; mCurrentPosition++; Log.i("onTouch: ", "onTouch: " + mCurrentPosition); horizontalScrollView.smoothScrollBy(mScrollX, 0); setTipsImage(mCurrentPosition); &#125; &#125; break; &#125; return true; &#125;&#125;); 总结 HorizontalScrollView 的实现实际上并不完善，因为 ImageView 是一次性全部添加进去的，并没有做优化处理，在虚拟机上运行时，由于超过了堆内存会导致报错。]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[onOptionsItemSelected() 返回值的理解]]></title>
    <url>%2F2017%2F05%2F03%2FAndroid%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95onOptionsItemSelected%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先查看官方 API 的解释： This hook is called whenever an item in your options menu is selected. The default implementation simply returns false to have the normal processing happen (calling the item's Runnable or sending a message to its Handler as appropriate). You can use this method for any items for which you would like to do processing without those other facilities. 也就是说当点击 OptionsMenu 中的 Item 时，默认会返回 false，这个时候将会处理 item 关联的 Runnable 或发送一条 message 给它的 Handler。 为了弄清楚返回 false 时可能会发生什么做了如下测试： 测试一 123456789101112131415161718@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(MainActivity.this, "Add", Toast.LENGTH_LONG).show(); break; case R.id.remove_item: Toast.makeText(MainActivity.this, "Remove", Toast.LENGTH_LONG).show(); item.setActionView(R.layout.progress); Intent intent = new Intent(MainActivity.this, SecondActivity.class); item.setIntent(intent); Log.i(TAG, "onOptionsItemSelected: Remove"); break; default: Toast.makeText(MainActivity.this, "re", Toast.LENGTH_LONG).show(); &#125; return true;&#125; 上述代码中给 item 关联了一个 Intent 用于跳转到 SecondActivity，如果返回为 true 则点击 item 时不会跳转到 SecondActivity，如果返回 false 则会跳转到 SecondActivity。 测试二 创建一个 Fragment 12345678910111213141516171819202122232425262728public class MyFragment extends Fragment &#123; @Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; inflater.inflate(R.menu.main, menu); super.onCreateOptionsMenu(menu, inflater); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.remove_item: Toast.makeText(getContext(), "Fragment Remove", Toast.LENGTH_LONG).show(); break; default: Toast.makeText(getContext(), "Fragment", Toast.LENGTH_LONG).show(); &#125; return false; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; setHasOptionsMenu(true); return inflater.inflate(fragment_layout, container, false); &#125;&#125; 上述创建了一个自定义的 Fragment 类，并添加了 OptionMenu 的点击事件。 在之前的 Activity 的布局文件中添加 Fragment 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;fragment android:id="@+id/fragment" android:layout_width="match_parent" android:layout_height="match_parent" android:name="com.rookieyang.demo.MyFragment" tools:layout="@layout/fragment_layout" /&gt;&lt;/LinearLayout&gt; 在完成上述步骤之后点击 remove 的 item，由于 Activity 中的 onOptionsItemSelected() 返回了false，导致事件没有被消费就会向下传递给 Fragment，进而执行 Fragment 中的 item 的点击事件，所以能够看到屏幕上将会显示 Fragment Remove 而不是 Remove。 补：OptionMenu 的 Item 自定义的点击事件优先级要高于 onOptionsItemSelected()。]]></content>
      <categories>
        <category>Android问题记录</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础之Activity]]></title>
    <url>%2F2017%2F05%2F02%2FAndroid%E5%9F%BA%E7%A1%80%E4%B9%8BActivity%2F</url>
    <content type="text"><![CDATA[Activity导图 主要内容： Activity 基本使用 创建活动 AndroidManifest.xml 的 application 标签内进行声明 载入布局 setContentView(R.layout.second_layout) Activity 跳转 显式 Intent 123//Intent(Context packageContext, Class&lt;?&gt; cls)Intent intent = new Intent(MainActivity.this, SecondActivity.class);startActivity(intent); 这种指定上下文和目标活动类名的 Intent 称之为显式 Intent。 隐式 Intent 12345678&lt;activity android:name=".SecondActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="com.rookieyang.demo.ACTION_START" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="com.rookieyang.demo.MY_CATEGORY" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 123Intent implieIntent = new Intent("com.rookieyang.demo.ACTION_START");implieIntent.addCategory("com.rookieyang.demo.MY_CATEGORY");startActivity(implieIntent); 隐式 Intent 通过指定一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动去启动。只有活动中的 &lt;action&gt; 和 &lt;category&gt; 标签完全匹配 Intent 中的 action 和 category 时，活动才能响应 Intent。 在调用 startActivity() 方法时会自动将 android.intent.category.DEFAULT 加入到 Intent 中，所以在给 Activity 指定 category 的时候不能够去掉默认的 android.intent.category.DEFAULT，去掉之后通过隐式 Intent 将无法匹配到该 Activity。 隐式 Intent 除了可以启动自己程序内的活动，还可以启动其他程序的活动： 12345678btn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("http://www.baidu.com")); startActivity(intent); &#125;&#125;); 隐式 Intent 指定了一个系统内置的 action，通过 setData() 设置 Intent 操作的数据用以调用系统浏览器，其中 setData() 对应 &lt;intent-filter&gt; 标签内的 &lt;data&gt; 标签，用于指定当前活动能够响应什么类型的数据。&lt;data&gt; 标签中主要可以配置以下内容： android:scheme：用于指定数据的协议部分，如上例的 http 部分。 android:host：用于指定数据的主机名部分，如上例的 www.baidu.com 部分。 android:port：用于指定数据的端口部分，一般紧随主机名之后。 android:path：用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。 android:mimeType：用于指定可以处理的数据类型，允许使用通配符方式进行指定。 Activity 间数据传递 向下一个活动传递数据 1234567//MainActivityIntent intent = new Intent(MainActivity.this, SecondActivity.class);intent.putExtra("data", "data");startActivity(intent);//SecondActivityIntent intent = getIntent();Toast.makeText(this, intent.getStringExtra("data"), Toast.LENGTH_LONG).show(); MainActivity 中通过 Intent 的 putExtra() 方法将数据暂存在 Intent 中，然后在 SecondActivity 中通过getIntent() 获取到启动 SecondActivity 的 Intent，之后通过 getStringExtra() 方法获取到传递的数据。如果传递的是整型数据则使用 getIntExtra() 方法。 返回数据给上一个活动 123456789101112131415161718192021222324252627282930//MainActivitybtn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivityForResult(intent, 1); &#125;&#125;);@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case 1: if (resultCode == RESULT_OK) &#123; Log.i("onActivityResult", data.getStringExtra("data")); &#125; break; default: &#125;&#125;//SecondActivitybtn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.putExtra("data", "data"); setResult(RESULT_OK, intent); finish(); &#125;&#125;); startActivityForResult(Intent intent, int requestCode)：期望在活动销毁的时候能够返回一个结果给上一个活动。 setResult(int resultCode, Intent data)：专门用于向上一个活动返回数据，第一个参数用于向上一个活动返回处理结果，一般只使用 RESULT_OK 和 RESULT_CANCELED。第二个参数则是把带有数据的 Intent 传递回去，然后调用 finish() 方法来销毁当前活动。 onActivityResult(int requestCode, int resultCode, Intent data)：第一个参数是我们启动活动传入的请求码，第二个参数是返回数据传入的返回结果，第三个参数是返回的携带数据的 Intent，由于一个活动可能调用 startActivityForResult() 启动多个活动，所以首先需要检查 requestCode 来判断数据来源，然后在通过 resultCode 来判断处理结果是否成功。 Activity 的生命周期 onCreate()：活动第一次被创建的时候调用，一般在该方法中完成活动的初始化操作，比如加载布局、绑定事件等。 onStart()：在活动由不可见变为可见的时候调用。 onResume()：在活动准备好和用户进行交互的时候调用。此时活动一定位于栈顶，并且处于运行状态。 onPause()：在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。 onStop()：在活动完全不可见的时候调用。如果启动的新活动是一个对话框式的活动，则 onPause() 会执行，而 onStop() 不会执行。 onDestroy()：在活动被销毁之前调用。 onRestart()：在活动由停止状态变为活动状态之前调用。 &gt; 以上七种方法中除了 onRestart( ) 方法，其他都是两两相对的，从而可以分为三种生存期：onCreate( ) 和 onDestory( ) 为完整生存期、onStart( ) 和 onStop( ) 为可见生存期、onResume( ) 和 onPause( ) 为前台生存期。 &gt; Activity 最多可能有四种状态，分别为：运行状态、暂停状态、停止状态、销毁状态。系统一般倾向于回收处于后两种状态的 Activity。 Activity 的数据保存 由于 Activity 处于停止状态的时候可能被系统回收，那么当用户返回被回收的 Activity 之时会面对一个空数据的 Activity。为了避免这种情况的发生，我们可以利用 onSaveInstanceState() 进行数据的保存工作： 123456789101112131415 //保存 @Override protected void onSaveInstanceState(Bundle outState) &#123; outState.putString("data", "outState"); Log.i(TAG, "onSaveInstanceState: "); super.onSaveInstanceState(outState); &#125; //恢复 protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_first); if (savedInstanceState != null) &#123; Log.i(TAG, "onCreate: " + savedInstanceState.getString("data")); &#125;&#125; 主动销毁 Acitivity 不会触发 onSaveInstanceState()，Bundle 也可以和 Intent 结合起来传递数据。 Activity 启动模式 Activity 有下列四种启动模式： 启动模式 作用 standard 每次启动活动都会创建一个活动的实例 singleTop 在启动活动的时候如果发现返回栈的栈顶已经是该活动，则会直接使用它，不会再创建新的活动实例 singleTask 在启动活动的时候如果发现返回栈中已经存在该活动，则直接使用它，并把该活动之上的所有活动统统出栈 singleInstance 在启动活动的时候，启动一个单独的返回栈来管理该活动 singleInstance 的意义：假设程序中有一个活动允许其他程序调用，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，就需要使用 singleInstance 模式，因为在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用同一个返回栈。 Intent 的 Flags 属性 Flags 的作用有很多，有的 Flags 为可以设定 Activity 的启动模式，还有的 Flags 可以影响 Activity 的运行状态，比如 FLAG_ACTIVITY_SINGLE_TOP 和 FLAG_ACTIVITY_CLEAR_TOP。 常用的 Flags 如下： Flags 作用 FLAG_ACTIVITY_NEW_TASK When using this flag, if a task is already running for the activity you are now starting, then a new activity will not be started; instead, the current task will simply be brought to the front of the screen with the state it was last in. FLAG_ACTIVITY_CLEAR_TOP 设置该标志之后的 Activity，当启动 Activity 时，如果该 Activity 已经存在任务栈中，则不在创建新的实例，并且位于该 Activity 之上的 Activity都需要出栈一般配合 FLAG_ACTIVITY_NEW_TASK 进行使用 FLAG_ACTIVITY_SINGLE_TOP 设置 Activity 的启动模式为 singleTop FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 具有该标志的 Activity 不会出现在历史 Activity 的列表中 FLAG_ACTIVITY_LAUNCH_ADJACENT 此标志仅用于分屏多窗口模式，新的活动将显示在上一个 Activity 的附近需要与 FLAG_ACTIVITY_NEW_TASK 结合使用。 另外，如果要创建现有活动的新实例，则应同时设置 FLAG_ACTIVITY_MULTIPLE_TASK FLAG_ACTIVITY_NEW_DOCUMENT 该标志用于在一个以目标 Activity 为栈顶的新任务栈中打开文档 FLAG_ACTIVITY_NEW_TASK：设置此状态，记住以下原则，首先会查找是否存在和被启动的 Activity 具有相同的亲和性的任务栈（即 taskAffinity，注意同一个应用程序中的 activity 的亲和性在没有修改的情况下是一样的），如果有，则直接把这个栈整体移动到前台，并保持栈中的状态不变，即栈中的 activity 顺序不变，如果没有，则新建一个栈来存放被启动的 activity。 FLAG_ACTIVITY_LAUNCH_ADJACENT：测试发现在分屏模式下在启动目标 Activity 时，如果没有设置 FLAG_ACTIVITY_MULTIPLE_TASK ，那么当目标 Activity 已经存在于任务栈中，将不会进入分屏模式。 FLAG_ACTIVITY_NEW_DOCUMENT： 当单独使用时，它相当于指定 documentLaunchMode =“intoExisting”。当与 FLAG_ACTIVITY_MULTIPLE_TASK 一起使用时，它等同于指定 documentLaunchMode =“always”。 序列化 目的 Intent 的 putExtra() 方法中所支持的数据类型是有限的，当需要传递一些自定义对象的时候，就需要用到序列化了。 方法 使用 Intent 来传递对象通常有两种实现方式： Parcelable 123456789101112131415161718192021222324252627282930public class Person implements Parcelable &#123; ... @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); dest.writeInt(age); &#125; public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel source) &#123; Person person = new Person(); person.name = source.readString(); person.age = source.readInt(); return person; &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;;&#125; Person 类实现了 Parcelable 接口用于序列化，提供了一个名为 CREATOR 的常量用于反序列化。createFromParcel() 和 writeToParcel() 的顺序需要一致。采用 Parcelable 方式进行序列化，获取对象的方法变为 getParcelableExtra()。 Serializable 12345678910111213141516171819202122232425262728293031public class Person implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;//MainActivity 中Person person = new Person();person.setAge(13);person.setName("data");Intent intent = new Intent(MainActivity.this, SecondActivity.class);intent.putExtra("data_person", person);startActivity(intent);//SecondActivity 中Person person = (Person) getIntent().getParcelableExtra("data_person");Log.i("SecondActivity", "onCreate: " + person.getName()); 首先创建了一个 Person 类去实现 Serializable 接口，这样所有的 Person 对象就都是可序列化的了，然后在 MainActivity 中创建了一个 Person 对象，然后将对象传入 SecondActivity 中去，在 SecondActivity 中用 getParcelableExtra() 来获取对象。 实用技巧 知晓当前是在哪一个活动 12345678public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d("onCreate: ", getClass().getSimpleName()); &#125;&#125; 创建一个 BaseActivity，然后让其他 Activity 继承 BaseAcitivty，那么当启动活动时就会 logcat 中打印出相应的信息。 随时随地退出程序 1234567891011121314151617181920public class ActivityCollector &#123; private static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;(); public static void addActivity(Activity activity) &#123; activities.add(activity); &#125; public static void removeActivity(Activity activity) &#123; activities.remove(activity); &#125; public static void finishAll() &#123; for (Activity activity : activities) &#123; if (!activity.isFinishing()) &#123; activity.finish(); &#125; &#125; &#125;&#125; 创建一个活动的管理类，在活动的 onCreate() 中调用 addActivity() 方法保存创建的活动，在 onDestroy() 中调用 removeActivity() 方法移除马上要销毁的活动。如果需要随时随地退出程序则只需要调用 finishAll()。 启动活动的最佳写法 123456public static void actionStart(Context context, String param1, String param2) &#123; Intent intent = new Intent(context, SecondActivity.class); intent.putExtra("param1", param1); intent.putExtra("param2", param2); context.startActivity(intent);&#125; 当活动中需要用到一些参数之时，可以采用如上方式去启动活动。那么当其他人来启动活动的时候将会非常方便。]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下 json 模块]]></title>
    <url>%2F2017%2F04%2F20%2FPython%E4%B8%8BJson%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Python 下的 json 模块主要有 4 个函数： 12345678#dict 转成 str json.dump()#将 json 数据保存到文件json.dumps()#str 转成 dict json.load()#从文件中读取 json 数据json.loads() 将 Json 数据写入文件： 1234567try: data_result_file = "data_result.json" with open(data_result_file, 'w') as f: data_json = json.loads(results.data) json.dump(data_json, f, indent=4)except IOError: print("文件不存在") 由于 json.dump() 产生的是 str 对象，不是 bytes 对象，所以写入时文件权限不能设置为 wb，否则会出现 TypeError: a bytes-like object is required, not ‘str'。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap-FileInput 的基本使用]]></title>
    <url>%2F2017%2F04%2F20%2Fbootstrap-fileinput%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装与引入 在引入 File Input 之前首先需要下载下列文件： 123bootstrap-fileinput/css/fileinput.min.cssbootstrap-fileinput/js/fileinput_locale_zh.jsbootstrap-fileinput/js/fileinput.min.js 上述文件可以在 File Input 的项目地址找到。 在下载好之后就需要添加如下代码进行引入： 123&lt;link href="/static/css/fileinput.min.css" rel="stylesheet"&gt;&lt;script src="/static/js/fileinput.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="/static/js/fileinput-zh.js" type="text/javascript"&gt;&lt;/script&gt; File Input 的使用 首先需要在页面添加一个 File Input 控件： 1234&lt;div class="form-group"&gt; &lt;input id="import_file" type="file" multiple class="file" name="userfile" data-overwrite-initial="false" data-min-file-count="1"&gt;&lt;/div&gt; data-min-file-count 可以设定最少上传的文件数 在添加完之后就需要对控件进行初始化： 12345678910111213141516171819202122$("#import_file").fileinput(&#123; uploadUrl: "/upload_file", //设置上传的地址 allowedFileExtensions: ['xls', 'xlsx'], //设置允许上传的文件格式 overwriteInitial: false, language: 'zh', //设置语言 maxFileSize: 6000, maxFilesNum: 10, //允许上传的最大文件数 uploadAsync: true, //默认异步上传 //allowedFileTypes: ['image', 'video', 'flash'], allowedPreviewTypes: null, previewFileIconSettings: &#123; 'xls': '&lt;i class="fa fa-file-excel-o text-success"&gt;&lt;/i&gt;' &#125;, //预览文件的图标设置 previewFileExtSettings: &#123; 'xls': function (ext) &#123; return ext.match(/(xls|xlsx)$/i); &#125; &#125;, //xls 和 xlsx 使用同一预览 slugCallback: function (filename) &#123; return filename.replace('(', '_').replace(']', '_'); &#125; //使用回调功能将文件名转换成处理之后的文件名。&#125;); 后台处理： 12345678910@app.route('/upload_file', methods=['POST'])def upload_file(): try: file = request.files.get('userfile') save_file_name = file.filename file.save(save_file_name) except KeyError: return [] else: return jsonify(&#123;'info': "上传成功"&#125;) 这里对上传的 Excel 文件进行了保存，返回上传成功的信息。 问题 在对 Excel 文件进行预览图标设置之前，如果通过按钮选择文件而不是拖拽，则会出现由预览文件所导致卡顿，在将 Excel 文件的预览设置为图标之后解决。 从后端直接返回字符串出现错误，改为返回 Json 格式数据后解决。 参考资料 File Input 开发文档 File Input Demo]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义 View 和 ViewGroup 简要总结]]></title>
    <url>%2F2017%2F04%2F17%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%92%8CViewGroup%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[主要方法及作用 自定义 ViewGroup 主要涉及的方法如下： onMeasure() 计算 childView 的测量值以及模式，以及设置自己的宽和高。 onLayout() 对所有 childView 进行定位。 自定义 View 主要涉及的方法如下： onMeasure() 测量 View 的宽和高。 onDraw() 将 View 绘制到屏幕上。 测量模式 onMeasure() 过程和测量模式相关，而测量模式分为三种： UNSPECIFIED：父容器不对 View 有任何限制，要多大给多大。这种情况一般用于系统内部。 EXACTLY：父容器已经检测出 View 所需要的精确大小，这个时候 View 的最终大小就是 SpecSize 所指定的值。它对应 LayoutParams 中的 mactch_parent 和具体数值这两种模式。 AT_MOST 父容器指定了一个可用大小即 SpecSize，View 的大小不能大于这个值，具体值看不同 View 的具体实现。它对应于 LayoutParams 中的 wrap_content。 LayoutParams 和 generateLayoutParams LayoutParams的官方文档解释如下： 1.LayoutParams are used by views to tell their parents how they want to be laid out. -- LayoutParams 是 View 用来告诉它的父控件如何放置自己的。 2.The base LayoutParams class just describes how big the view wants to be for both width and height. -- 基类 LayoutParams（也就是 ViewGroup.LayoutParams）仅仅描述了这个 View 想要的宽度和高度。 3.There are subclasses of LayoutParams for different subclasses of ViewGroup. -- 不同 ViewGroup 的继承类对应着不同的 ViewGroup.LayoutParams 的子类。 generateLayoutParams官方文档解释如下： Returns a new set of layout parameters based on the supplied attributes set. -- 根据提供的属性集返回一组新的布局参数。 在 addView() 的执行过程当中，如果 checkLayoutParams() 检测到传递过来的 LayoutParams 不是对应布局的 LayoutParam，则会通过 generateLayoutParams() 根据你传递的 LayoutParams 的属性构造一个对应布局的 LayoutParams。 参考资料 Android 手把手教您自定义ViewGroup（一） 自定义控件知识储备-LayoutParams的那些事]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中 View 的构造函数浅解]]></title>
    <url>%2F2017%2F04%2F17%2FAndroid%E4%B8%ADView%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B5%85%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[构造函数的调用时机 在自定义 View 的过程当中，不可避免的需要接触到 View 的构造函数，目前 View 具有四个构造函数，分别如下： 12345678910111213141516public View(Context context) &#123; /...../&#125; public View(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0);&#125; public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0);&#125; public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; this(context); /...../&#125; defStyleAttr 当前主题中的一个属性，其中包含对为视图提供默认值的样式资源的引用。 可以为0，不寻找默认值。 defStyleRes 为视图提供默认值的样式资源的资源标识符，仅在 defStyleAttr 为0或在主题中找不到时使用。可以为0，不寻找默认值。 第一个构造函数源码的解释如下： &gt; Simple constructor to use when creating a view from code. 也就是说当在代码中创建 View 的时候会调用第一个构造函数。 第二个构造函数的源码解释如下： &gt; Constructor that is called when inflating a view from XML. This is called when a view is being constructed from an XML file, supplying attributes that were specified in the XML file. This version uses a default style of 0, so the only attribute values applied are those in the Context's Theme and the given AttributeSet. 也就是说当在 XML 文件中插入 View 的时候会调用第二个构造函数，并且会应用 Context 的主题以及在 XML 中给定的属性值。 第三个和第四个构造函数的源码解释分别如下： &gt; Perform inflation from XML and apply a class-specific base style from a theme attribute. &gt; &gt;This constructor of View allows subclasses to use their own base style when they are inflating. For example, a Button class's constructor would call this version of the super class constructor and supply R.attr.buttonStyle for defStyleAttr; this (in particular its background) as well as the Button class's attributes. Perform inflation from XML and apply a class-specific base style from a theme attribute or style resource. &gt; This constructor of View allows subclasses to use their own base style when they are inflating. 也就是说两个构造函数共同的作用是允许 View 应用自己的基础 style，那么当我们需要为 View 设置 style 的时候就可以选择去调用这两个构造函数当中的一个，调用方式一般如下： 1234567public Button(Context context, AttributeSet attrs) &#123; this(context, attrs, com.android.internal.R.attr.buttonStyle);&#125;public Button(Context context, AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0);&#125; defStyleAttr 和 defStyleRes 的联系 接下来的问题是这两者的区别在哪里？由于这两者都用于设置 style，而 style 里面是属性的集合，所以这里需要先了解 View 设置属性的方式，一般来说有如下五种方式： 1. XML 中直接声明相关属性值 2. XML 中 引入 style 3. defStyleAttr 4. defStyleRes 5. theme中直接指定 既然有五种方式，那么当同时应用的时候就涉及到了优先级的问题。为了了解优先级的问题，首先我们需要在 attrs.xml 文件中写入如下代码： 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="DefAttrs"&gt; &lt;attr name="attr_1" format="string" /&gt; &lt;attr name="attr_2" format="string" /&gt; &lt;attr name="attr_3" format="string" /&gt; &lt;attr name="attr_4" format="string" /&gt; &lt;/declare-styleable&gt; &lt;attr name="defStyleAttr" format="reference" /&gt;&lt;/resources&gt; 这里定义了四个格式为 string 的属性用于测试，定义了一个名为 defStyleAttr 引用。 通过 declare-styleable 可以为每个属性在 R 文件里自动生成一个 int[]，这样就可以很方便的用 R.styleable.* 来进行使用，当然定义的属性也可以不放在 declare-styleable 中，但是使用的时候就需要通过如下代码： 12int[] attrs = &#123;R.attr.attr_1,R.attr_2&#125;;TypedArray typedArray = context.obtainStyledAttributes(set,attrs); 在创建了自定义的属性之后，还需要创建一些 style，在 style.xml 文件中写入如下代码： 123456789101112131415161718192021222324252627282930313233343536373839&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;!--Theme 直接指定--&gt; &lt;item name="attr_1"&gt;theme_one&lt;/item&gt; &lt;item name="attr_2"&gt;theme_two&lt;/item&gt; &lt;item name="attr_3"&gt;theme_three&lt;/item&gt; &lt;item name="attr_4"&gt;theme_four&lt;/item&gt; &lt;!--defStyleAttr--&gt; &lt;item name="defStyleAttr"&gt;@style/def_style_attr&lt;/item&gt; &lt;/style&gt; &lt;!--xml 中引入的 style --&gt; &lt;style name="xml_style"&gt; &lt;item name="attr_1"&gt;xml_style_one&lt;/item&gt; &lt;item name="attr_2"&gt;xml_style_two&lt;/item&gt; &lt;/style&gt; &lt;!--defStyleAttr 引用的 style--&gt; &lt;style name="def_style_attr"&gt; &lt;item name="attr_1"&gt;def_style_one&lt;/item&gt; &lt;item name="attr_2"&gt;def_style_two&lt;/item&gt; &lt;item name="attr_3"&gt;def_style_three&lt;/item&gt; &lt;/style&gt; &lt;!--defStyleRes--&gt; &lt;style name="def_style_res"&gt; &lt;item name="attr_1"&gt;def_style_res_one&lt;/item&gt; &lt;item name="attr_2"&gt;def_style_res_two&lt;/item&gt; &lt;item name="attr_3"&gt;def_style_res_three&lt;/item&gt; &lt;item name="attr_4"&gt;def_style_res_four&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 上述代码添加了四种 style，对应为 View 设置属性的方式中的后四种，在添加了 style 之后，我们还需要应用 style，所以需要先创建一个如下的自定义 View： 123456789101112131415161718192021222324252627282930313233343536373839public class MyView extends TextView&#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, R.attr.defStyleAttr); &#125; public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr,R.attr.defStyleAttr); parse(context, attrs, defStyleAttr); &#125; @TargetApi(VERSION_CODES.LOLLIPOP) public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); &#125; private void parse(Context context, AttributeSet attrs, int defStyleAttr) &#123; TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.DefAttrs, defStyleAttr, R.style.def_style_res); String one = typedArray.getString(R.styleable.DefAttrs_attr_1); String two = typedArray.getString(R.styleable.DefAttrs_attr_2); String three = typedArray.getString(R.styleable.DefAttrs_attr_3); String four = typedArray.getString(R.styleable.DefAttrs_attr_4); log("one = " + one); log("two = " + two); log("three = " + three); log("four = " + four); typedArray.recycle(); &#125; private void log(String msg) &#123; Log.i("MyView", msg); &#125;&#125; 第二个构造函数中显式调用了第三个构造函数，并设置 defStyleAttr 参数值为 R.attr.defStyleAttr。 parse() 获取四个属性值并进行打印。 创建完自定义 View 之后，现在需要在 XML 文件中添加自定义的View： 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:test="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.rookieyang.test.MainActivity"&gt; &lt;com.rookieyang.test.MyView test:attr_1="xml_attr_attr1" style="@style/xml_style" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; test:attr_1=&quot;xml_attr_attr1&quot; XML 中直接指定 attr_1 属性值。 style=&quot;@style/xml_style&quot; XML 中引入 style。 运行结果 在完成上述步骤之后就可以运行，运行之后的输出如下： 上述代码中，XML 中直接声明 attr_1 属性值为 xml_attr_attr1，XML 中 引入的 style 中给 attr_1，attr_2 赋值为 xml_style_one，xml_style_two，defStyleAttr 给 attr_1，attr_2，attr_3 赋值为 def_style_one，def_style_two，def_style_three，defStyleRes 和 Theme 也分别为四个属性进行了赋值，而根据输出的结果在优先级上我们很容易得到以下结论： &gt; XML 中直接声明相关属性值 &gt; XML 中 引入 style &gt; defStyleAttr &gt; theme中直接指定 &gt; &gt; defStyleAttr &gt; defStyleRes 从第一部分可以知道由于 defStyleAttr 的存在，defStyleRes 没有生效，所以 defStyleRes 和 theme中直接指定的优先级还不能进行判断，这个时候需要将 style.xml 文件中的下列代码进行注释： 1&lt;item name="defStyleAttr"&gt;@style/def_style_attr&lt;/item&gt; 或者将自定义 View 中调用第三个构造函数的代码做如下修改： 12//将第三个参数更改为 0this(context, attrs, defStyleAttr,0); 修改之后运行能得到如下输出： 可以看到当 defStyleAttr 不存在后 defStyleRes 开始生效，并且优先级要高于theme中直接指定。 所以最终结论如下： &gt; XML 中直接声明相关属性值 &gt; XML 中 引入 style &gt; defStyleAttr &gt; defStyleRes &gt; theme中直接指定 &gt; 仅在 defStyleAttr 为0或在主题中找不到时，defStyleRes 生效。 参考资料 深度解析View构造函数中的参数defStyleAttr Android View 四个构造函数详解 深入理解Android 自定义attr Style styleable以及其应用]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getWidth() 方法和 getMeasureWidth() 方法的区别]]></title>
    <url>%2F2017%2F04%2F16%2FgetWidth()%E6%96%B9%E6%B3%95%E5%92%8CgetMeasureWidth()%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[首先 getMeasureWidth() 方法在 measure() 过程结束后就可以获取到了，而 getWidth() 方法要在 layout() 过程结束后才能获取到。另外 getMeasureWidth() 方法中的值是通过 setMeasuredDimension() 方法来进行设置的，而 getWidth() 方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。 观察 SimpleLayout 中 onLayout() 方法的代码，这里给子视图的 layout() 方法传入的四个参数分别是 0，0，childView.getMeasuredWidth() 和 childView.getMeasuredHeight() ，因此 getWidth() 方法得到的值就是 childView.getMeasuredWidth() - 0 = childView.getMeasuredWidth()，所以此时 getWidth() 方法和 getMeasuredWidth() 得到的值就是相同的。 1234567@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (getChildCount() &gt; 0) &#123; View childView = getChildAt(0); childView.layout(0, 0, childView.getMeasuredWidth(), childView.getMeasuredHeight()); &#125; &#125; 但如果你将 onLayout() 方法中的代码进行如下修改： 1234567@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (getChildCount() &gt; 0) &#123; View childView = getChildAt(0); childView.layout(0, 0, 200, 200); &#125; &#125; 这样 getWidth() 方法得到的值就是 200 - 0 = 200，不会再和 getMeasuredWidth() 的值相同了。当然这种做法充分不尊重 measure() 过程计算出的结果，通常情况下是不推荐这么写的。 getHeight() 与 getMeasureHeight() 方法之间的关系同上，就不再重复分析了。 参考资料 Android视图绘制流程完全解析，带你一步步深入了解View(二)]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[d3.js 绘制柱形图]]></title>
    <url>%2F2017%2F04%2F14%2Fd3-js%E7%BB%98%E5%88%B6%E6%9F%B1%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[在d3.js 绘制力导向图中已经说明了如何绘制力导向图以及数据更新。本次将说明如何绘制带坐标轴的柱形图。 确定初始数据 初始数据如下： 12345678910111213141516171819202122232425262728293031323334var nodes = [&#123;'label': 'Sort', 'title': 'lslamic'&#125;, &#123; 'label': 'GOODS', 'title': 'VINTAGE OLD HAND MADE BEAUTY SILVER BROOCH PIN RED ENAMEL LEAF SIAM STERLING' &#125;, &#123;'label': 'Website', 'title': 'ebay'&#125;, &#123;'label': 'Sort', 'title': 'Antiques'&#125;, &#123; 'label': 'Sort', 'title': 'Baby' &#125;, &#123;'label': 'Sort', 'title': 'Books'&#125;, &#123;'label': 'Sort', 'title': 'Business &amp; Industrial'&#125;, &#123; 'label': 'Sort', 'title': 'Cameras &amp; Photo' &#125;, &#123;'label': 'Sort', 'title': 'Cell Phones &amp; Accessories'&#125;, &#123; 'label': 'Sort', 'title': 'Clothing, Shoes &amp; Accessories' &#125;, &#123;'label': 'Sort', 'title': 'Coins &amp; Paper Money'&#125;, &#123;'label': 'Sort', 'title': 'Collectibles'&#125;, &#123; 'label': 'Sort', 'title': 'Computers Tablets &amp; Networking' &#125;, &#123;'label': 'Sort', 'title': 'Consumer Electronics'&#125;, &#123;'label': 'Sort', 'title': 'Crafts'&#125;, &#123; 'label': 'Sort', 'title': 'eBay Motors' &#125;, &#123;'label': 'Sort', 'title': 'Everything Else'&#125;, &#123;'label': 'Sort', 'title': 'Health &amp; Beauty'&#125;, &#123; 'label': 'Sort', 'title': 'Home &amp; Garden' &#125;, &#123;'label': 'Sort', 'title': 'Jewelry &amp; Watches'&#125;, &#123; 'label': 'Sort', 'title': 'Musical Instruments &amp; Gear' &#125;, &#123;'label': 'Sort', 'title': 'Sporting Goods'&#125;, &#123;'label': 'Sort', 'title': 'Antiquities'&#125;, &#123; 'label': 'Sort', 'title': 'Architectural &amp; Garden' &#125;, &#123;'label': 'Sort', 'title': 'Asian Antiques'&#125;, &#123;'label': 'Sort', 'title': 'Decorative Arts'&#125;, &#123; 'label': 'Sort', 'title': 'Linens &amp; Textiles (Pre-1930)' &#125;, &#123;'label': 'Sort', 'title': 'Maritime'&#125;, &#123;'label': 'Sort', 'title': 'Periods &amp; Styles'&#125;, &#123; 'label': 'Sort', 'title': 'Primitives' &#125;, &#123;'label': 'Sort', 'title': 'Science &amp; Medicine (Pre-1930)'&#125;, &#123;'label': 'Sort', 'title': 'Silver'&#125;]; 初始数据中每个数据具有不同的类别，本次的目的是统计不同类别的数据出现次数并进行绘制，数据处理代码如下： 123456789101112131415var dataset = &#123;&#125;;for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; dataset[node['label']] = 0; for (var j = 0; j &lt; nodes.length; j++) &#123; if (nodes[j]['label'] == node['label']) dataset[node['label']] += 1; &#125;&#125;var data = [];var labels = [];for (var key in dataset) &#123; data.push(dataset[key]); labels.push(key);&#125; dataset 用于将数据进行分类统计。 data 保存每个分类出现次数。 labels 保存分类名称，作为 x 轴的刻度。 创建 SVG 1234var width = 420, height = 420;var svg = d3.select("#graph").append("svg") .attr("width", width) .attr("height", height); 绘制坐标轴 123456789101112131415161718192021222324252627282930313233var padding = &#123;top: 20, right: 20, bottom: 20, left: 30&#125;;var xAxisWidth = width - 2 * padding.left;var yAxiWidth = height - 2 * padding.bottom;var xAxisScale = d3.scale.ordinal() .domain(d3.range(labels.length)) .rangeRoundBands([0, xAxisWidth]);var yAxisScale = d3.scale.linear() .domain([0, d3.max(data)]) .range([yAxiWidth, 0]);var xAxis = d3.svg.axis() .scale(xAxisScale) .orient("bottom") .tickFormat(function (d) &#123; return labels[d]; &#125;);var yAxis = d3.svg.axis() .scale(yAxisScale) .orient("left");svg.append("g") .attr("class", "axis") .attr("transform", "translate(" + padding.left + "," + (height - padding.bottom) + ")") .call(xAxis);svg.append("g") .attr("class", "axis") .attr("transform", "translate(" + padding.left + "," + (height - yAxiWidth - padding.bottom) + ")") .call(yAxis); xAxisWidth，yAxiWidth 代表 x 轴和 y 轴的长度。 padding x 轴和 y 轴的外边距。 xAxisScale，yAxisScale x 轴和 y 轴的比例尺。 ordinal().domain() 设定或获取定义域。 ordinal.rangeRoundBands(interval[, padding[, outerPadding]]) 接收一个连续的区间，然后根据定义域中离散值的数量将其分段，分段结果会取整。 tickFormat() 用于设定文字格式的刻度。 这样添加之后的坐标轴，样式会比较丑，所以还需要给坐标轴增加如下样式： 12345678910111213&lt;style&gt; .axis path, .axis line &#123; fill: none; stroke: black; shape-rendering: crispEdges; &#125; .axis text &#123; font-family: sans-serif; font-size: 11px; &#125;&lt;/style&gt; 绘制矩形 123456789101112131415161718192021222324252627//0.05 用于设置矩形之间的间隔，由于 rangeRoundBands 选取的范围远小于 xAxisWidth，所以矩形之间的间隔远大于 0.05，该参数未起作用。var xScale = d3.scale.ordinal() .domain(d3.range(labels.length)) .rangeRoundBands([0, 100], 0.05);var yScale = d3.scale.linear() .domain([0, d3.max(data)]) .range([0, yAxiWidth]);var rect = svg.selectAll("rect") .data(data);rect.enter() .append("rect") .attr("x", function (d, i) &#123; x = xAxisWidth / (2 * labels.length) * (2 * i + 1) - xScale.rangeBand() / 2 + padding.left; return x; &#125;) .attr("y", function (d, i) &#123; return height - padding.bottom - yScale(d); &#125;) .attr("width", function (d, i) &#123; return xScale.rangeBand(); &#125;) .attr("height", yScale) .attr("fill", "steelblue"); xScale 用于控制矩形宽度， yScale 用于控制矩形高度。这样做可以使得矩形的宽度和高度自由伸缩。 给矩形增加文字描述 123456789101112131415161718192021var text = svg.selectAll("text") .data(data);text.enter().append("text") .attr("x", function (d, i) &#123; x = xAxisWidth / (2 * labels.length) * (2 * i + 1) - xScale.rangeBand() / 2 + padding.left; return x; &#125;) .attr("y", function (d, i) &#123; return height - padding.bottom - yScale(d); &#125;) .attr("dx", function (d, i) &#123; return xScale.rangeBand() / 4; &#125;) .attr("dy", -2) .attr("text-anchor", "begin") .attr("font-size", 14) .attr("fill", "#000000") .text(function (d, i) &#123; return d; &#125;); text 元素的坐标是矩形的坐标，dx，dy 设定了方向上的偏移量。所以最终文字位于矩形正上方。 柱形图动画 给柱形图增加动画，需要将代码修改为： 12345678910111213141516171819202122232425262728var rect = svg.selectAll("rect") .data(data);rect.enter() .append("rect") .attr("y", function (d, i) &#123; return height - padding.bottom; &#125;) .attr("height", 0) .attr("fill", "red") .transition() .duration(3000) .ease("bounce") .delay(function (d, i) &#123; return 200 * i; &#125;) .attr("x", function (d, i) &#123; x = xAxisWidth / (2 * labels.length) * (2 * i + 1) - xScale.rangeBand() / 2 + padding.left; return x; &#125;) .attr("y", function (d, i) &#123; return height - padding.bottom - yScale(d); &#125;) .attr("width", function (d, i) &#123; return xScale.rangeBand(); &#125;) .attr("height", yScale) .attr("fill", "steelblue"); 上述代码设置了两个 fill 属性，在添加了 transition() 之后，D3 会自动对颜色之间的值进行线性插值，最终在动画中会看到平滑的颜色变化。 duration() 动画持续时间。 ease() 指定转变方式，常用的转变方式有： linear 普通的线性变化。 circle 慢慢地到达变换的最终状态。 elastic 带有弹跳的到达最终状态。 bounce 在最终状态处弹跳几次。 delay() 指定延时。 最终效果 参考资料 如何让图表动起来 d3-3.x-api-reference]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>d3.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[d3.js 绘制力导向图]]></title>
    <url>%2F2017%2F04%2F13%2Fd3-js%E7%BB%98%E5%88%B6%E5%8A%9B%E5%AF%BC%E5%90%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[简介 D3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。 使用 在 HTML 文件中引入： &lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 确定初始数据 初始数据为节点数据 nodes 和 连线数组 links，如下： 1234567891011121314151617181920212223242526272829303132333435var nodes = [&#123;'label': 'Website', 'title': 'ebay'&#125;, &#123;'label': 'Sort', 'title': 'Antiques'&#125;, &#123; 'label': 'Sort', 'title': 'Baby' &#125;, &#123;'label': 'Sort', 'title': 'Books'&#125;, &#123;'label': 'Sort', 'title': 'Business &amp; Industrial'&#125;, &#123; 'label': 'Sort', 'title': 'Cameras &amp; Photo' &#125;, &#123;'label': 'Sort', 'title': 'Cell Phones &amp; Accessories'&#125;, &#123; 'label': 'Sort', 'title': 'Clothing, Shoes &amp; Accessories' &#125;, &#123;'label': 'Sort', 'title': 'Coins &amp; Paper Money'&#125;, &#123;'label': 'Sort', 'title': 'Collectibles'&#125;, &#123; 'label': 'Sort', 'title': 'Computers Tablets &amp; Networking' &#125;, &#123;'label': 'Sort', 'title': 'Consumer Electronics'&#125;, &#123;'label': 'Sort', 'title': 'Crafts'&#125;, &#123; 'label': 'Sort', 'title': 'eBay Motors' &#125;, &#123;'label': 'Sort', 'title': 'Everything Else'&#125;, &#123;'label': 'Sort', 'title': 'Health &amp; Beauty'&#125;, &#123; 'label': 'Sort', 'title': 'Home &amp; Garden' &#125;, &#123;'label': 'Sort', 'title': 'Jewelry &amp; Watches'&#125;, &#123; 'label': 'Sort', 'title': 'Musical Instruments &amp; Gear' &#125;, &#123;'label': 'Sort', 'title': 'Sporting Goods'&#125;]; var links = [&#123;'source': 1, 'target': 0&#125;, &#123;'source': 2, 'target': 0&#125;, &#123;'source': 3, 'target': 0&#125;, &#123; 'source': 4, 'target': 0 &#125;, &#123;'source': 5, 'target': 0&#125;, &#123;'source': 6, 'target': 0&#125;, &#123;'source': 7, 'target': 0&#125;, &#123; 'source': 8, 'target': 0 &#125;, &#123;'source': 9, 'target': 0&#125;, &#123;'source': 10, 'target': 0&#125;, &#123;'source': 11, 'target': 0&#125;, &#123; 'source': 12, 'target': 0 &#125;, &#123;'source': 13, 'target': 0&#125;, &#123;'source': 14, 'target': 0&#125;, &#123;'source': 15, 'target': 0&#125;, &#123; 'source': 16, 'target': 0 &#125;, &#123;'source': 17, 'target': 0&#125;, &#123;'source': 18, 'target': 0&#125;, &#123;'source': 19, 'target': 0&#125;]; 创建布局 12var force = d3.layout.force() .charge(-300).linkDistance(130).size([width, height]); d3.layout.force() 创建一个力导向图布局。 charge() 设定节点的电荷数，负数则排斥，正数则吸引。 linkDistance() 设置连线的距离。 size([x, y]) 设置力导向图的作用范围，用于指定重力中心为（x/2，y/2），所有节点的初始位置限定为 [0,x] 和 [0,y] 之间。 创建 SVG 12var svg = d3.select("#graph").append("svg") .attr("width", "100%").attr("height", "380px"); append() 用于添加元素 设置 svg 的长宽 转换数据和绘制 设定节点数组和连线数组之后开启布局计算 1force.nodes(nodes).links(links).start(); 绘制 绑定数组 nodes 和 links，分别添加节点的元素 &lt;circle&gt; 和连线的元素&lt;line&gt;。另外，还要添加文字元素 &lt;text&gt;。各元素的 CSS 样式分别为：node，link，nodeText。代码如下： 12345678910111213141516171819202122232425262728293031323334353637var link = svg.selectAll(".link") .data(links);link.enter() .insert("line", ".link") .attr("class", "link");var node = svg.selectAll(".node") .data(nodes);node.enter() .append("circle") .attr("class", function (d) &#123; return "node " + d.label &#125;) .attr("r", 25) .call(force.drag);var text = svg.selectAll(".nodeText").data(nodes);text.enter() .append("text") .attr("class", "nodeText") .attr("x", function (d) &#123; return d.x; &#125;) .attr("font-size", "10px") .attr("text-anchor", "middle") .attr("dy", ".3em") .attr("y", function (d) &#123; return d.y; &#125;).text(function (d) &#123; var act_title; if (d.title.length &gt; 8) &#123; act_title = d.title.substring(0, 8) + "..."; return act_title; &#125; else &#123; return d.title; &#125;&#125;); 节点的选择集调用了 call(force.drag)，可以让节点支持鼠标拖拽。 连线的选择集调用了 insert(&quot;line&quot;, &quot;.link&quot;)，可以确保力导向图进行更新（移除节点后增加节点）之后连线不会覆盖在节点上。 在拖动节点之后，图形元素的坐标会发生变化，所以需要设置一个监听器进行更新，代码如下： 123456789101112131415161718192021222324force.on("tick", function () &#123; link.attr("x1", function (d) &#123; return d.source.x; &#125;) .attr("y1", function (d) &#123; return d.source.y; &#125;) .attr("x2", function (d) &#123; return d.target.x; &#125;) .attr("y2", function (d) &#123; return d.target.y; &#125;); node.attr("transform", function (d) &#123; return "translate(" + d.x + "," + d.y + ")"; &#125;); text.attr("x", function (d) &#123; return d.x; &#125;) .attr("y", function (d) &#123; return d.y; &#125;);&#125;); * `force.on()` 可为三种事件设定监听器，start，tick，end。其中，start 是刚开始运动，end 是运动停止，tick 是表示运动的每一步。 * 选择集 node，link，text 上都绑定了数据，当每一次 tick 事件发生时，被绑定的数据被更新，`function(d)` 中的 d 也都更新了。 增加样式： 123456789101112131415161718192021222324 &lt;style type="text/css"&gt; .node &#123; stroke: #222; stroke-width: 1.5px; &#125; .link &#123; stroke: #707071; stroke-opacity: .6; stroke-width: 1px; &#125; .node.Website &#123; fill: #ff756e; &#125; .node.Sort &#123; fill: #de9bf9; &#125; .nodeText &#123; fill: #ffffff &#125;&lt;/style&gt; 效果 绘制箭头和添加文字 绘制箭头需要用到 SVG 中的标记（marker）。标记 写在 中，defs 用于定义可重复利用的元素。定义箭头代码如下： 12345678910111213141516var defs = svg.append("defs");var arrowMarker = defs.append("marker") .attr("id", "arrow") .attr("markerUnits", "strokeWidth") .attr("markerWidth", "10") .attr("markerHeight", "10") .attr("viewBox", "-0 -5 10 10") .attr("refX", "35") .attr("refY", "0") .attr("orient", "auto");var arrow_path = 'M 0,-5 L 10 ,0 L 0,5 L5,0 L0,-5';arrowMarker.append("path") .attr("d", arrow_path) .attr("fill", "#a6a6a6"); refX, refY 指的是图形元素和 marker 连接的位置坐标，这里圆的半径设置为 25，箭头的顶点到底部垂直距离为 10，所以设置为（35，0）则箭头的顶端刚好在圆上。 markerUnits 标记大小的基准，有两个值，即 strokeWidth（线的宽度）和 userSpaceOnUse（线前端的大小）。 markerWidth，markerHeight 标识的大小。 orient 绘制方向，可设定为 auto（自动确认方向和角度值）。 id 标识的 id 号。 粉红色框是 viewBox 范围，黑色为 arrow_path 的轨迹： link.attr('marker-end', 'url(#arrow)');可以为连接线添加箭头。 为连接线增加文字，首先需要定义 &lt;path&gt; 确定文字放在连接线路径上，再定义 &lt;text&gt;，之后在 &lt;text&gt; 添加 &lt;textPath&gt; 引用路径，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041//定义文字路径var linkpaths = svg.selectAll(".linkpath") .data(links_data);linkpaths.enter() .append('path') .attr('d', function (d) &#123; return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y &#125;) .attr('class', 'linkpath') .attr('fill-opacity', 0) .attr('stroke-opacity', 0) .attr('fill', '#ffffff') .attr('stroke', 'red') .attr('id', function (d, i) &#123; return 'linkpath' + i; &#125;) .style("pointer-events", "none");//定义 &lt;text&gt; var linklabels = svg.selectAll(".linklabel") .data(links_data);linklabels.enter() .append('text') .style("pointer-events", "none") .attr('class', 'linklabel') .attr('id', function (d, i) &#123; return 'linklabel' + i; &#125;) .attr('dx', 50) .attr('dy', 0) .attr('font-size', 5) .attr('fill', '#aaa');//增加 &lt;textPath&gt; 引用 pathlinklabels.append('textPath') .attr('xlink:href', function (d, i) &#123; return '#linkpath' + i &#125;) .style("pointer-events", "none") .text(function (d, i) &#123; return 'BELONG'; &#125;); pointer-events 设置为 none 则不在接收鼠标事件，设置为 all 则在指针在元素中或边缘时接收鼠标事件。 上述代码只是确保了初始时文字在连接线路径上，所以还需要设置对上述元素的坐标更新。在 force.on() 中增加如下代码： 1234567891011121314151617linkpaths.attr('d', function (d) &#123; var path = 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y; return path&#125;); linklabels.attr('transform', function (d, i) &#123; if (d.target.x &lt; d.source.x) &#123; bbox = this.getBBox(); //确保文字不会倒置 rx = bbox.x + bbox.width / 2; ry = bbox.y + bbox.height / 2; return 'rotate(180 ' + rx + ' ' + ry + ')'; &#125; else &#123; return 'rotate(0)'; &#125;&#125;); 缩放和拖动 要同时支持鼠标缩放以及拖动，必须处理这两者的事件冲突，代码如下： 123456789101112131415161718192021var zoom = d3.behavior.zoom() .scaleExtent([1, 10]) .on("zoom", function zoomed() &#123; d3.select(this).attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")"); &#125;);svg.call(d3.behavior.zoom().on("zoom", redraw)) .append('g');force.drag() .on("dragstart", function (d) &#123; //在拖动节点的时候阻止事件冒泡 d3.event.sourceEvent.stopPropagation(); &#125;);// 缩放之后重绘function redraw() &#123; svg.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")");&#125;function dragstart(d) &#123; d3.select(this).classed("fixed", d.fixed = true);&#125; g 元素 是用来分组用的，它能把多个元素放在一组里，对 标记实施的样式和渲染会作用到这个分组内的所有元素上。组内的所有元素都会继承 标记上的所有属性。 fixed 设置为 true 时，顶点固定不动。 更新数据 有时候需要更新数据，更新后力导向图也会跟着变化。由于上述的选择集通过 data() 将数据与元素进行绑定，而绑定的情况分为以下三种： * update：数组长度 = 元素数量 * enter：数组长度 &gt; 元素数量 * exit：数组长度 &lt; 元素数量 所以在更新数据的时候需要分别对这三种情况进行处理，对于 enter 这种没有足够的元素的处理办法是添加元素，对于 exit 这种存在多余元素的处理办法是删除元素，而对于 update 则是进行内容修改。 以节点的更新数据为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344var node = svg.selectAll(".node") .data(nodes_data);//节点数据内容修改node.attr("class", function (d) &#123; return "node " + d.label&#125;) .on("dblclick", dblclick) .attr("r", 25) .call(force.drag) .on("click", function (d) &#123; keys = d3.keys(d); delete_key = ["x", "y", "index", "weight", "px", "py", "fixed"]; info = []; for (var i = 0; i &lt; delete_key.length; i++) &#123; keys.removeByValue(delete_key[i]); &#125; for (var j = 0; j &lt; keys.length; j++) &#123; info.push(d[keys[j]]) &#125; showinfo(d.label, keys, info); &#125;);//增加不足的元素node.enter() .append("circle") .attr("class", function (d) &#123; return "node " + d.label &#125;) .on("dblclick", dblclick) .attr("r", 25) .call(force.drag) .on("click", function (d) &#123; keys = d3.keys(d); delete_key = ["x", "y", "index", "weight", "px", "py", "fixed"]; info = []; for (var i = 0; i &lt; delete_key.length; i++) &#123; keys.removeByValue(delete_key[i]); &#125; for (var j = 0; j &lt; keys.length; j++) &#123; info.push(d[keys[j]]) &#125; showinfo(d.label, keys, info); &#125;);//删除多余元素node.exit().remove(); 参考资料 理解 update, enter, exit 的使用]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>d3.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下 Flask 结合 Neo4j 构建管理系统（四）]]></title>
    <url>%2F2017%2F04%2F13%2FPython%E4%B8%8BFlask%E7%BB%93%E5%90%88Neo4j%E6%9E%84%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据的增删改功能引入了 bootstrap table 插件进行操作。 #### bootstrap table 使用 引入 Bootstrap 库（假如你的项目还没有使用）和 bootstrap-table.css 到 head 标签下。 12&lt;link rel="stylesheet" href="bootstrap.min.css"&gt;&lt;link rel="stylesheet" href="bootstrap-table.css"&gt; 引入 jQuery 库，bootstrap 库（假如你的项目还没有使用）和 bootstrap-table.js 到 head 标签下或者在 body 标签关闭之前（一般建议这么做）。 12345&lt;script src="jquery.min.js"&gt;&lt;/script&gt;&lt;script src="bootstrap.min.js"&gt;&lt;/script&gt;&lt;script src="bootstrap-table.js"&gt;&lt;/script&gt;&lt;-- put your locale files after bootstrap-table.js --&gt;&lt;script src="bootstrap-table-zh-CN.js"&gt;&lt;/script&gt; 表格初始化 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var TableInit = function () &#123; var oTableInit = new Object(); //初始化Table oTableInit.Init = function () &#123; $('#ta_info').bootstrapTable(&#123; url: $SCRIPT_ROOT + "/search_table", //请求后台的URL（*） method: 'get', //请求方式（*） toolbar: '#toolbar', //工具按钮用哪个容器 striped: true, //是否显示行间隔色 cache: false, //是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*） pagination: true, //是否显示分页（*） sortable: false, //是否启用排序 sortOrder: "asc", //排序方式 queryParams: oTableInit.queryParams,//传递参数（*） sidePagination: "server", //分页方式：client客户端分页，server服务端分页（*） pageNumber: 1, //初始化加载第一页，默认第一页 pageSize: 10, //每页的记录行数（*） pageList: [10, 25, 50, 100], //可供选择的每页的行数（*） search: false, //是否显示表格搜索，此搜索是客户端搜索，不会进服务端，所以，个人感觉意义不大 strictSearch: false, showColumns: true, //是否显示所有的列 showRefresh: true, //是否显示刷新按钮 minimumCountColumns: 2, //最少允许的列数 clickToSelect: true, //是否启用点击选中行 height: 500, //行高，如果没有设置height属性，表格自动根据记录条数觉得表格高度 uniqueId: "ID", //每一行的唯一标识，一般为主键列 showToggle: true, //是否显示详细视图和列表视图的切换按钮 cardView: false, //是否显示详细视图 detailView: false, //是否显示父子表 columns: [&#123; checkbox: true &#125;, &#123; field: 'name', title: '信息名' &#125;, &#123; field: 'label', title: '类别' &#125;] &#125;); &#125;; //得到查询的参数 oTableInit.queryParams = function (params) &#123; var temp = &#123; //这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的 limit: params.limit, //页面大小 offset: params.offset, //页码 q: $("#search_table").find("input[name=condition]").val() &#125;; return temp; &#125;; return oTableInit;&#125;; 服务器分页 后端代码： 123456789101112@app.route('/search_table')def search_table(): try: q = request.args.get('q', 0) limit = request.args.get('limit', 1) offset = request.args.get('offset', 2) except KeyError: return [] else: user = User(session.get("username")) results = user.search_table(q, limit, offset) return results 1234567891011121314151617def search_table(self, condition, limit, offset): nodes = [] act_nodes = [] query = "MATCH (m) WHERE m.name CONTAINS \'" + condition + \ "\' and (labels(m)='Sort' or labels(m)='GOODS' or labels(m)='Website') RETURN m, labels(m)" results = graph.run(query) for result, label in results: node = &#123;&#125; node["name"] = result.get("name") node["label"] = label[0] nodes.append(node) total = len(nodes) for i in range(int(offset), int(offset) + int(limit)): if i &gt;= len(nodes): break act_nodes.append(nodes[i]) return jsonify(&#123;'total': total, 'rows': act_nodes&#125;) 服务器分页必须返回 total 和 rows 两个参数，前者代表查询数据的总长度，后者返回该页应该显示的数据。 增删改 以增加数据为例： 由于 Neo4j 中的数据不是结构性数据，所以增加数据的基本思路是由用户选择父节点，然后向父节点增加子节点，增加子节点的过程中必须填入子节点的 名字，类别以及和父节点的关系属性，如果子节点还有其它属性，则可以点击增加行进行额外属性的增加。 前端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$('#btn_add').click(function () &#123; var father_node = $("#ta_info").bootstrapTable('getSelections'); if (father_node == "") &#123; alert("请选择插入元素的父节点") &#125; else if (father_node.length &gt; 1) &#123; alert("父节点只允许一个") &#125; else &#123; if ($('.added-row').length &gt; 0) $('.added-row').remove(); $('#insertModal_body').find("input[name=name]").val(""); $('#insertModal_body').find("input[name=label]").val(""); $('#insertModal_body').find("input[name=relation]").val(""); $('#insertModal').modal() &#125; return false&#125;);$('#add_row').click(function () &#123; var modal_body = document.getElementById("insertModal_body"); var row_div = document.createElement("div"); var row_label = document.createElement("input"); var row_text = document.createElement("input"); row_div.setAttribute("class", "input-data form-inline added-row"); row_label.setAttribute("class", "extra-label form-control"); row_label.setAttribute("type", "text"); row_label.setAttribute("placeholder", "属性名"); row_label.setAttribute("name", "attr"); row_text.setAttribute("class", "extra-text form-control"); row_text.setAttribute("placeholder", "属性"); row_text.setAttribute("type", "text"); row_div.appendChild(row_label); row_div.appendChild(row_text); modal_body.appendChild(row_div);&#125;);$('#insert_btn').click(function () &#123; var data = &#123;&#125;; var father_node = $("#ta_info").bootstrapTable('getSelections'); var insertModal = $('#insertModal_body'); var fa_name = father_node[0]["name"]; var fa_label = father_node[0]['label']; var child_name = insertModal.find("input[name=name]").val(); var child_label = insertModal.find("input[name=label]").val(); var relation = insertModal.find("input[name=relation]").val(); var child_attrs_label = $('.extra-label'); var child_attrs = $('.extra-text'); data['fa_name'] = fa_name; data['fa_label'] = fa_label; data['name'] = child_name; data['label'] = child_label; data['relation'] = relation; if (child_name == "" || child_label == "" || relation == "") &#123; alert("请填写必要信息"); return false; &#125; else if (fa_name == child_name) &#123; alert("不可与父节点名称相同"); return false; &#125; if (child_attrs.length &gt; 0) &#123; console.log(1); for (var i = 0; i &lt; child_attrs.length; i++) &#123; data[child_attrs_label[i].value] = child_attrs[i].value; &#125; &#125; data = JSON.stringify(data); $.ajax(&#123; url: "/insert", type: 'POST', data: data, contentType: 'application/json; charset=UTF-8', success: function (msg) &#123; if (msg == "插入成功") &#123; $('#insertModal').modal('hide'); $("#ta_info").bootstrapTable('refresh'); &#125; alert(msg); &#125; &#125;)&#125;); 后端代码： 1234567891011121314151617181920@app.route('/insert', methods=['POST'])def get_insert(): try: data = request.get_json() except KeyError: return [] else: user = User(session.get("username")) start_node = &#123;&#125; end_node = &#123;&#125; start_node['name'] = data['fa_name'] start_node['label'] = data['fa_label'] relation = data['relation'] data.pop('fa_name') data.pop('fa_label') data.pop('relation') for key in data.keys(): end_node[key] = data[key] results = user.insert_table(start_node, relation, end_node) return results 123456789101112131415161718192021def insert_table(self, start_node, relation, end_node): end_node_label = end_node['label'] end_node.pop("label") data = "" for key in end_node.keys(): data += key + ":" + "\'" + end_node[key] + "\'" + "," data = data.strip(",") check_query = "MATCH (m) WHERE m.username=\'" + end_node['name'] \ + "\' and labels(m)=\'" + end_node_label + "\' RETURN m" insert_query = "MATCH (m) WHERE m.name=\'" + start_node['name'] \ + "\' and labels(m)=\'" + start_node['label'] + \ "\' CREATE (n:" + end_node_label + "" + "&#123;" + data + "&#125;)&lt;-" + \ "[:" + relation + "]-(m) RETURN n" check_result = graph.run(check_query) if check_result.forward(): return "已经存在此节点" print(insert_query) insert_result = graph.run(insert_query) if insert_result.forward(): return "插入成功" return "插入失败" 总结 利用 Neo4j 结合 Flask 构建 Web 应用的关键在于如何前端和后端如何进行数据交互，Flask 可以很方便的通过 jsonify() 方法返回 Json 数据，所以在构建应用的过程中可以尽可能使用 ajax 向后端发送 Json格式数据。 参考资料 Bootstrap Table]]></content>
      <categories>
        <category>Python实战</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>Neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下 Flask 结合 Neo4j 构建管理系统（三）]]></title>
    <url>%2F2017%2F04%2F13%2FPython%E4%B8%8BFlask%E7%BB%93%E5%90%88Neo4j%E6%9E%84%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[需求 核心需求如下： * 管理系统登录 * 从 Neo4j 中获取数据信息图形化显示出来 * 节点的关系查询及溯源查询 * 对 Neo4j 进行节点的增删改 管理系统登录 首先需要在工程目录下创建 login.html 和 models.py，前者为登录界面用于测试与 Neo4j 的连接，后者是一个用户类用于处理用户的各项操作。 本次连接采用了 Py2neo v3 库，安装可以通过 pip 安装：pip install py2neo 安装成功之后在 models.py 文件输入如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from passlib.handlers import bcryptfrom py2neo import authenticate, Graph, Nodeauthenticate("localhost:7474", "neo4j", "yy0758jyl")graph = Graph()class User: def __init__(self, username): self.username = username user_data = self.find() #获取登录用户标签 if user_data: self.label = user_data['label'] else: self.label = "User" def find(self): user = &#123;&#125; data_user = graph.find_one("User", "username", self.username) if not data_user: data_admin = graph.find_one("Admin", "username", self.username) if not data_admin: return False else: print(user) user['username'] = data_admin['username'] user['password'] = data_admin['password'] user['label'] = 'Admin' else: user['username'] = data_user['username'] user['password'] = data_user['password'] user['label'] = 'User' return user def register(self, password): if not self.find(): user = Node("User", username=self.username, password=bcrypt.encrypt(password)) graph.create(user) cypher = 'MATCH (admin:Admin) MATCH(user:User &#123;username:\'' + self.username + '\'&#125;) CREATE (admin)-[manage:Manage]-&gt;(user)' graph.run( 'MATCH (admin:Admin) MATCH(user:User &#123;username:\'' + self.username + '\'&#125;) CREATE (admin)-[manage:Manage]-&gt;(user)') return True else: return False def verify_pass(self, password): user = self.find() if not user: return False else: return bcrypt.verify(password, user["password"]) authenticate() 用于连接 Neo4j 数据库，三个参数依次是地址，用户名，密码。 find(self) 用户查找用户。 register(self, password) 注册用户。 verify_pass(self, password) 登录验证。 app.py 代码： 1234567891011121314151617181920212223242526272829303132app = Flask(__name__)app.secret_key = 'sugarsugar'@app.route('/', methods=["GET", "POST"])def index(): if request.method == "POST": if "registeruser" in request.form: username = request.form['registeruser'] password = request.form['password'] if not username or not password: flash('请输入用户名和密码') else: user = User(username) print(user) if not user.register(password): flash('一个用户已经存在') else: flash('注册成功') else: username = request.form['username'] password = request.form['password'] user = User(username) if not username or not password: flash('请输入用户名和密码') elif not user.verify_pass(password): flash('无效登录') else: session["username"] = user.username session['label'] = user.label return redirect(url_for("main_view")) return render_template('login.html') app.secret_key 由于使用了 Session 所以必须要设置该项值。 flash() 用于向网页发送信息。 数据查询 在测试完登录功能之后，首先在 templates 文件夹下创建 view.html 文件，作为登录后跳转的页面： 执行查询后相应的前端代码： 1234567891011121314151617181920212223$(document).ready(function () &#123; function search() &#123; var query = $("#search").find("input[name=condition]").val(); var flag = $("#search").find("input[name=trace]").prop('checked'); if(flag == true &amp;&amp; query == "ebay") &#123; alert("不可为根节点"); return false; &#125; $.get("/search" , &#123;q: query, f : flag&#125;, function (data) &#123; if(data.nodes.length &gt; 0)&#123; update(data.nodes, data.links); update_static(data.nodes); &#125; else alert("查询结果为空"); &#125;, "json"); return false; &#125; $("#search").submit(search); search();&#125;); 后台处理代码： app.py 代码： 1234567891011@app.route('/search')def get_search(): try: q = request.args.get('q', 0) f = request.args.get('f', 1) except KeyError: return [] else: user = User(session.get("username")) results = user.search_graph(q, f) return results models.py 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667def search_graph(self, condition, flag=False): nodes = [] rels = [] i = 0 #关系查询 query = "MATCH (m)&lt;-[:BELONG]-(a) WHERE m.name CONTAINS \'" + condition + "\' or a.name CONTAINS \'" + condition + \ "\' RETURN properties(m) as start_node, labels(m) as labels, " \ "collect(properties(a)) as cast,collect(labels(a)) as cast_labels" #溯源查询 query_trace = "Match (n) WHERE n.name contains \'" + condition + \ "\' MATCH path = shortestPath( (m:Website)-[:BELONG*..5]-(n) )" \ " where labels(n)='Sort' or labels(n)='GOODS'" \ " RETURN nodes(path) AS nodes, EXTRACT(node IN nodes(path) | ID(node)) AS ids " \ ",EXTRACT(node IN nodes(path) | labels(node)) AS labels" results = graph.run(query) if flag == "true" and condition: nodes_act = [] rels_act = [] for node_trace, id_trace, label_trace in graph.run(query_trace): j = 0 for node_ori in node_trace: node_act = &#123;&#125; node_keys = list(node_ori.keys()) for key in node_keys: node_act[key] = node_ori.get(key) node_act['label'] = label_trace[j][0] try: target_act = nodes_act.index(node_act) j += 1 except ValueError: target_act = len(nodes_act) nodes_act.append(node_act) j += 1 if j &lt; len(node_trace): try: source_act = nodes_act.index(self.get_node(node_trace[j], label_trace[j])) except ValueError: source_act = len(nodes_act) rels_act.append(&#123;"source": source_act, "target": target_act&#125;) return jsonify(&#123;"nodes": nodes_act, "links": rels_act&#125;) for start_nodes, start_labels, end_nodes, end_labels in results: keys = list(start_nodes.keys()) node = &#123;&#125; for key in keys: node[key] = start_nodes.get(key) node['label'] = start_labels[0] try: target = nodes.index(node) except ValueError: nodes.append(node) target = i i += 1 for end_node, label in zip(end_nodes, end_labels): end_keys = list(end_node.keys()) end = &#123;&#125; for key in end_keys: end[key] = end_node.get(key) end['label'] = label[0] try: source = nodes.index(end) except ValueError: nodes.append(end) source = i i += 1 rels.append(&#123;"source": source, "target": target&#125;) return jsonify(&#123;"nodes": nodes, "links": rels&#125;) 数据的可视化采用 d3.js，具体过程参考d3.js 绘制力导向图，返回的数据格式限定为 Json 格式，nodes 保存节点信息，links 保存节点关系： 12&#123;&quot;nodes&quot;: [&#123;&apos;label&apos;: &apos;Website&apos;, &apos;name&apos;: &apos;ebay&apos;&#125;, &#123;&apos;label&apos;: &apos;Sort&apos;, &apos;name&apos;: &apos;Health &amp; Beauty&apos;&#125;, &#123;&apos;label&apos;: &apos;Sort&apos;, &apos;name&apos;: &apos;Musical Instruments &amp; Gear&apos;&#125;], &quot;links&quot;:[&#123;&apos;target&apos;: 0, &apos;source&apos;: 1&#125;, &#123;&apos;target&apos;: 0, &apos;source&apos;: 2&#125;]&#125; 查询效果： 参考资料 Py2neo v3 Handbook]]></content>
      <categories>
        <category>Python实战</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>Neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下 Flask 结合 Neo4j 构建管理系统（二）]]></title>
    <url>%2F2017%2F04%2F12%2FPython%E4%B8%8BFlask%E7%BB%93%E5%90%88Neo4j%E6%9E%84%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Neo4j 简介 Neo4j 是一个高性能的，NOSQL 图形数据库，它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的 Java 持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。 安装 进入Neo4j 下载地址选择社区版进行下载安装。 使用 Neo4j 提供了 Cypher 查询语言对数据库数据进行操作，在使用 Neo4j 之前必须先了解 Cypher，可以参考官方提供了一些例程和开发文档： Intro to Cypher The Neo4j Developer Manual v3.1 第一个介绍了 Cypher 的一些基本概念方便去理解 Cypher 语言，第二个则是一份开发者文档，详细介绍了各操作的含义以及一些示例语句。 在了解 Cypher 后，就可以利用 Neo4j 控制台做一些基本的查询测试： * 首先需要开启服务器： * 在开启服务器后进入 http://localhost:7474 第一次进入需要设置密码 * 在主界面中选择 Jump into code，之后选择 Movie Graph 中的 Create a graph，则可以看到一个 Neo4j 官方提供的构造数据图的代码，点击之后运行即可。 在创建了数据图之后，点击左侧的第一个导航栏，可以看见数据图的各项信息。 查询 这里以查询节点 name 属性为 Audrey Tautou 到节点 title 属性为 As Good as It Gets 且节点关系为 ACTED_IN 间隔不超过 5 的最短路径为例，在输入框中输入如下代码： 1234MATCH (you &#123;name:&quot;Audrey Tautou&quot;&#125;)MATCH (expert &#123;title:&quot;As Good as It Gets&quot;&#125;)MATCH path = shortestPath( (you)-[:ACTED_IN*..5]-(expert) )RETURN path 运行之后结果如下：]]></content>
      <categories>
        <category>Python实战</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下 Flask 结合 Neo4j 构建管理系统（一）]]></title>
    <url>%2F2017%2F04%2F09%2FPython%E4%B8%8BFlask%E7%BB%93%E5%90%88Neo4j%E6%9E%84%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介 Flask 是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。 安装 在终端中输入 sudo pip install Flask 即可进行安装（如果不想进行全局安装，请参考官方文档）。 创建文件夹 首先需要创建如下结构的文件夹： 123/flaskr /static /templates flaskr 是工程文件夹名 static 是用于放置 css 和 javascript 文件的文件夹 templates 是放置网页模板的文件夹 如果用 PyCharm 开发，在创建 templates 文件夹后需要按住快捷键 Command + , 在 Project→Project Structure，选择 templates 文件夹后点击 Mark as 中的 Templates 测试 在 flaskr 目录下创建 app.py 的文件，输入如下代码： 123456789from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run() app = Flask(__name__) 创建一个该类的实例，第一个参数是应用模块或者包的名称。 如果你使用单一的模块（如本例），你应该使用 name ，因为模块的名称将会因其作为单独应用启动还是作为模块导入而有不同（ 也即是 'main' 或实际的导入名）。这是必须的，这样 Flask 才知道到哪去找模板、静态文件等等。 __name__ 指当前的模块名，当模块直接运行时，__name__ 为 __main__，当模块被导入运行时，__name__ 为模块名字。 route() 装饰器告诉 Flask 什么样的URL 能触发我们的函数，函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想要显示在用户浏览器中的信息。 运行结果 运行之后进入 http://localhost:5000 可以看到如下结果： 参考资料 Flask 文档]]></content>
      <categories>
        <category>Python实战</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下用 Scrapy 采集知网期刊数据（四）]]></title>
    <url>%2F2017%2F04%2F08%2FPython%E4%B8%8B%E7%94%A8Scrapy%E9%87%87%E9%9B%86%E7%9F%A5%E7%BD%91%E6%9C%9F%E5%88%8A%E6%95%B0%E6%8D%AE%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在Python 下用 Scrapy 采集知网期刊数据（三）中采集了所需数据，接下来该进行的就是数据的存储和导出。 数据存储 创建 MySql 表 导入 pymysql 库 import pymysql 配置 MySql 在 setting.py 文件中写入下列配置代码： 123456# start MySQL database configure settingMYSQL_HOST = &apos;localhost&apos;MYSQL_DBNAME = &apos;数据库名&apos;MYSQL_USER = &apos;登录名&apos;MYSQL_PASSWD = &apos;密码&apos;# end of MySQL database configure setting 编写 item pipeline 每个 item pipeline 组件(有时称之为 “Item Pipeline” )是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。 以采集引证文献的 item pipeline 为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class CnkiPipeline(object): def __init__(self): self.connect = pymysql.connect( host=settings.MYSQL_HOST, db=settings.MYSQL_DBNAME, user=settings.MYSQL_USER, passwd=settings.MYSQL_PASSWD, charset='utf8', use_unicode=True) self.cursor = self.connect.cursor() def process_item(self, item, spider): if item.__class__ == Quote: try: self.cursor.execute("""select * from reference where literature_title = %s and quote_title = %s AND literature_author = %s AND literature_journalName = %s AND literature_time = %s""", (item["paper_title"], str(item['quote_title']), item['paper_author'], item['paper_journalName'], item['paper_time'])) ret = self.cursor.fetchone() if ret: self.cursor.execute( """update reference set literature_title = %s,literature_author = %s, literature_journalName = %s, literature_time = %s,quote_title = %s where literature_title = %s and quote_title = %s AND literature_author = %s""", (str(item['paper_title']), str(item['paper_author']), str(item['paper_journalName']), str(item['paper_time']), str(item['quote_title']), str(item['paper_title']), str(item['quote_title']), str(item['paper_author']))) else: self.cursor.execute( """insert into reference(literature_title,literature_author,literature_journalName, literature_time,quote_title) value (%s,%s,%s,%s,%s)""", (str(item['paper_title']), str(item['paper_author']), str(item['paper_journalName']), str(item['paper_time']), str(item['quote_title']))) self.connect.commit() except Exception as error: log(error) return item item pipeline 中需要判断 item 的类型是否是需要被处理的类型，进而进行查询判断该条记录是否在数据库中存在，如果存在则进行更新，否则进行插入。 爬取结果 数据导出 为了将数据导出为 Excel 格式，利用到了xlrd，xlsxwriter，xlutils 库，导出代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293try: with connect.cursor() as cursor: # Create a new record sql_quote = "select * from periodical_data where journalName = %s and publicationDate = %s ORDER BY referenceNum DESC" sql_reference = "select * from reference where quote_title = %s" cursor.execute(sql_quote, (title, publicationDate)) results = cursor.fetchall() #oneup 用于记录引用数在每年一次以上的文献数，onelow 用于记录引用数在每年一次以下的文献数，noone 用于记录没有被引用的文献数 oneup=0 onelow=0 noone=0 endrows=0 for result in results: reference="" years=[] resultwork = xlrd.open_workbook(year + title + ".xls") sheet1 = resultwork.sheet_by_index(0) old_excel = copy.copy(resultwork) sheet_write = old_excel.get_sheet(0) rows = sheet1.nrows cols = sheet1.ncols quote_title = result['title'] if result['referenceNum'] != "0": cursor.execute(sql_reference, quote_title) reference = cursor.fetchall() if result['referenceNum']: if result['referenceNum'] &gt; (2016-int(year)): if oneup == 0: sheet_write.write(rows, 0, "引用每年一次以上") rows = rows + 1 oneup = oneup + 1 sheet_write.write(rows, 0, "1") sheet_write.write(rows, 1, result['title']) sheet_write.write(rows, 2, result['author']) sheet_write.write(rows, 3, result['journalName']) sheet_write.write(rows, 4, result['publicationDate']) sheet_write.write(rows, 5, result['referenceNum']) sheet_write.write(rows, 6, result['downloadNum']) else: if onelow == 0: sheet_write.write(rows, 0, "引用每年一次以下") rows = rows + 1 onelow = onelow + 1 sheet_write.write(rows, 0, "1") sheet_write.write(rows, 1, result['title']) sheet_write.write(rows, 2, result['author']) sheet_write.write(rows, 3, result['journalName']) sheet_write.write(rows, 4, result['publicationDate']) sheet_write.write(rows, 5, result['referenceNum']) sheet_write.write(rows, 6, result['downloadNum']) else: if noone == 0: sheet_write.write(rows, 0, "没有引用") rows = rows + 1 noone = noone + 1 sheet_write.write(rows, 0, "1") sheet_write.write(rows, 1, result['title']) sheet_write.write(rows, 2, result['author']) sheet_write.write(rows, 3, result['journalName']) sheet_write.write(rows, 4, result['publicationDate']) sheet_write.write(rows, 5, result['referenceNum']) sheet_write.write(rows, 6, result['downloadNum']) for row in range(len(reference)): sheet_write.write(rows + row + 1, 0, "0") sheet_write.write(rows+row+1, 1, reference[row]['literature_title']) sheet_write.write(rows+row+1, 2, reference[row]['literature_author']) sheet_write.write(rows+row+1, 3, reference[row]['literature_journalName']) sheet_write.write(rows+row+1, 4, reference[row]['literature_time']) years.append(reference[row]['literature_time']) c = Counter(years) print(c.most_common(1)) print(result['title']) if result['referenceNum']: if result['referenceNum'] &gt; (2016-int(year)): if c.most_common(1): for most in c.most_common(1): most_year = str(most).split(",")[0].split("(")[1] most_time = str(most).split(",")[1].split(")")[0] sheet_write.write(rows, 7, most_year) sheet_write.write(rows, 8, most_time) old_excel.save(year + title + ".xls") endrows = rows + len(reference) + 2 resultwork = xlrd.open_workbook(year + title + ".xls") sheet1 = resultwork.sheet_by_index(0) old_excel = copy.copy(resultwork) sheet_write = old_excel.get_sheet(0) sheet_write.write(endrows, 0, "每年引用次数一次以上百分比：" + str(float(oneup)/len(results))) sheet_write.write(endrows+1, 0, "每年引用次数一次以下百分比：" + str(float(onelow) / len(results))) sheet_write.write(endrows+2, 0, "每年没有引用百分比：" + str(float(noone) / len(results))) old_excel.save(year + title + ".xls")finally: connect.close() 导出效果： 参考资料 Scrapy 文档]]></content>
      <categories>
        <category>Python实战</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据处理</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下用 Scrapy 采集知网期刊数据（三）]]></title>
    <url>%2F2017%2F04%2F08%2FPython%E4%B8%8B%E7%94%A8Scrapy%E9%87%87%E9%9B%86%E7%9F%A5%E7%BD%91%E6%9C%9F%E5%88%8A%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在Python 下用 Scrapy 采集知网期刊数据（二）中已经获取了期刊的搜索结果，接下来就可以开始采集文献数据了。 采集期刊文献数据 定义 Items 为了定义常用的输出数据，Scrapy提供了 Item 类。 Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。 在 items.py 文件中增加如下代码： 1234567class PaperItem(scrapy.Item): title = scrapy.Field() author = scrapy.Field() journalName = scrapy.Field() publicationDate = scrapy.Field() referenceNum = scrapy.Field() downloadNum = scrapy.Field() 提取数据 12345678910111213141516171819def parse(self, response): if "rurl" in str(requests_url): iden_code_url = str(requests_url).split("GET")[1].split("&gt;")[0].strip() yield scrapy.Request(iden_code_url, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.handleCode, dont_filter=True) items = PaperItem() for result in response.css('tr[bgcolor]'): items['title'] = result.css("td &gt; a[class=fz14]").xpath("string(.)").extract_first() items['author'] = result.css("td[class=author_flag] &gt; a[class=KnowledgeNetLink]::text").extract() items['journalName'] = result.css("td[class=cjfdyxyz]").xpath("string(a)").extract_first() items['publicationDate'] = result.css("td[align] &gt; a[target=_blank]::text").extract_first().split("/")[0] items['referenceNum'] = result.css("span[class=KnowledgeNetcont] &gt; a::text").extract_first() items['downloadNum'] = result.css("span[class=downloadCount] &gt; a::text").extract_first() yield items next_page = response.xpath("//div/a[text()='下一页']/@href").extract() if next_page: next_page = response.urljoin(next_page[0]) yield scrapy.Request(next_page, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.parse, dont_filter=True) if &quot;rurl&quot; in str(requests_url) 用于判断当前请求是否是请求验证码的请求，如果是则回调 handleCode(self, response) 进行验证码的处理，由于验证码的请求链接大多相同所以必须设置 dont_filter=True。 for 循环用于提取文献的各项数据，next_page 是下一页的链接，response.urljoin() 方法构造一个绝对路径的 URL (页面上的链接都是相对路径的)，发送下一页的请求也需要设置 dont_filter=True。 验证码处理 验证码的处理主要和这两个请求相关： 第一个请求用于显示输入验证码页面和提交验证码，主要和两个参数相关： 第二个请求则主要用于获取验证码： http://kns.cnki.net/kns/checkcode.aspx?t=%27+Math.random() 处理验证码的代码如下： 12345678910111213141516171819202122232425262728293031323334def handleCode(self, response): sid_kns = "" sessionId = "" ori_cookie = response.request.headers.getlist('Cookie') response_url = str(response.request.headers.getlist('Referer')).split("'")[1].split("rurl=")[1] if "vericode=" in response_url: response_url = re.sub(r"&amp;vericode.*", "", response_url) for cookie_parameter in str(ori_cookie).split(";"): if "SID_kns" in cookie_parameter: sid_kns = cookie_parameter.split("=")[1] if "ASP.NET_SessionId" in cookie_parameter: sessionId = cookie_parameter.split("=")[1] act_cookie = &#123;"ASP.NET_SessionId": sessionId, "SID_kns": sid_kns&#125; url = "http://kns.cnki.net/kns/checkcode.aspx?t='+Math.random()" result_file = self.downloadCodeImg(url, act_cookie) code_img = Image.open(result_file) code_img.show() ver_code = input("输入验证码:") print("已输入验证码:", ver_code) return_url = "http://kns.cnki.net/kns/brief/vericode.aspx?rurl=" + response_url + "&amp;vericode=" + ver_code yield scrapy.Request(return_url, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.parse, dont_filter=True)def downloadCodeImg(self, getCodeUrl, cookie): iden_code_img = "ver_code" + time.strftime('%Y-%m-%d', time.localtime(time.time())) + ".jpg" response = requests.get(getCodeUrl, stream=True, cookies=cookie) # here we need to set stream = True parameter requests.utils.add_dict_to_cookiejar(response.cookies, cookie) print(response.cookies) with open(iden_code_img, 'wb') as f: for chunk in response.iter_content(chunk_size=1024): if chunk: f.write(chunk) f.flush() f.close() return iden_code_img response_url 为 rurl 的参数值 act_cookie 为请求的 cookies 值 downloadCodeImg 用于下载验证码 采集引证文献 定义 Items 123456class Quote(scrapy.Item): paper_title = scrapy.Field() paper_author = scrapy.Field() paper_journalName = scrapy.Field() paper_time = scrapy.Field() quote_title = scrapy.Field() 提取数据 引证文献的数据提取是动态网页，所以不能够直接采集，通过抓包分析，数据主要下图的请求相关： 为了对引证文献的所有类别进行翻页，参数 CurDBCode 必须去除，发送请求之后的页面如下图所示： 由于是纯文本页面，除了知道上图所示的参数之外，还需要知道引证文献的最大页数进行翻译，具体代码如下： 发送引证文献请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def parse(self, response): requests_url = response.request #True 代表文献引证文献数大于 0，否则代表文献没有引证文献 flag = True if "rurl" in str(requests_url): iden_code_url = str(requests_url).split("GET")[1].split("&gt;")[0].strip() yield scrapy.Request(iden_code_url, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.handleCode , dont_filter=True) #quote_urls 用于保存引证文献数大于 10 的链接，代表着引证文献页数可能两页以上需要计算页数 quote_urls = [] #quote_direct 用于保存引证文献数小于等于 10 的链接，代表着引证文献页数只有一页只用直接采集 quote_direct = [] for result in response.css('tr[bgcolor]'): quote_url = result.css("span[class=KnowledgeNetcont] &gt; a").xpath("@onclick").extract_first() num = result.css("span[class=KnowledgeNetcont] &gt; a::text").extract_first() if quote_url is not None: if int(num) &lt;= 10: pages = 1 else: pages = 1000 title = result.css("td &gt; a[class=fz14]").xpath("string(.)").extract_first() quote_code = self.get_quote_code(quote_url) origin_quote_url = "http://kns.cnki.net/kcms/detail/frame/asynlist.aspx" quote_parameters = &#123;'dbcode': 'CJFQ', 'search': title, 'code': quote_code, 'ds': 'frame/list.aspx', 'reftype': '18', 'page': pages, &#125; url = self.get_url(origin_quote_url, quote_parameters) if int(num) &lt;= 10: quote_direct.append(url) else: quote_urls.append(url) else: flag = False next_page = response.xpath("//div/a[text()='下一页']/@href").extract() if next_page and flag: next_page = response.urljoin(next_page[0]) yield scrapy.Request(next_page, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.parse , dont_filter=True, priority=100) for get_quote_url in quote_urls: yield scrapy.Request(get_quote_url, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.parse_first_quote) for get_quote_url in quote_direct: yield scrapy.Request(get_quote_url, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.parse_quote) title 文献的篇名 quote_code 文献的编码 pages 页数，设置为 1000，为了方便计算页数，如果设置为 1 进行页数计算，那么进行数据采集的时链接将被过滤掉。 priority=100 优先处理翻页的请求，翻页时间过长将导致页面不会按照被引量降序排列，从而导致数据丢失。 计算页数 1234567891011121314151617181920212223242526def parse_first_quote(self, response): result_html = Selector(response, type="html") regex = r"\Wcode=" quote_code = re.split(regex, response.url)[1] quote_code = quote_code.split("&amp;")[0] title = response.url.split("search=")[1] title = title.split("&amp;")[0] title = urllib.parse.unquote(title) origin_res = result_html.css("b[class=titleTotle] &gt; span[id]::text").extract() act_res = [] for result in origin_res: if result is not '\xa0': act_res.append(int(re.sub("\D", "", result.strip()))) if act_res: max_page = max(act_res) max_page = math.ceil(float(max_page)/10) else: max_page = 1 origin_url = 'http://kns.cnki.net/kcms/detail/frame/asynlist.aspx' for page_num in range(max_page): quote_parameters = &#123;'dbcode': 'CJFQ', 'search': title, 'code': quote_code, 'ds': 'frame/list.aspx', 'reftype': '18', 'page': str(page_num + 1), &#125; act_url = self.get_url(origin_url, quote_parameters) yield scrapy.Request(act_url, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.parse_quote) origin_res 用于获取页面上记录的条数 max_page 最大的页数 for 循环用于引证文献的翻页 采集 引证文献的格式可以分为三类，所以这三类需要单独进行处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def parse_quote(self, response): quote_item = Quote() ori_title = response.url.split("search=")[1] ori_title = ori_title.split("&amp;")[0] quote_title = urllib.parse.unquote(ori_title) for result in response.css("div[class=essayBox]"): dbTitle = result.xpath(".//div[@class='dbTitle']/text()").extract_first() if "中国学术期刊网络出版总库" in dbTitle: for result_cjfq in result.css("ul &gt; li"): paper_title = result_cjfq.xpath(".//em/text()").extract_first() +\ result_cjfq.xpath(".//a[@target='kcmstarget']").xpath('string(.)').extract_first() paper_author = result_cjfq.xpath("./text()").extract_first().replace("&amp;nbsp", '') paper_title = paper_title + paper_author.split(".")[0] paper_author = paper_author.split(".")[1].strip() paper_journalName = result_cjfq.xpath(".//a[@onclick]/text()").extract()[0] time_len = len(result_cjfq.xpath(".//a[@onclick]/text()")) paper_time = result_cjfq.xpath(".//a[@onclick]/text()").extract()[time_len - 1] paper_time = paper_time.split("(")[0] quote_item['paper_title'] = paper_title quote_item['paper_author'] = paper_author quote_item['paper_journalName'] = paper_journalName quote_item['paper_time'] = paper_time quote_item['quote_title'] = quote_title.replace("++", " ") yield quote_item if "中国博士学位论文全文数据库" in dbTitle or "中国优秀硕士学位论文全文数据库" in dbTitle: for result_cjfq in result.css("ul &gt; li"): paper_title = result_cjfq.xpath(".//em/text()").extract_first() + \ result_cjfq.xpath(".//a[@target='kcmstarget']/text()").extract_first() paper_author = result_cjfq.xpath("./text()").extract_first() paper_title = paper_title + paper_author.split(".")[0] paper_author = paper_author.split(".")[1].strip() paper_journalName = result_cjfq.xpath(".//a[@onclick]/text()").extract()[0] paper_time = result_cjfq.xpath("./text()").extract()[1].strip() quote_item['paper_title'] = paper_title quote_item['paper_author'] = paper_author quote_item['paper_journalName'] = paper_journalName quote_item['paper_time'] = paper_time quote_item['quote_title'] = quote_title.replace("++", " ") yield quote_item if "中国重要会议论文全文数据库" in dbTitle or "国际会议论文全文数据库" in dbTitle: for result_cjfq in result.css("ul &gt; li"): paper_title = result_cjfq.xpath(".//em/text()").extract_first() + \ result_cjfq.xpath(".//a[@target='kcmstarget']/text()").extract_first() other_data = result_cjfq.xpath("./text()").extract_first() paper_title = paper_title + other_data.split(".")[0] if len(other_data.split(".")) == 4: paper_author = other_data.split(".")[1].strip() paper_journalName = other_data.split(".")[2].strip() paper_time = other_data.split(".")[3].strip() elif len(other_data.split(".")) == 3: paper_author = "" paper_journalName = other_data.split(".")[1].strip() paper_time = other_data.split(".")[2].strip() quote_item['paper_title'] = paper_title quote_item['paper_author'] = paper_author quote_item['paper_journalName'] = paper_journalName quote_item['paper_time'] = paper_time quote_item['quote_title'] = quote_title.replace("++", " ") yield quote_item 参考资料 Scrapy 文档]]></content>
      <categories>
        <category>Python实战</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据处理</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下用 Scrapy 采集知网期刊数据（二）]]></title>
    <url>%2F2017%2F04%2F06%2FPython%E4%B8%8B%E7%94%A8Scrapy%E9%87%87%E9%9B%86%E7%9F%A5%E7%BD%91%E6%9C%9F%E5%88%8A%E6%95%B0%E6%8D%AE%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[需求 本次采集需要采集期刊 2000～2010 年间的数据，相关的数据首先是期刊中各文献的数据： 文献数据 主要包括 title（篇名），author（作者），journalName（刊名），publicationDate（发表时间），referenceNum（被引数） 以及 downloadNum下载数 其次是每篇文献的引证文献数据： 引用文献数据 主要包括 paper_title（篇名），paper_author（作者），paper_journalName（刊名），paper_time（发表时间）以及quote_title（引用的文献篇名）。 搜索期刊 抓包分析 在采集数据之前首先需要获取到期刊的搜索结果，而本次采集主要和下列的搜索参数相关： 起始年份 模糊或精确搜索 期刊名称 抓包之后发现搜索过程主要和下图标有红线的两个请求相关，第一个请求用于得到搜索结果，第二个请求则是将搜索的结果显示出来。 对第一个请求进行分析之后发现了与搜索条件相对应的搜索参数。 第二个请求大部分是固定参数值 发送请求 从 Excel 读取参数： 由于需要采集每本期刊 11 年的数据，所以为了减少搜索结果从而尽可能避免需要输入验证码，所以将所有的搜索条件保存在一个 Excel 文件里面： 读取参数过程如下： 1234567891011121314151617def read_excel(self): # 打开文件 workbook = xlrd.open_workbook(r'/Users/firstdream/PycharmProjects/cnkiSprider/查询条件.xlsx') # 获取所有sheet # 根据sheet索引或者名称获取sheet内容 sheet1 = workbook.sheet_by_index(0) # sheet索引从0开始 search_setting = [] for row in range(sheet1.nrows): setting = "" for col in range(sheet1.ncols): if isinstance(sheet1.row(row)[col].value, float): setting = setting + str(int(sheet1.row(row)[col].value)) + "," else: setting = setting + str(sheet1.row(row)[col].value) search_setting.append(setting) return search_setting 将每行的搜索条件拼接起来并保存在一个 list 当中。 生成请求 由于请求的参数较多，所以采用词典进行请求的参数配置，再用 get_url() 获取最终的链接： 生成第一个请求： 12345678910111213141516171819def createUrls(self): search_setting = self.read_excel() urls = [] for setting in search_setting: year_from = setting.split(",")[0] year_to = setting.split(",")[1] magazine_setting = setting.split(",")[2] search_parameters = &#123;'action': '', 'ua': '1.21', 'PageName': 'ASP.brief_result_aspx', 'DbPreFix': 'CJFQ', 'DbCatalog': '中国学术期刊网络出版总库', 'ConfigFile': 'CJFQ.xml', 'db_opt': 'CJFQ', 'db_value': '中国学术期刊网络出版总库', 'magazine_value1': magazine_setting, 'year_type': 'echar', 'year_from': year_from, 'year_to': year_to, 'magazine_special1': '=' &#125; origin_url = "http://kns.cnki.net/kns/request/SearchHandler.ashx" url = self.get_url(origin_url, search_parameters) urls.append(url) return urls 将 Excel 文件中读取的搜索条件通过 createUrls() 方法生成可迭代的请求列表。 生成第二个请求： 12345result_parameters = &#123;'pagename': 'ASP.brief_result_aspx', 'DbPreFix': 'CJFQ', 'Research': 'off', 'KeyValue': '', 'S': '1', 'recordsperpage': '50' , "sorttype": "(被引频次,'INTEGER') desc"&#125;origin_url = "http://kns.cnki.net/kns/brief/brief.aspx"act_url = self.get_url(origin_url, result_parameters) 第二个请求中增加了 recordsperpage 和 sorttype 两个参数，前者代表每页显示的记录条数（Sprider 每采集 13 页左右，知网会提示输入验证码，所以设置为最大值 50 减少结果的总页数），后者代表结果的排序方式（采集引证文献时，由于一些文献是没有被引用的，所以采用按被引量递减的方式排序去过滤掉无用的请求，从而缩短采集时间）。 get_url() 方法： 123456def get_url(self, origin_url, parameters): act_url = origin_url + "?" for key in parameters.keys(): act_url = act_url + key + "=" + urllib.request.quote(str(parameters[key])) + "&amp;" act_url = act_url.strip("&amp;") return act_url urllib.request.quote() 中文字符进行编码处理。 发送 12345678910111213141516171819def start_requests(self):headers_parameters = &#123; 'Host': 'kns.cnki.net', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36', 'Referer': 'http://kns.cnki.net/kns/brief/result.aspx?dbPrefix=CJFQ'&#125;urls = self.createUrls()for i, url in enumerate(urls): yield scrapy.Request(url, meta=&#123;'cookiejar': i&#125;, callback=self.result_page, headers=headers_parameters) def result_page(self, response): result_parameters = &#123;'pagename': 'ASP.brief_result_aspx', 'DbPreFix': 'CJFQ', 'Research': 'off', 'KeyValue': '', 'S': '1', 'recordsperpage': '50' , "sorttype": "(被引频次,'INTEGER') desc"&#125;origin_url = "http://kns.cnki.net/kns/brief/brief.aspx"act_url = self.get_url(origin_url, result_parameters)return scrapy.Request(act_url, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.parse, dont_filter=True) meta={'cookiejar': i} 保存的是 cookie 用于保持持久性连接。 There is support for keeping multiple cookie sessions per spider by using the cookiejar Request meta key. By default it uses a single cookie jar (session), but you can pass an identifier to use different ones. For example: 123for i, url in enumerate(urls): yield scrapy.Request(url, meta=&#123;'cookiejar': i&#125;, callback=self.parse_page) start_requests(self) 在获取到搜索结果之后回调 result_page(self, response) 进行进一步处理。 meta={'cookiejar': response.meta['cookiejar']} 取出 cookie 值向下传递。 Keep in mind that the cookiejar meta key is not “sticky”. You need to keep passing it along on subsequent requests. For example: 12345def parse_page(self, response): # do some processing return scrapy.Request("http://www.example.com/otherpage", meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.parse_other_page) dont_filter=True 由于第二次请求的链接相同，Scrapy 默认会过滤到这些请求，所以必须设置为 True。 配置访问异常重试 为了尽可能保证采集数据的完整性，需要配置 setting.py 文件加入如下代码： 123456# 当访问异常时是否进行重试RETRY_ENABLED = True# 当遇到以下 http 状态码时进行重试RETRY_HTTP_CODES = [500, 502, 503, 504, 400, 403, 404, 408]# 重试次数RETRY_TIMES = 5 参考资料 Scrapy 文档]]></content>
      <categories>
        <category>Python实战</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据处理</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下用 Scrapy 采集知网期刊数据（一）]]></title>
    <url>%2F2017%2F04%2F06%2FPython%E4%B8%8B%E7%94%A8Scrapy%E9%87%87%E9%9B%86%E7%9F%A5%E7%BD%91%E6%9C%9F%E5%88%8A%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介 Scrapy 是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。 安装 Pycharm 安装 Mac 下按住快捷键 Command + , 选择 Project→Project Interpreter 点击 + 号后搜索 Scrapy 进行安装即可： pip安装 pip install Scrapy 创建工程 在终端中进入需要创建工程的目录，输入命令： scrapy startproject tutorial 将会创建一个 tutorial 的目录，目录结构如下： 1234567891011121314tutorial/ scrapy.cfg # 部署配置文件 tutorial/ # 项目的 Python 模块，在这里加入代码 __init__.py items.py # 项目的 items 定义文件 pipelines.py # 项目的 pipelines 文件，用于处理 items settings.py # 项目的设置文件 spiders/ # Spider 目录所在地 __init__.py 创建 Spider 在 tutorial/spiders 目录下新建一个名为 quotes_spider.py 的文件，输入如下代码： 1234567891011121314151617181920import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): page = response.url.split("/")[-2] filename = 'quotes-%s.html' % page with open(filename, 'wb') as f: f.write(response.body) self.log('Saved file %s' % filename) QuotesSpider 继承 scrapy.Spider，同时定义了一些属性和方法： * name：作为爬虫的唯一标识，对于在同一工程中的爬虫，不能够设置相同的名称。 * start_requests()：返回一个可迭代的请求，然后 Spider 将爬取这些请求 * parse()：用于处理请求的结果。 运行 Sprider 终端命令运行 在创建的项目目录下，输入： scrapy crawl quotes quotes 为 Sprider 的标识。 Pycharm 下运行 在 tutorial 目录下创建名为 entrypoint.py 的文件，输入如下代码： 1234#!/usr/bin/env pythonfrom scrapy.cmdline import execute# quotes 为刚刚创建的 Spider 的 name，可以在这里切换不同的 Spiderexecute(['scrapy', 'crawl', 'quotes']) 修改配置 在 Run 中选择 Edit Configurations，做如下修改： 参考资料 Scrapy 文档]]></content>
      <categories>
        <category>Python实战</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据处理</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下 pymsql 库的基本使用]]></title>
    <url>%2F2017%2F04%2F06%2FPython%E4%B8%8Bpymsql%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[库的导入 import pymysql 连接 MySql 连接配置 1234MYSQL_HOST = &apos;localhost&apos;MYSQL_DBNAME = &apos;cnkiQuote&apos;MYSQL_USER = &apos;root&apos;MYSQL_PASSWD = &apos;123456&apos; 从上往下依次是主机 ip，数据库名，用户名及密码。 连接 指定编码为 utf8 1234567connection=pymysql.connect( host=MYSQL_HOST, db=MYSQL_DBNAME, user=MYSQL_USER, passwd=MYSQL_PASSWD, charset='utf8', use_unicode=True) Sql 操作 查询 1234connection.cursor.execute("""select * from periodical_data where title = %s and publicationDate = %s and author = %s""",(item["title"],item['publicationDate'],str(item['author']))) 插入 1234567connection.cursor.execute("""insert into periodical_data(title,author,journalName,publicationDate,referenceNum, downloadNum) value (%s,%s,%s,%s,%s,%s)""",(item['title'],str(item['author']),item['journalName'],item['publicationDate'],item['referenceNum'],item['downloadNum'])) 更新 12345678910connection.cursor.execute("""update periodical_data set title = %s,author = %s,journalName = %s, publicationDate = %s,referenceNum = %s,downloadNum = %s where title = %s and publicationDate = %s and author = %s""",(str(item['title']),str(item['author']),str(item['journalName']),item['publicationDate'],item['referenceNum'],item['downloadNum'],str(item['title']),item['publicationDate'],str(item['author']))) 提交更改 connection.commit()]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MySql 操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下 Excel 的读取与写入]]></title>
    <url>%2F2017%2F04%2F05%2FPython-%E4%B8%8BExcel-%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前言 前段时间需要将 MySql 的数据导出到指定格式的 Excel 表格中去，由于是基于 Python3.5 的程序，所以最后选定了 xlrd 库来进行 Excel 的读取操作，写入操作则由 xlsxwriter 和 xlutils 库来进行，其中 xlutils 用于对 Excel 文件的追加。 Excel 文件的读取 打开 Excel 文件 workbook = xlrd.open_workbook(r'查询条件.xlsx') 获取所有 sheet workbook.sheet_names() 根据sheet索引或者名称获取 sheet 内容 sheet1 = workbook.sheet_by_index(0) # sheet索引从0开始 sheet1 = data.sheet_by_name(u'Sheet1')#通过名称获取 获取 sheet1 的行数 sheet1.nrows 获取 sheet1 的列数 sheet1.ncols 获取指定行列的值 sheet1.row(row)[col].value Excel 文件的写入追加 创建 Excel 文件 workbook = xlsxwriter.Workbook(year + title + &quot;.xls&quot;) 增加 Sheet worksheet = workbook.add_worksheet() 写入数据 1234worksheet.write('A1', 'tag')worksheet.write('B1', '文章名字')sheet_write.write(rows, 0, "1")workbook.close() 追加数据 追加之前需要将 xlutils.copy 导入到工程中，首先用 xlrd 打开旧的 Excel 文件，然后利用 xlutils.copy 中的 copy() 方法复制已经存在的数据，最终在原有数据的基础上进行写入。具体代码如下： 123456789101112#导入模块from xlutils.copy import copy#打开文件resultwork = xlrd.open_workbook(year + title + ".xls")#获取行数sheet1 = resultwork.sheet_by_index(0)rows = sheet1.nrows#追加数据，保存old_excel = copy.copy(resultwork)sheet_write = old_excel.get_sheet(0)sheet_write.write(rows, 0, "1")old_excel.save(year + title + ".xls") 参考资料 xlsxwriter 文档 Python中使用第三方库xlutils来追加写入Excel文件示例]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式和 CSS 选择器以及 XPath]]></title>
    <url>%2F2017%2F04%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Ccss%E9%80%89%E6%8B%A9%E5%99%A8%E4%BB%A5%E5%8F%8Axpath%2F</url>
    <content type="text"><![CDATA[正则表达式 正则表达式主要用于字符串匹配，使用正则表达式之前需要了解各个符号的含义，这里推荐 菜鸟教程，在了解语法之后我们可以通过 regex101 进行正则表达式的测试。 CSS 选择器 CSS 选择器用于筛选 HTML 文档中的元素，可以通过元素的标签及元素的属性进行筛选，这里介绍使用过的一些小例子： span[class=KnowledgeNetcont] &gt; a::text 筛选出 class 属性为 KnowledgeNetcont 的 span 标签下的 a 标签的文本内容。 a[href*=image]::attr(href) 筛选出 a 标签的 href 属性值包含 image 的属性值。 XPath XPath 也用于筛选 HTML 文档中的元素，主要基于文档的结构进行筛选，这里依旧介绍使用过的一些小例子： xpath(&quot;.//a[@target='kcmstarget']&quot;).xpath('string(.)') @ 用于选取属性，string(.) 取的当前节点下的所有文本（包含子标签的文本），整个的含义是选取当前节点下所有 target 属性值为 kcmstarget 的 a 标签下的所有文本。 xpath(&quot;.//em/text()&quot;) 如果只想取的当前节点的文本而不需要子标签的文本则可以用 text() 去获取。 xpath(&quot;//div/a[text()='下一页']/@href&quot;) 获取文本内容为下一页的 a 标签的 href 属性值。 参考资料 正则表达式 – 教程 XPath 教程 CSS 选择器参考手册]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>字符匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 下 BeautifulSoup 的基本使用]]></title>
    <url>%2F2017%2F04%2F05%2FPython%E4%B8%8BBeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[BeautifulSoup 简介 BeautifulSoup 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库. 库的安装 库的安装参考此篇文章 requests 库的使用 基本使用 导入 BeautifulSoup from bs4 import BeautifulSoup 创建文档对象 soup = BeautifulSoup(html文档, 'html.parser') 配合 Python 内置的 html 解析器，将 html 文档传入 BeautifulSoup 构造方法。 获取数据BeautifulSoup提供了如下几种方式搜索文档获取数据： find_all() 全文搜索 返回文档中所有符合要求的数据。 find() 单次搜索 返回文档中第一个符合要求的数据。 select() CSS选择器查找 soup.select(&quot;td[align] &gt; a[target=_blank]&quot;) find_all() 中可以通过 limit 参数限制结果数量，如： soup.find_all(&quot;a&quot;, limit=2) 同时上述的 find_all() 和 find() 也可配合 CSS 选择器进行使用，如： titleList = soup.find_all(&quot;a&quot;, {&quot;class&quot;: &quot;fz14&quot;}) 参考资料 BeautifulSoup 文档 ​]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 requests 获取 Discuz 论坛验证码]]></title>
    <url>%2F2017%2F04%2F04%2Frequests%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[requests 库的安装 Mac 下使用 Pycharm 时只需按住快捷键 Command + , 选择 Project→Project Interpreter 点击 + 号后搜索 requests 进行安装即可： 获取过程使用的方法 requests.get(url, params=None, **kwargs) url 是请求的链接，params 是发送请求时参数，kwargs 是可选参数。 获取过程 为了保持连接的持久性不能直接使用 requests 发送请求，而需要利用 Session 对象。具体获取代码如下： 12345678910111213141516171819202122232425session = requests.session()ss = session.get("http://www.zhuixinfan.com/member.php?mod=register")result = ss.text#获取参数params = re.findall("&lt;input.*(?:name=\"formhash\"|name=\"sechash\").*\&gt;", result)params = list(set(params))sechash = re.sub(".*value=\"", "", params[1])sechash = re.sub("\".*", "", sechash)#更新验证码actually_url = "http://www.zhuixinfan.com/misc.php?mod=seccode&amp;action=update&amp;idhash=" + sechashhtm = session.get(actually_url)#获取图片链接update_url = re.findall(r"\bsrc=\S*", htm.text)update = re.sub("src=\"", "", update_url[0])update = re.sub("\"", "", update)#下载图片headers = &#123; 'Host': 'www.zhuixinfan.com', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36', 'Referer': 'http://www.zhuixinfan.com/member.php?mod=register' &#125;url = "http://www.zhuixinfan.com/" + updateresult = session.get(url, headers=headers)im = Image.open(BytesIO(result.content))im.show() 获取过程中首先向站点发送请求，从返回的网页信息中利用正则表达式获取 sechash 参数，之后利用所得到的 sechash 向站点发送更新验证码的请求并从返回的信息中获取验证码图片的 url，最后从站点下载图片利用 Image.open() 显示图片。 参考资料 Requests: 让 HTTP 服务人类]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>requests 库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HorizontalScrollView 和 ViewPager 触控冲突解决]]></title>
    <url>%2F2016%2F09%2F27%2FAndroid%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95HorizontalScrollView%E5%92%8CViewPager%E8%A7%A6%E6%8E%A7%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言 当 HorizontalScrollView 和 ViewPager 一起使用的时候会出现滑动冲突的问题 解决过程 要了解 HorizontalScrollView 和 ViewPager 触控冲突的原因，首先需要了解Android 触摸事件处理的的机制，在了解后可以知道，当 HorizontalScrollView 内层嵌套使用 ViewPager 时，由于触摸事件被 HorizontalScrollView 的 onInterceptTouchEvent() 拦截导致事件不能向下层传递，所以当滑动屏幕时，HorizontalScrollView 可以正常滑动，但是 ViewPager 却不能正常滑动，而这个时候我们期望的是边缘滑动时，HorizontalScrollView 响应事件，非边缘滑动时，ViewPager 响应事件，为了达到这一目的我们需要重写 HorizontalScrollView 的 onInterceptTouchEvent() 函数，具体代码如下： 1234567public boolean onInterceptTouchEvent(MotionEvent ev) &#123; mXPoint = ev.getRawX(); if (mXPoint &gt; 100 &amp;&amp; mXPoint &lt; mMenuWidth) &#123; return false; &#125; return super.onInterceptTouchEvent(ev);&#125; 通过限定滑动的屏幕范围决定是否事件在这一层被处理，在这样处理之后 HorizontalScrollView 和 ViewPager 都能正确响应了，但是当 HorizontalScrollView 滑动至终点时，屏幕中间的部分却不能够正确响应 HorizontalScrollView 的滑动事件，所以我们需要做进一步处理，判断 HorizontalScrollView 是否滑动至终点，所以在 onTouchEvent 事件中利用一个 flag 的标志位去判断是否滑动至终点，具体代码如下： 12345678910111213141516public boolean onTouchEvent(MotionEvent ev) &#123; int action = ev.getAction(); switch (action) &#123; case MotionEvent.ACTION_UP: int scollX = getScrollX(); if (scollX &gt; mMenuHaltWidth) &#123; this.scrollTo(mMenuWidth, 0); sMenuFlag = false; &#125; else &#123; this.scrollTo(0, 0); sMenuFlag = true; &#125; return true; &#125; return super.onTouchEvent(ev);&#125; onInterceptTouchEvent() 函数判断条件变为： if (mXPoint &gt; 100 &amp;&amp; mXPoint &lt; mMenuWidth &amp;&amp; sMenuFlag == false) 最终效果 参考资料 Android 控件的触摸事件传递与处理 Android 触摸事件处理机制]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 语法基础]]></title>
    <url>%2F2016%2F09%2F26%2FPython%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[近段时间学习了下Python，于是大略总结了下所学的语法知识： 列表的创建: 1movies = ["The Holy Grail", 1975, "Terry Jones &amp; Terry Gilliam", 91,["Graham Chapman", ["Michael Palin", "John Cleese", "Terry Gilliam", "Eric Idle", "Terry Jones"]]] 这里是一个嵌套列表的创建，其中的中括号也可以换成大括号，双引号可以用单引号代替，列表里面可以是混合的数据。常用的方法有 ： append()：在列表末尾增加一个数据项 pop()：在列表的末尾删除数据 extend(数据项集合)：在列表的末尾添加一个数据项集合 remove(项)：删除一个特定数据的项 insert(序号, 数据项)：在指定序号的前面插入数据项 列表的遍历之 for 循环: 列表的遍历需要用到 for 循环，其基本语法是：for 变量 in 列表项：，由此可以将列表中的每一项（只会遍历一级列表）通过 print() 函数输出。 嵌套列表的遍历之 if 判断: 对于嵌套列表的遍历，需要判断 for 循环时每一项是否是列表项，因此需要用到 if 判断语句和 isinstance，isinstance(变量, list) 用于判断是否是列表，if 的语法是： 1234if 某个条件满足: True组else: False组 嵌套列表的遍历之定义函数： 上述最多只能够处理一层嵌套的列表，如果希望处理多层嵌套的列表则需要定义函数并去递归调用，其基本语法是： 12def 函数名(参数): 代码块 转换为模块： 代码块保存为 .py 文件，创建 setup.py 的文件，包含如下内容： 12345678910from distutils.core import setupsetup( name='HelloWorld', version='1.0.0', py_modules=['nester'], url='http://www.headfirstlabs', author='firstdream', author_email='firstdream10@icloud.com', description='A simple printer of nested lists') 构建发布文件 (windows 下): python setup.py sdist 安装 Python 副本到本地： python setup.py install 导入模块： import 模块名 向 PyPl 上传代码： python setup.py register(第一次上传) python setup.py sdist upload 常用 BIF 1234567891011121314#创建一个空的列表list()#返回一个迭代器，根据需要生成一个指定范围的数字，常配合 for 循环使用range()for num in range(4): print(num)＃创建成对数据的一个编号列表，从 0 开始enumerate()#将一个字符串或另一个数转换为一个整数(如果可行)int()#返回一个 Python 数据对象的唯一标识id()#返回一个可迭代数据结构中的下一项next() 为函数提供默认参数 def 函数名(参数=缺省值): 2016.10.7 文件操作 123456789101112#以默认的 r 模式打开文件the_file = open("文件名")#以 w 模式打开文件out = open("文件名", "w")#关闭文件the_file.close()#读取文件数据行the_file.readline()#返回文件起始位置the_file.seek(0)#写入数据到文件print("内容", file=文件对象名) 异常处理 1234567891011121314try: 可能发生错误的代码except: 错误恢复代码finally: 最后的执行代码#数据不符合期望的格式时会出现 ValueError#数据无法正常访问时会出现 IOError#用with处理文件，可不需要 finally 模块try: with open() as data: 代码except 异常： 代码 其余方法 123456789101112131415161718#显示当前目录及更改当前目录import osos.getcwd()os.chdir("路径")#split() 分割字符串，返回一个字符串列表(role, line_spoken) = each_line.split(":")#利用 split 的可选参数指定为两部分split(":", 1)#find() 查找字符串each_line.find(":")#not 取反判断条件if not each_line.find(':') == -1:#pass 作为Python的空语句或null语句#strip() 方法从字符串中去除不想要的空白符line_spoken.strip()#str() 可以用来访问任何数据对象的字符串表示#locals() 返回当前作用域中的变量集合if 'man_file' in locals(): 2016.10.15 pickle &quot;腌制&quot;数据和恢复数据 Python 提供了一个标准库 pickle 用于保存和加载 Python 的数据对象，使用方法： 12345678import pickle...#pickle 处理文件数据时必须以二进制访问with open('mydata.pickle', 'wb') as mysavedata: pickle.dump([1, 2, ''three], mysavedata) ...with open('mydata.pickle', 'rb') as myrestoredata: a_list = pickle.load(myrestoredata) 列表推导 列表推导用于减少转换列表时的代码量 12345新列表 = [转换函数(t) for t in 原列表]new_l = []for t in old_l: new_l.append(len(t))new_l = [len(t) for t in old_l] 集合 set Python 提供一种名为集合的数据结构，集合中的数据是无序的，而且不允许重复 创建集合： 123#set() -&gt; new empty set object#set(iterable) -&gt; new set object集合名 = set(object) 字典 字典将 value 和 key 关联，使用字典: 123456#创建字典字典名 = &#123;&#125;字典名 = dict()#增加数据字典名[key] = value #vlaue可以为任意数据类型字典名 = &#123;’key‘:value, 'key':value&#125; 类 123456#定义类class 类名: def _init_(self): #初始化对象的代码#创建对象实例对象 = 类名() 继承 123class 类名(继承的类名): def _init_(self, 参数):#初始化对象的代码 其它 print(列表[-1]) 输出最后一个数据项 strip() 方法可以从字符串中去除不想要的空白符 in 操作符用于检查成员关系 原地排序 sort()，原列表顺序改变 复制排序 sorted()，返回一个排序过的原列表副本 分片访问列表列表[起始值：结束值]可以访问起始到结束(不包括结束值)的列表项]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 下获取 activity_main.xml 的根 View]]></title>
    <url>%2F2016%2F09%2F22%2FAndroid%E4%B8%8B%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8DXML%E7%9A%84%E6%A0%B9View%2F</url>
    <content type="text"><![CDATA[最近做测试的时候需要获取当前 XML 的根视图进行操作，查询后发现网上提到了 getDecorView()，getRootView()，参照别人的测试自己也做了一个小的测试，首先是一个 View 层次结构图，方便理解测试，原文地址在文章最后： activity_main 和 btn_lay 布局如下： 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.rookieyang.test.MainActivity"&gt; &lt;Button android:id="@+id/btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="hello" /&gt; &lt;include layout="@layout/btn_lay" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:id="@+id/btn2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="test" /&gt;&lt;/LinearLayout&gt; 接下来是测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainActivity extends AppCompatActivity &#123; private View mDecorView; private View mRootView; private View mContentView; private View mCurrentView; private View mCurrentView2; private TextView mOneText; private TextView mTwoText; private Button mBtn; private Button mBtn2; private Button mBtn3; private View mView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); logView(); &#125; private void init() &#123; mDecorView = getWindow().getDecorView(); mRootView = mDecorView.getRootView(); mContentView = mDecorView.findViewById(android.R.id.content); mCurrentView = ((ViewGroup) mContentView).getChildAt(0); mOneText = (TextView) ((ViewGroup) mCurrentView).getChildAt(0); mCurrentView2 = ((ViewGroup) mRootView .findViewById(android.R.id.content)).getChildAt(0); mTwoText = (TextView) ((ViewGroup) mCurrentView2).getChildAt(0); mView = LayoutInflater.from(this).inflate(R.layout.btn_lay, null); mBtn = (Button) findViewById(R.id.btn); mBtn2 = (Button) mView.findViewById(R.id.btn2); mBtn3 = (Button) findViewById(R.id.btn2); &#125; private void logView() &#123; Log.i("MainActivity", "DecorView:" + mDecorView ); Log.i("MainActivity", "DecorView ID:" + mDecorView.getId()); Log.i("MainActivity", "RootView:" + mRootView); Log.i("MainActivity", "RootView ID:" + mRootView.getId()); Log.i("MainActivity", "ContentView:" + mContentView); Log.i("MainActivity", "ContentView ID:" + mContentView.getId()); Log.i("MainActivity", "CurrentView:" + mCurrentView); Log.i("MainActivity", "CurrentView ID:" + mCurrentView.getId()); Log.i("MainActivity", "CurrentView2:" + mCurrentView2); Log.i("MainActivity", "CurrentView2 ID:" + mCurrentView2.getId()); Log.i("MainActivity", "mOneText ID:" + mOneText.getText()); Log.i("MainActivity", "mTwoText ID:" + mTwoText.getText()); Log.i("MainActivity", "mBtn RootView:" + mBtn.getRootView()); Log.i("MainActivity", "mBtn2 RootView:" + mBtn2.getRootView()); Log.i("MainActivity", "mBtn3 RootView:" + mBtn3.getRootView()); &#125;&#125; 运行结果如下： 首先可以看到 getWindow().getDecorView() 和 getDecorView().getRootView() 获得的 View 和 id 是一样的， 说明 DecorView 是整个 Window 界面最顶层的 View。 但是对比 mBtn2.getRootView() 和 mBtn3.getRootView() 却发现两者输出结果完全不同，mBtn3.getRootView() 获取到的是 DecorView，而 mBtn2.getRootView() 获取到的则是 LinearLayout，两者的不同之处在于 mBtn2 通过 mView.findViewById(R.id.btn2) 获取，mBtn3 却是直接通过 findViewById(R.id.btn2) 获取。在查询 LayoutInflater 的 API 文档后，第一行的描述是这样的： 「Instantiates a layout XML file into its corresponding View objects」 也就说通过 LayoutInflater.from(this).inflate(R.layout.btn_lay, null)，btn_lay 布局被实例化了到对应的 View 对象中，所以导致 mView 的根视图是 LinearLayout，自然 mBtn2 的根视图也是 LinearLayout。 findViewById(android.R.id.content) 用于获取 activity_main 外层的视图，即上图的 mContentParent。 在获取了 mContentParent 之后，由于 activity_main 的根视图是 mContentParent 的第一个子元素，所以利用 getChildAt(0) 即可获取 ConstraintLayout。mCurrentView 和 mCurrentView2 的输出结果可以印证该点。 总结： 获取 activity_main.xml 根 View： 12View rootView = ((ViewGroup)(getWindow().getDecorView() .findViewById(android.R.id.content))).getChildAt(0); 获取 btn_lay.xml 根 View: 1View rootView = LayoutInflater.from(this).inflate(R.layout.btn_lay, null).getRootView(); getDecorView(): Retrieve the top-level window decor view (containing the standard window frame/decorations and the client's content inside of that), which can be added as a window to the window manager. getRootView(): Finds the topmost view in the current view hierarchy. 参考链接 view.getRootView() 的真正含义及测试 Android View 源码解读]]></content>
      <categories>
        <category>Android问题记录</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 TabLayout 和 ToolBar 实现滑动标签页]]></title>
    <url>%2F2016%2F09%2F08%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%88%A9%E7%94%A8TabLayout%E5%92%8CToolBar%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[最近在实现便签滑动页的时候突然发现 ActionBar 已经不被官方推荐使用，比较好的一个方法就是利用 ToolBar 和 TabLayout 来实现，以下是实现步骤： TalLayout 是 Android Support Design 中的一个控件，在使用之前需要在 build.gradle 文件中添加compile'com.android.support:design:23.2.0' 才能够正常使用。 对 values 中的 style 文件进行设置以屏蔽 Activity 的 ActionBar，让主题继承于 NoActionBar，如果需要改变 Acitivity 的背景颜色设置 windowBackground 即可： 123456789&lt;!-- Base application theme. --&gt;&lt;style name="AppTheme" parent="Theme.AppCompat.NoActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/material_blue_grey_800&lt;/item&gt; &lt;!--Status bar color--&gt; &lt;item name="colorPrimaryDark"&gt;@color/accent_material_light&lt;/item&gt; &lt;!--Window color--&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 由于需要实现标签页的滑动效果所以需要用到 ViewPager ，加上 TabLayout 和 TooBar 基本的布局如下： 12345678910111213141516171819&lt;android.support.v7.widget.Toolbar android:id="@+id/topToolBar" android:layout_width="match_parent" android:layout_height="wrap_content" android:paddingTop="@dimen/bar_top_padding"&gt;&lt;/android.support.v7.widget.Toolbar&gt;&lt;android.support.design.widget.TabLayout android:id="@+id/tabLayout" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/topToolBar" app:tabSelectedTextColor="#3da6a2" app:tabTextColor="#817f7f"&gt;&lt;/android.support.design.widget.TabLayout&gt;&lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_below="@id/tabLayout"&gt;&lt;/android.support.v4.view.ViewPager&gt; 其中 TabLayout 中tabSelectedTextColor 用于设置选中Tab的字体颜色，tabTextColor 用于设置未选中的Tab字体的颜色，Toolbar 中设置 paddingTop 主要用于4.4中沉浸式状态栏的适配，防止 ToolBar 和状态栏重合。 之后是为 ToolBar 设置各种属性创建 FramePagerAdapter，对 ViewPager 和 TabLayout 设置监听事件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class Bar_Activity extends AppCompatActivity &#123; Toolbar topToolBar; TabLayout tabLayout; ViewPager viewPager; FragmentPagerAdapter pagerAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_bar_); init(); topToolBar.setTitle("BarDemo"); setSupportActionBar(topToolBar); /*设置状态栏为透明*/ WindowManager.LayoutParams layoutParams = getWindow().getAttributes(); layoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | layoutParams.flags); getSupportActionBar().setDisplayHomeAsUpEnabled(false); //遍历FragmentPagerAdapter为TabLayout添加Tab for (int i = 0; i &lt; pagerAdapter.getCount(); i++) &#123; tabLayout.addTab( tabLayout.newTab().setText(pagerAdapter.getPageTitle(i))); &#125; //为ViewPager设置适配器 viewPager.setAdapter(pagerAdapter); //为viewPager设置监听事件，当frame改变时更改Tab viewPager.addOnPageChangeListener( new TabLayout.TabLayoutOnPageChangeListener(tabLayout)); //为tabLayout设置监听事件，当选中tab的时候切换frame tabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; viewPager.setCurrentItem(tab.getPosition()); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125; &#125;); topToolBar.setNavigationIcon(R.drawable.ic_account_circle_white_24dp); &#125; protected void init() &#123; topToolBar = (Toolbar) findViewById(R.id.topToolBar); tabLayout = (TabLayout) findViewById(R.id.tabLayout); viewPager = (ViewPager) findViewById(R.id.viewPager); topToolBar.setBackgroundColor(Color.parseColor("#1aae98")); tabLayout.setBackgroundColor(Color.GRAY); //创建针对ViewPager的FragmentPagerAdapter pagerAdapter = new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; Fragment tabFragment = new TabFragment(); Bundle args = new Bundle(); args.putInt(TabFragment.FLAG_TAB, position + 1); tabFragment.setArguments(args); return tabFragment; &#125; @Override public int getCount() &#123; return 3; &#125; @Override public CharSequence getPageTitle(int position) &#123; switch (position) &#123; case 0: return "tab1"; case 1: return "tab2"; case 2: return "tab3"; &#125; return null; &#125; &#125;; &#125; //设置 toolBar 右上角的菜单项 @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; return super.onOptionsItemSelected(item); &#125;&#125; 最后看下 menu 文件 12345678&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/search_item" android:title="search" android:icon="@drawable/ic_search_white_24dp" app:actionViewClass="android.support.v7.widget.SearchView" app:showAsAction="ifRoom|collapseActionView"&gt;&lt;/item&gt;&lt;/menu&gt; 最终实现效果如图所示：]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用视图显示图片和菜单]]></title>
    <url>%2F2016%2F05%2F27%2F%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E5%92%8C%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[显示图片的视图控件 GridView 添加方式： 123456789&lt;GridView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/gridview" android:numColumns="auto_fit" android:verticalSpacing="10dp" android:horizontalSpacing="10dp" android:columnWidth="90dp" android:stretchMode="columnWidth"/&gt;//缩放与列宽同步 其中 verticalSpacing 表示 grid 元素之间的竖直距离，horizontalSpacing 表示 grid 元素之间的水平距离。 常用方法: 1234567gridView.setAdapter(new ImageAdapter(this));gridView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Toast.makeText(getBaseContext(), "pic" + (position + 1) + "selected", Toast.LENGTH_SHORT).show(); &#125;&#125;); 显示效果： 菜单和视图一起显示 常用方法： CreateMenu(Menu menu) 创建菜单项 1234567891011private void CreateMenu(Menu menu) &#123; MenuItem mnu1 = menu.add(0, 0, 0, "Item 1"); &#123; mnu1.setAlphabeticShortcut('a'); &#125; MenuItem mnu2 = menu.add(0, 1, 1, "Item 2"); &#123; mnu2.setAlphabeticShortcut('a'); &#125;&#125; add() 方法中4个参数： groupId 菜单项所在的组的标识符，0 表示不在一个组中。 itemId 唯一的菜单项ID order 菜单项显示的顺序 title 菜单项显示的文本 MenuChoice(MenuItem item) 用于判断菜单项是否被选中 1234567891011private boolean MenuChoice(MenuItem item) &#123; switch (item.getItemId()) &#123; case 0: Toast.makeText(this, "You clicked on Item1", Toast.LENGTH_SHORT).show(); return true; case 1: Toast.makeText(this, "You clicked on Item2", Toast.LENGTH_SHORT).show(); return true; &#125; return false;&#125;= onCreateOptionsMenu() 当 MENU 按钮按下时调用 12345public boolean onCreateOptionsMenu (Menu menu) &#123; super.onCreateOptionsMenu(menu); CreateMenu(menu); return true;&#125; onOptionsItemSelected() 选择菜单时调用 123public boolean onOptionsItemSelected (MenuItem item)&#123; return MenuChoice(item);&#125; setOnCreateContextMenuListener 设置上下文菜单 通过设置 setOnCreateContextMenuListener 方法，然后实现 onCreateContextMenu 方法即可。 12345public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, view, menuInfo); CreateMenu(menu); &#125; 实现效果如图： WebView 添加 WebView 1234&lt;WebView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/webview"/&gt; 避免启动设备的 Web 浏览器 实现 WebViewClient 类重写 shouldOverrideUrlLoading 1234567webView.setWebViewClient(new CallBack());public class CallBack extends WebViewClient &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; return (false); &#125;&#125;]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控件添加右键菜单项]]></title>
    <url>%2F2016%2F04%2F22%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[以 JList 控件为例 首先控件需要添加鼠标的监听事件 12345678mUserList.addMouseListener(new MouseAdapter() &#123; @Override public void mouseReleased(MouseEvent e) &#123; super.mouseReleased(e); showPopup(e); &#125;&#125;); showPopup() 显示菜单的功能 1234567public void showPopup(MouseEvent e) &#123; if (e.isPopupTrigger() &amp;&amp; mUserList.getSelectedIndex() != -1 &amp;&amp; !mUserList.getSelectedValue().equals("管理员")) &#123; Object selected = mUserName.getElementAt(mUserList.getSelectedIndex()); popupMenu.show(e.getComponent(), e.getX(), e.getY()); &#125;&#125; e.isPopupTrigger() 检测是否是右键，mUserList.getSelectedIndex() 防止在列表空白处点击]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>AWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DialogFragment 实现TimePickerDialog]]></title>
    <url>%2F2016%2F04%2F22%2FDialogFragment%E5%AE%9E%E7%8E%B0TimePickerDialog%2F</url>
    <content type="text"><![CDATA[在实现 onCreateDialog(int id) 发现方法已过时，新的方法是 DialogFragment，FragmentManager 12345678910111213141516171819202122public class TimePickerFragment extends DialogFragment implements TimePickerDialog.OnTimeSetListener &#123; int hour, minute; public Dialog onCreateDialog(Bundle savedInstanceState) &#123; return new TimePickerDialog(getActivity(), this, hour, minute, false);//返回一个TimePickerDialog &#125; @Override public void onTimeSet(TimePicker view, int hourOfDay, int minuteOfHour) &#123; hour = hourOfDay; minute = minuteOfHour; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("hh:mm aa"); Date date; Calendar calendar = Calendar.getInstance();//Date构造方法过时，Calendar转Date calendar.set(0,0,0,hour,minute); date = calendar.getTime(); String strDate = simpleDateFormat.format(date); Toast.makeText(getActivity(), "you have selected" + strDate, Toast.LENGTH_SHORT).show(); &#125;&#125; 显示 Dialog 12DialogFragment dialogFragment = new TimePickerFragment();dialogFragment.show(getSupportFragmentManager(),"timePicker");]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 视图设计用户界面]]></title>
    <url>%2F2016%2F04%2F21%2FAndroid%E8%A7%86%E5%9B%BE%E8%AE%BE%E8%AE%A1%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[基本视图 ToggleButton，RadioButton，RadioGroup，AutoCompleteTextView ToggleButton 用一个灯光指示器来显示选中/未选中状态 12345&lt;ToggleButton android:id="@+id/toggle1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@id/rdbGp1"/&gt; RadioButton 和 RaidoGroup RadioButton 有两个状态：选中或未选中。 RaidoGroup 用来把一个或多个 RaidoButton 视图组合在一起，从而只允许一个 RaidoButton 被选中。 1234567891011121314151617&lt;RadioGroup android:id="@+id/rdbGp1" android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:layout_below="@id/star"&gt; &lt;RadioButton android:id="@+id/rdb1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Option 1" /&gt; &lt;RadioButton android:id="@+id/rdb2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Option 2" /&gt;&lt;/RadioGroup&gt; 视图效果如下： AutoCompleteTextView：与 EditText 类似，输入时提供候选项 123456&lt;AutoCompleteTextView android:id="@+id/txtCountries" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentStart="true" android:layout_below="@+id/textView" /&gt; 1234ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_dropdown_item_1line,presidents);//创建容器AutoCompleteTextView textView = (AutoCompleteTextView) findViewById(R.id.txtCountries); textView.setThreshold(3); textView.setAdapter(adapter);//设置候选项 视图效果： CheckBox，RadioButton 视图事件 CheckBox：需将 onClick() 方法的参数类型转换为一个CheckBox ，然后检查 isCheckBox() 方法来确定其是否被选中 12345678910CheckBox checkBox = (CheckBox)findViewById(R.id.chkAutosave);checkBox.setOnClickListener(new View.OnClickListener() &#123;@Overridepublic void onClick(View v) &#123; if (((CheckBox) v).isChecked()) DisplayToast("CheckBox is checked"); else DisplayToast("CheckBox is unchecked"); &#125;&#125;); RadioButton：需要使用 RadioGroup 的 setOnCheckedChangeListener() 方法注册一个回调函数, 以便该组中的被选中的 RadioButton 发生变化的时候调用。 123456789101112RadioGroup radioGroup = (RadioGroup)findViewById(R.id.rdbGp1);radioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener() &#123;@Overridepublic void onCheckedChanged(RadioGroup group, int checkedId) &#123; RadioButton rb1 = (RadioButton) findViewById(R.id.rdb1); if (rb1.isChecked()) &#123; DisplayToast("Option 1 checked"); &#125; else &#123; DisplayToast("Option 2 checked"); &#125; &#125;&#125;); 列表视图 ListView,Spinner ListView： 12345setListAdapter(new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_checked, presidents));//设置列表项public void onListItemClick(ListView parent, View v, int position, long id) &#123; Toast.makeText(this, "you have selected:" + presidents[position], Toast.LENGTH_SHORT).show();&#125; getListView() 获取当前的列表视图，只有当前 Activity 继承 ListAcitvity 时才能用。 Spinner： 12345&lt;Spinner android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/spinner" android:drawSelectorOnTop="true"/&gt; 设置列表和判断选择 1234567891011121314151617 Spinner spinner = (Spinner) findViewById(R.id.spinner); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_spinner_item, prisidents); spinner.setAdapter(adapter);//设置列表项 spinner.setOnItemSelectedListener(new OnItemSelectedListener() &#123;@Overridepublic void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; int index = parent.getSelectedItemPosition(); Toast.makeText(BasicViews6Activity.this, "you have selected item :" + prisidents[index], Toast.LENGTH_SHORT).show();&#125;@Overridepublic void onNothingSelected(AdapterView&lt;?&gt; parent) &#123;&#125; &#125;);//判断哪一项被选择了 特殊碎片 ListFragment，DialogFrament，PerferenceFragment 要使用 ListFragment 首先需要创建一个 ListFragment 的类 (fragmnet1)，创建一个关于 fragment1 的视图，在 Activity 的 Layout 中声明碎片。在 Activity 中显示于 fragment1 的视图，可以使用 FragmentManger 和 FragmentTransaction 类； 1234567FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();Fragment1 fragment1 = new Fragment1();fragmentTransaction.replace(android.R.id.content,fragment1);fragmentTransaction.addToBackStack(null);fragmentTransaction.commit(); PerferenceFragment 中 PreferenceCategory 用于创建类别 PreferenceScreen 用于显示一个 PerferenceFragmnet 界面 练习 访问放在 Strings.xml 文件中的字符串资源 getResources() 获取当前日期 1234Calendar today = Calendar.getInstance();yr = today.get(Calendar.YEAR);month = today.get(Calendar.MONTH);day = today.get(Calendar.DAY_OF_MONTH);]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础控件</tag>
      </tags>
  </entry>
</search>
