<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ikroal&#39;s blog</title>
  
  <subtitle>Through the darkest alleys and loneliest valleys</subtitle>
  <link href="https://www.ikroal.cn/atom.xml" rel="self"/>
  
  <link href="https://www.ikroal.cn/"/>
  <updated>2022-04-16T14:25:55.421Z</updated>
  <id>https://www.ikroal.cn/</id>
  
  <author>
    <name>ikroal</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这有一份秋招指南，请注意查收</title>
    <link href="https://www.ikroal.cn/posts/a023eb3a.html"/>
    <id>https://www.ikroal.cn/posts/a023eb3a.html</id>
    <published>2022-04-16T13:48:17.000Z</published>
    <updated>2022-04-16T14:25:55.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://res.craft.do/user/full/1ae7c81f-976a-6137-e5f0-8e6e6e91b9f5/doc/73C7CEB7-7670-4319-ABF4-02469D939DEB/6EFFD135-4AFA-4BF9-A76B-F91EA95E78A9_2/yWysYTGUj3vBOWmlUTnH33agfGyXuYLwPWVPgPpO5jIz/IMG_20220224_111648.jpeg"></p><span id="more"></span><h1 id="前言">前言</h1><p>拖延许久，终于下定决定来完成这份秋招指南。写份指南的想法最早萌生自与实验室同学关于秋招话题的一些探讨，最初的目的是希望通过介绍一些经验来防止同学们在秋招过程中犯下与我相似的错误。然而，在整理构思这份指南的过程中，我发现这份指南在介绍经验外也帮助我完成了一次阶段性的总结。</p><h1 id="食用说明">食用说明</h1><blockquote><p>本部分介绍了指南的组织结构，说明了每个部分关注的重点，以便读者针对性地进行阅读。值得注意的是，本指南的内容均为个人观点，请读者批判性地来吸收。</p></blockquote><p><img src="https://res.craft.do/user/full/1ae7c81f-976a-6137-e5f0-8e6e6e91b9f5/doc/73C7CEB7-7670-4319-ABF4-02469D939DEB/FA9ED7F8-4BD3-46A6-84A8-86187E185DA3_2/N1eFNrpztQ89dRA1DvJH8d5GKyH0UsMeMQHx3TJIKn0z/FA9ED7F8-4BD3-46A6-84A8-86187E185DA3_2.png"></p><p>按照事件发生的时间顺序，秋招指南由四部分组成，每部分关注的重点如下：</p><ul><li><p>前期准备</p><p>充足的准备是成功开始。在条件允许的情况下，我们至少应当在秋招启动（提前批一般在7月份）的一两个月前开始复习。在这个过程中，我们一方面需要对计算机相关的理论知识进行复习。另一方面，我们也需要对参与过的实践项目进行梳理，并且加强算法题的训练。<strong>针对理论知识的复习</strong>，我在这一部分尽可能给出了每一科目核心知识的思维导图，该思维导图对知识间的逻辑关系（也可理解为技术的演变路线）进行了梳理。借助这些思维导图，希望大家能够更有条理地来学习这些知识。<strong>而针对实践项目的梳理和算法题的训练</strong>，我介绍了自己的梳理思路，并提供了一些算法题训练的材料。</p></li><li><p>简历制作与投递</p><p>在进行了一定程度的准备后，我们可以开始制作简历并投递一些小公司的岗位，用以检验自己当前的准备方案是否存在问题等。在投递岗位时，简历决定了留给招聘方的第一印象，而岗位的选择会影响后续应聘的成功率。因此，在这一部分，我主要说明了<strong>制作简历和岗位选择时需要考虑的一些因素。</strong></p></li><li><p>应聘</p><p>在投递简历并通过筛选之后，我们将进入由笔试和面试组成的应聘环节。通常，笔试和面试包含多轮，每轮都有各自的侧重点。<strong>对于这些侧重点，应聘部分将予以介绍，并说明其中隐藏的一些坑。</strong></p></li><li><p>薪酬谈判与Offer选择</p><p>在秋招结束时，每个人或多或少会接收到多个Offer，这时将面临后续的薪酬谈判和Offer选择的问题。针对这些问题，我会说明<strong>一些薪酬谈判中值得关注的点，并介绍了Offer选择时需要考虑的一些因素。</strong></p></li></ul><h1 id="前期准备">前期准备</h1><p>在前期准备中，我们需要对理论知识和实践内容进行复习和梳理。理论知识除了包括数据结构、编程语言和操作系统等常见的专业课外，还会涉及到研究方向的知识。而实践部分主要包括我们平常所参与的项目，以及为了应对笔试所进行的算法训练。可以看到，前期准备所涉及的内容不仅多而且杂，这意味着如果我们在准备时没有一个清晰的思路，会很容易陷入到混乱的状态。一种值得推荐的准备思路是<strong>先复习理论与实践部分的核心知识，即秋招过程中频繁考察的知识点，然后在此基础上逐步扩充外围知识。值得注意的是，在复习过程中应当着重梳理各个知识点间的逻辑，以减轻记忆的负担。</strong></p><h2 id="理论">理论</h2><h3 id="基础知识">基础知识</h3><h4 id="数据结构与算法">数据结构与算法</h4><p><img src="https://res.craft.do/user/full/1ae7c81f-976a-6137-e5f0-8e6e6e91b9f5/doc/73C7CEB7-7670-4319-ABF4-02469D939DEB/8A47974C-4B5F-4C3D-BA5E-0D8438E797E6_2/yyqVoNSAZlO5Mac76CjdKhHl0AjkbJtssfRAJc0rHuwz/8A47974C-4B5F-4C3D-BA5E-0D8438E797E6_2.png"></p><p>在准备基础知识的复习时，推荐从数据结构与算法部分开始。因为一旦完成数据结构与算法的复习，我们便可以开启算法题的训练。对于数据结构，复习的重点在于掌握栈、队列、散列表、二叉树和图的两种物理结构实现，即数组和链表结构。其中，对于栈、队列和散列表，我们在前期时可只掌握数组的实现方式，因为这种方式最常用。</p><p>对于算法，<strong>首先</strong>关注查找类的算法，这类算法的思想可以分为以下四种：</p><ol type="1"><li>若待查找记录未按关键字排序，可对这些待排序记录进行遍历查找</li><li>若记录已按关键字排序，则可对有序记录进行二路或多路查找</li><li>对于待查找的记录，通过哈希函数建立关键字到记录的映射关系，然后基于这种映射关系来查找。</li><li>若待查找记录未按关键字排序，可在关键字基础上建立有序的索引（本质上就是一种排序），然后对索引进行二路或多路查找。</li></ol><p>这四种思想结合不同逻辑或物理结构的数据则会出现不同的实现。例如，对于二路查找，如果数据按线性结构组织并以数组形式存储，则对应我们所熟知的二分查找，而如果是链式存储则为跳表。在复习查找类算法时，<strong>重点</strong>放在树和图的遍历算法上，并且了解查找树的分类和演变过程。除此之外，我们还需要了解常见的索引以及这些索引之间的区别。值得指的是，索引的内容与数据库存在重叠，可以关联学习。</p><p><strong>其次</strong>，我们需要关注排序类的算法，需重点掌握的算法已经用颜色进行标识。对于这些算法，我们需要了解其应用场景。例如，当需要稳定排序时应当使用何种排序算法？当待排序记录逆序时使用何种算法排序更快？</p><p><strong>最后</strong>，我们还需要着重关注字符串匹配、动态规划、贪心以及图的相关算法。值得说明的是，图的相关算法在秋招的笔试过程中出现频率相当高，因此一定要熟练掌握。</p><p>除了具体的算法实现外，在面试过程中，面试官或许还会问及算法的复杂度，因此复杂度的计算也得掌握。</p><p><strong>推荐阅读：</strong></p><blockquote><p>本指南涉及的网络资源将放入网盘进行共享，文章最后会给出链接。</p></blockquote><ol type="1"><li>大话数据结构——强烈推荐，书籍内部的逻辑性很强</li><li>轻松学算法</li></ol><h4 id="编程语言">编程语言</h4><p><img src="https://res.craft.do/user/full/1ae7c81f-976a-6137-e5f0-8e6e6e91b9f5/doc/73C7CEB7-7670-4319-ABF4-02469D939DEB/72F20720-2A40-48FC-888F-EEDE5A8C3904_2/bF6MmvPWhivHNf5xwX30OQsOtXpuizondaegaY4qEcIz/Java.png"></p><p>编程语言作为面试必考点也是复习的重中之重，由于我应聘时投递的岗位大多与Java语言相关，所以这一部分将介绍与Java相关的复习内容。这块的复习内容大概可以分为四块：</p><ul><li><p>Java基础</p><p>根据去年的经验，这一块内容问的相当少，可能现在人都很卷，八股文背的很溜，所以就不问太基础的了。</p></li><li><p>容器</p><p>主要考察的是思维导图上列出的这些容器类，除了需要掌握这些类之间的区别，还要掌握一些涉及源码的问题。例如，HashMap的底层数据结构、put和get过程等。</p></li><li><p>JVM</p><p>在复习时，我们首先需要弄清楚JVM的内存区域，然后进一步了解堆内存的分配和回收。关于内存回收，主要关心三个问题：</p><ul><li>如何判断对象是否需要回收，即如何判断对象已死？</li><li>具体的回收算法是怎样的？这些算法之间的演变过程是怎样的？</li><li>何时进行回收？哪些情况可以触发回收操作</li></ul><p>而对于分配过程，在堆内存分代的情况下，需要弄清JVM如何决定对象所属的代，以及代之间的转换规则。除此之外，我们还需关注JVM加载类的过程和双亲委托机制。</p></li><li><p>并发编程</p><p>这一块的内容是复习的难点，为了降低难度，我在初步的梳理后将这块内容划分为了五部分：</p><ul><li><p>并发编程基础：涉及线程的创建与使用，还有线程状态的转换</p></li><li><p>线程的管理：这一部分的内容主要是线程池，需要理解线程池的作用，并掌握线程池的使用，以及各项参数的含义</p><p>推荐阅读：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNTYwNjIzMTYxMzUy">线程池的使用🔗<i class="fa fa-external-link-alt"></i></span></p></li><li><p>线程的安全性：并发访问共享变量会带来安全问题，即程序的预期结果可能会与实际结果不一致。该问题是否出现与三种特性相关，即原子性、可见性和有序性。这一块的内容基本围绕这三种特性展开，复习重点在理解这三种特性为什么会导致安全性问题，以及相应的解决方案是什么？</p><p>推荐阅读：</p><ol type="1"><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81ODg1NTU5OQ==">Java并发之原子性、有序性、可见性<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9pa3JvYWwubm90aW9uLnNpdGUvZTU0YjcxNjU0NDU4NDVjNGIwYTQ5NmUzM2NiY2VjNjI=">对有序性的一些理解<i class="fa fa-external-link-alt"></i></span></li></ol></li><li><p>由保证安全性而带来的性能问题：保证线程安全性的一个方法是加锁，但加锁会影响程序的性能，所以这块的内容主要围绕着如何降低锁对程序的性能影响展开。这块的复习重点在弄清楚优化性能的各种方案，并了解各种锁之间的区别。</p><p>推荐阅读：<span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTgvMTEvMTUvamF2YS1sb2NrLmh0bWw=">不可不说的Java“锁”事<i class="fa fa-external-link-alt"></i></span></p></li><li><p>线程之间的协同：主要是一些工具类，明白这些工具类的区别就可以。</p></li></ul><p>上述内容介绍的是涉及Java的并发编程，但对于其它语言而言，一些框架性的内容也是适用的。例如，其它语言也会面临线程的管理以及安全性问题，并且与安全性相关的因素也会涉及原子性等。<strong>因此，我个人觉得并发编程这块的内容在复习其它编程语言时是可以借鉴的。</strong></p></li></ul><p><strong>推荐阅读：</strong></p><ol type="1"><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N5QzIwMTgvQ1MtTm90ZXM=">CS-Notes<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24v">JavaGuide<i class="fa fa-external-link-alt"></i></span></li><li>Java并发编程实战</li></ol><blockquote><p>1和2两个材料是大多数人的八股文来源，在记忆这些八股文时，我们应当提升思考的深度。即使大家都在背八股文，但我们也需要说出一些不一样的东西，以和其他人区分开来。例如，在考察并发编程的内容时，面试官或许会问及进程和线程的区别是什么？很多人会答进程的切换开销比线程的切换开销大，但并不会给出解释。此时，我们可以引申至内存地址转换上，进一步解释为什么进程开销会高于线程的切换开销，这样就能体现我们思考的深度。</p></blockquote><h4 id="操作系统">操作系统</h4><p><img src="https://res.craft.do/user/full/1ae7c81f-976a-6137-e5f0-8e6e6e91b9f5/doc/73C7CEB7-7670-4319-ABF4-02469D939DEB/713B728B-FCD6-469E-B536-DC3EB840AEB8_2/5FK2kdwxy8am6xw6Lb9NScsmYkWh5d2PAKS6CJ5MGZQz/713B728B-FCD6-469E-B536-DC3EB840AEB8_2.png"></p><p>操作系统这一块的内容也是考察比较多的，主要包括进程管理、内存管理、文件管理和设备管理。其中，<strong>进程管理和内存管理是考察的重点</strong>。对于进程管理而言，我们需要了解以下内容：</p><ul><li><p>进程的状态以及状态之间的转换条件</p></li><li><p>进程的调度算法：围绕提高系统的吞入量和保证响应速度这两个目标来理解调度算法的设计。</p></li><li><p>进程的协同：重点弄清楚通信和同步的方式，以及这些方式之间存在什么关系。此外，由于进程同步涉及加锁，还需要了解死锁的产生和解决方式。</p><p><strong>推荐阅读：</strong></p><ol type="1"><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDQ3MTM0NjM=">进程通信1<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNjUyMjQxNzU=">进程通信2<i class="fa fa-external-link-alt"></i></span></li></ol></li></ul><p>至于内存管理，我们可以从内存管理的三个目标（隔离、透明、效率）出发来了解内存管理技术的演变。在这一过程中，我们应当思考为什么要从直接操作物理内存转向虚拟内存？虚拟地址如何转化为实际的物理地址？连续分配虚拟内存会导致什么问题？分段是如何解决这一问题的？分页解决了分段的什么问题，以及产生了什么问题？能否获得超过物理内存的寻址空间？</p><p><strong>推荐阅读</strong>：操作系统导论</p><blockquote><p>操作系统导论这本书是目前我读过的最通俗易懂的操作系统书籍，在阅读内存管理相关章节时会给我一种娓娓道来的感觉。强烈推荐阅读这本书，你将从书中找到我上面提的所有问题的答案。</p></blockquote><h4 id="计算机网络">计算机网络</h4><p><img src="https://res.craft.do/user/full/1ae7c81f-976a-6137-e5f0-8e6e6e91b9f5/doc/73C7CEB7-7670-4319-ABF4-02469D939DEB/C32531A1-5353-4EF0-ADC8-8DD7BD440DD0_2/SR60kOamyy5aqewb8uYXf3jld80IKBjjZvy7yLgxgcEz/C32531A1-5353-4EF0-ADC8-8DD7BD440DD0_2.png"></p><p>计算机网络部分最频繁问及的内容可能是涉及TCP协议的内容。这块的内容我们可以从TCP本身的特性出来来理解它的内部逻辑，首先需要了解TCP是一种具备可靠传输特性的协议，并从这一特性出发来思考TCP如何从停等协议发展到连续ARQ协议。然后，我们需要了解连续ARQ协议存在什么问题？为什么TCP需要进行流量控制？在此基础之上，我们需要思考流量控制和拥塞控制的区别是什么？最后，我们还需要关注TCP建立和断开连接的过程，即三次握手和四次挥手。</p><p><strong>推荐阅读：</strong><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbFU1dVBmaEZFQ3JYLTBfaE1MOThCUQ==">这一篇TCP总结请收下<i class="fa fa-external-link-alt"></i></span></p><h4 id="数据库">数据库</h4><p>数据库这块的内容我当时复习的不多，大多数面试官在考察数据库时会涉及SQL语句的编写。但是如果你说平时接触不多，只会写简单的SQL语句而不会写复杂的，对方也会表示理解。所以，这一块的内容可能要求并不高。对于这块内容，我简单介绍一些当时了解的内容：</p><ul><li><p>基本的SQL语法和关系模型</p><p><strong>推荐阅读：</strong><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMDAyODY3Mg==">数据库第一二三范式到底在说什么？<i class="fa fa-external-link-alt"></i></span></p></li><li><p>事务处理相关：主要包括ACID和隔离级别等</p><p>这里简单梳理下ACID的逻辑，在ACID中，C是事务处理的目标，也即一个事务的执行最终要保证数据的一致性。导致不一致的原因有两种：多个事务之间的干扰；故障。要避免因事务之间的干扰而带来的不一致，数据库需要保证事务的隔离性（I）。而要避免故障带来的不一致，数据库需保证事务原子性（A）和持久性（D）。</p><p><strong>推荐阅读：</strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N5QzIwMTgvQ1MtTm90ZXMvYmxvYi9tYXN0ZXIvbm90ZXMvJUU2JTk1JUIwJUU2JThEJUFFJUU1JUJBJTkzJUU3JUIzJUJCJUU3JUJCJTlGJUU1JThFJTlGJUU3JTkwJTg2Lm1kIyVFNCVCQSU4QyVFNSVCOSVCNiVFNSU4RiU5MSVFNCVCOCU4MCVFOCU4NyVCNCVFNiU4MCVBNyVFOSU5NyVBRSVFOSVBMiU5OA==">事务处理<i class="fa fa-external-link-alt"></i></span></p></li><li><p>索引：一些常见的索引和适用场景。</p><p><strong>推荐阅读：</strong><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjc2NjQ1OQ==">索引的本质是排序<i class="fa fa-external-link-alt"></i></span></p></li></ul><h4 id="设计模式">设计模式</h4><p><img src="https://res.craft.do/user/full/1ae7c81f-976a-6137-e5f0-8e6e6e91b9f5/doc/73C7CEB7-7670-4319-ABF4-02469D939DEB/997C1756-D007-4E2E-B697-68FEDE26E980_2/SnxOVqr5mx3eqhS8AIUCuzNul5VbgfBISbJIYzeHB6Yz/997C1756-D007-4E2E-B697-68FEDE26E980_2.png"></p><p>设计模式这块考察很少，除非你简历上提及，否则面试官基本不会问。这块的内容建议在有空闲的情况下额外了解，并且选取一些设计模式的进行了解，而不需要全部了解。需要强调的是，作为经典且常见的设计模式，单例模式是必须了解的，并且要了解它的6种写法，以及其中一些写法存在的问题。</p><p>在前文中，我提及在复习过程中应当着重梳理各个知识点间的逻辑，但这样讲是不具体的，对于梳理知识点间的逻辑这件事是缺乏进一步解释的。接下来，我将以设计模式为例来进一步解释梳理逻辑这件事。</p><p>对于设计模式，其实我很早之前便了解到它分为三种模式，即创建型、结构型以及行为型。但是我一直是死记硬背的，而没有思考过为什么设计模式会分为这三种？为什么不是两种或四种。换句话说，这三种模式的关系是怎样的？在这次复习时，我发现了这块逻辑的缺失，所以针对性地对这个问题进行了思考。目前思考的结论是设计模式被划分为三种这件事与面向对象编程有关。设计模式的目的是希望通过一些模板来规范我们的编码方式，以产生更多易于维护的代码。当前，我们在编程时主要采用的面向对象的编程思想，那么设计模式在提供这些模板时势必会考虑到这一点。而在面向对象编程中，对象是绝对的核心，我们在编程过程中总不可避免的涉及到对象创建、组合与使用。所以，设计模式在提供模板时应该是从这个维度出发进行了拆解，最终形成了规范对象创建过程的创建型模式、对象组合的结构型模式以及对象使用的行为型模式。</p><p>借助上面的例子，我想表达的是在复习时如果发现一些内容需要死记硬背时，不妨问一下自己是不是有什么逻辑没有想清楚，是不是遗漏了什么问题。实际上，很多问题是值得思考的，例如，为什么隔离级别是四种。想清楚这些问题除了能加深我们的理解，还能让我们在面对面试官时回答出一些他从未听过的内容，这样能够提高印象分。</p><h3 id="领域知识">领域知识</h3><p>对于领域知识这块，由于大家的研究方向是不尽相同的，所以复习的内容存在很大差异。这也意味着指南的这块内容参考价值并不大。但考虑研究方向也可能重合，我还是决定简单介绍一下与分布式计算系统方向相关的复习内容，包括整体的复习框架以及一些常见的面试题。希望能为一些分布式计算系统方向的同学提供一些参考。</p><p>在复习分布式计算系统时，我主要复习了Hadoop、Spark和Flink等系统，每个系统大致包括四个部分：</p><ul><li><p>设计思想</p><p>这部分需要<strong>弄清楚系统解决了什么问题，采用了什么思想来解决这些问题</strong>。例如，对于构成Hadoop的文件系统HDFS，它需要解决大文件的存储、文件系统容错以及大文件的并发读写问题。在解决这些问题时，HDFS对大文件进行分块，以实现对逻辑层面的大文件进行物理存储。而为了防止分块数据丢失的问题，HDFS对分块进行了冗余存储。至于最后的大文件并发读写问题，由于HDFS的主要应用场景是读多写少的场景，所以HDFS通过一次写入多次读取的方式来避免读写冲突。</p></li><li><p>体系架构</p><p>体系架构部分需要弄清楚系统由哪些组件构成，各个组件的作用是什么？对于分布式计算系统而言，其组件的功能会涉及到作业管理和资源管理。作业管理主要包括任务分配、执行以及监控，而资源管理主要包括资源的监控和分配。</p><p>特别地，系统或许会有多种部署模式，不同模式会导致架构上的一些细微差异，因此需要弄清楚这些差异。例如，Spark会有Standalone和Yarn模式，并且每种模式还可以细分为Client和Cluster方式。此外，我们还需要弄清楚应用程序的执行流程，即提交一个作业后，组件是如何交互的。</p></li><li><p>工作原理</p><p>根据系统类型不同，工作原理的内容也会有所不同：</p><ul><li>对于HDFS而言，我们需要弄清楚它如何对文件进行分块以及如何选择分块的副本位置。另外，还需要熟悉其读写过程。</li><li>对于Yarn而言，主要需要了解它的三种资源分配策略</li><li>对于MapReduce、Spark以及Flink这类计算系统而言，我们需要弄清楚数据的输入、处理和输出过程。值得说明的，由于这类系统的处理过程通常由多个任务完成，这些任务间会存在数据传输，该过程会影响性能。所以，面试官很喜欢考察与数据传输相关的内容。例如，Spark的shuffle过程是怎样的？如果出现了数据倾斜该怎么优化？</li></ul></li><li><p>容错机制</p><p>对于容错机制，我们需要了解系统在组件发生故障后对组件所采取的恢复策略。进一步地，故障往往会导致计算结果丢失，如果不对其进行处理会导致计算结果不正确。因此，我们也需要了解保证结果正确性的相关机制。例如，Spark的RDD机制以及Flink的Chandy-Lamport算法。</p></li></ul><p>接下来，我列举一些秋招过程中接触的有代表性的面试题：</p><ul><li><p>Hadoop</p><ul><li>HDFS的原理，解决了什么问题？具体的方案是什么？</li><li>谈谈对Map/Reduce的理解，为什么一定要划分成两个阶段</li><li>Reduce如何确定要去哪些Mapper所在的节点去拉取数据</li><li>Yarn资源分配和应用启动</li></ul></li><li><p>Spark</p><ul><li><p>Spark三种算子（创建、转换、行动算子）的区别</p></li><li><p>Spark应用程序的执行过程，以及资源是如何分配的</p></li><li><p>Spark中宽依赖和窄依赖的区别是什么？</p></li><li><p>Spark的Shuffle过程，处理数据倾斜的方法</p><p><strong>推荐阅读：</strong></p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kYXRhZWxlbWVudC50b3AvMjAyMS8wMS8xOC9zcGFyay1zaHVmZmxlLWludGVybmFsLw==">Spark Shuffle Internal<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTYvMDUvMTIvc3BhcmstdHVuaW5nLXByby5odG1s">Spark性能优化指南——高级篇<i class="fa fa-external-link-alt"></i></span></li></ul></li></ul></li><li><p>Flink</p><ul><li>对于水位线的理解，为什么需要水位线？水位线是如何设置的？</li><li>Flink为什么会比Spark Streaming实时性更好？</li><li>Flink的检查点机制</li></ul></li></ul><h2 id="实践">实践</h2><h3 id="算法训练">算法训练</h3><p>对于算法题的训练，本人并非专业的ACM选手，也没有充足的时间来进行相关的训练和总结，所以我无法提供一些专业的意见，而只能从自身的经历出发来谈谈关于这件事的一些业余理解。如果你也是一名业余选手，希望这些理解能对你有一定的帮助</p><p>受到一些因素的影响，在秋招期间我实际能用于复习的时间仅仅只有一个多月，这使得我没有充足的时间来刷题。换句说话，我需要在有限的时间内尽可能提高解题能力。考虑再三后，我觉得大部分的算法题都是基础算法的变体，所以当时制定的策略是将基本算法弄熟，即数据结构与算法部分介绍的那些算法。然后，在这个基础上选择一些有代表性的题目来进行练习，比如LeetCode上的剑指Offer题库，用以检验是否掌握了这些算法的应用场景。此外，我也同步在看比较出名的刷题教程，<span class="exturl" data-url="aHR0cHM6Ly9sYWJ1bGFkb25nLmdpdGh1Yi5pby9hbGdvLw==">labuladong 的算法小抄<i class="fa fa-external-link-alt"></i></span>，来学习一些常见的解题技巧。通过上述的这些手段，在后续的笔试中，我虽然不能达到全AC的境界，但是却能通过大部分的笔试进入到面试环节。从这一点看，这也算是达到了我最初的目的。然而，我依然任务上述策略只是时间不充裕下的一种权宜之计，更可取的方法还是需要尽可能早的开始练习，并且采用像「<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVlZlRkNhb2hTZHpXVUNfQlFHbGhKZw==">如何科学的打开 Leetcode？<i class="fa fa-external-link-alt"></i></span>」这篇文章中所提及方法来刷题。</p><h3 id="项目梳理">项目梳理</h3><p>作为面试的重点，面试官往往会要求我们向他介绍所参与的项目，然后他会根据我们的描述和他的理解不断地抛出问题。在这个过程中，清晰地向面试官传达你对项目的理解是至关重要的，因为这体现了你的总结能力和沟通能力。</p><p>然而，我们在面试时难免会紧张，临场发挥很可能导致马失前蹄。因此，在梳理项目时，我认为是有必要通过一个框架来保证描述的逻辑性。一般来说，好的项目介绍需要包括三点：<strong>做了什么；为什么要做这件事情；以及这样做之后有什么效果</strong>。此外，对于缺乏你背景的面试官，你可能需要在介绍的开头插入一小段的背景介绍，以帮助面试官理解。注意不要太长，这样会让面试官觉得你很啰嗦。</p><p>除了上面提到的框架外，对于描述过程中出现的每个技术点，我们都需要有充足的了解。否则，面试官会怀疑这个项目是不是你做的，或者认为你的技术深度不够。</p><h1 id="简历制作与投递">简历制作与投递</h1><p>在完成一部分内容的复习后，我们应当制作自己的简历，并投递一些小公司的岗位来测试自己的复习效果。对于简历的制作，我们首先需要了解简历本身的意义，然后有针对性地完成制作过程。而对于岗位的投递，我们需要了解一些常见的投递渠道以及岗位选择所需考虑的因素。</p><h2 id="简历的意义">简历的意义</h2><p>在面试官对你进行面试之前，他唯一能够了解你的渠道便是简历。所以，简历实际上决定了面试官对你的第一印象。一个好的印象肯定会对面试有所帮助，那如何留下一个好的印象呢？我觉得可以从面试官的目的来考虑这件事情，面试官的目的肯定是希望招聘到一个能胜任岗位职责或者暂时不能胜任但有培养潜力的人。因此，我们制作简历时应当尽可能展示一些可以证明自己足够优秀的信息。例如，ACM的竞赛奖、好的实习经历等等。并且，对于这些信息，我们需要突出显示，以让面试官第一时间注意到。</p><h2 id="简历的内容">简历的内容</h2><p>一般来说，一份简历需要包括下列的信息：</p><ul><li><p>基本信息</p><p>基本信息包括姓名、年龄以及联系方式。此外，如果平时有写博客或者Github有好的项目，也可以放在这块。</p></li><li><p>教育经历</p><p>教育经历包括学校、学院和专业。此外，对于研究方向和学分绩排名也可以进行标注，前提是学分绩排名足够高。</p></li><li><p>实践经验</p><p>在介绍实践经验时，我们需要提供项目的起止时间、名称以及在此项目中承担的角色。然后，我们需要简略描述下这个项目做了啥以及我们在其中负责什么内容，取得了什么成果。注意，简历中的项目描述不要太长，因为太长的描述会让人失去了解的欲望，而且也会模糊其它部分的重要信息。</p></li><li><p>实习</p><p>实习这块主要介绍下时间、公司和岗位，然后说明下你参与了哪些项目，以及获得的成果。</p></li><li><p>奖项</p><p>将你获得的奖学金、各种竞赛成果写上去，但要注意竞赛成果是否有含金量。</p></li><li><p>专业技能</p><p>专业技能这块主要目的是向面试官展示你的技术栈。通过这块的内容，面试官不但可以判断你和这个岗位是否契合，还能在后续的面试中进行针对性的提问。在填写这块的内容时，我们需要确保填写的技术点是与岗位相关的，不要填写“会画画”这样的无关内容。此外，我们列出的技术点要是具体的，而不是宽泛的。例如，熟悉Java的并发编程技术会比熟悉Java更具体。值得说明的是，这块的内容不要太多，只需要列出五六项即可。</p></li></ul><p>下图提供了一个简历的示例，大家可以参考这个来制作简历，同时也不妨根据自己的想法来优化信息的描述和顺序。对于信息的描述，我们应尽可能的精简，以防简历超出一页。此外，我们还可以对一些信息加粗，以进行强调。而对于信息的排序，我们需要考虑哪些重要信息要优先呈现。例如，如果你有一段阿里的实习经历，那么就可以把实习经历放在教育背景下方。如果没有什么重要的奖项荣誉，则可以把这块内容放在最下方，弱化存在感。</p><blockquote><p>在后续的资源链接中，我会提供一些简历模板，大家可以自行取用。另外，大家也可以去<span class="exturl" data-url="aHR0cHM6Ly93d3cuNTAwZC5tZS8=">五百丁<i class="fa fa-external-link-alt"></i></span>这个网站在线制作自己的简历。</p></blockquote><blockquote><p>⚠️投递的简历请务必使用PDF格式。</p></blockquote><p><img src="https://res.craft.do/user/full/1ae7c81f-976a-6137-e5f0-8e6e6e91b9f5/doc/73C7CEB7-7670-4319-ABF4-02469D939DEB/D322A3AE-4122-4E54-9EA3-76FDBFED5F19_2/AlZhKFBPxuYWoNysAe2EbjwTOB0XRHLtexKav169uGkz/D322A3AE-4122-4E54-9EA3-76FDBFED5F19_2.jpeg"></p><h2 id="投递简历">投递简历</h2><p>制作完简历后，我们可以考虑去投递一些岗位了。在这里，我分享下常见的投递渠道、对于岗位选择的一些看法以及投递简历时一些隐藏的坑。</p><h3 id="投递渠道">投递渠道</h3><p>在去年投递的时候，我大概接触了下面四种投递渠道：</p><ul><li><p>直接投递</p><p>在投递之前，我们可以通过牛客网的<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2pvYnMvc2Nob29sL3NjaGVkdWxl">校招日程<i class="fa fa-external-link-alt"></i></span>这个网站或者是<strong>校招巴士</strong>这个公众号来了解哪些公司目前处于招聘状态，然后通过对应的官网直接投递自己的简历。但这种做法会存在不少的弊端，比如无法了解更为详细的进度信息、对于腾讯这样采用大类投递的公司无法控制自己应聘的具体部门。所以，直接投递这种方式更适合一些你不太在乎的公司。</p></li><li><p>校友内推</p><p>每年招聘季的时候都会很热闹，很多学院的校友都会通过辅导员发布招聘信息，这个时候你可以通过他们的渠道来投递简历，这种投递方式一般会将你的简历推到具体的某个部门。另外，如果你有内推人的联系方式，还可以让他帮你获取一些内部的处理动态，甚至在面试后帮你获取一些面评的信息。<strong>这种方式是最值得推荐的</strong>。</p></li><li><p>一些论坛找人内推</p><p>受到部门方向和部门工作地点的影响，我们也会遇到找不到校友内推的情况。此时，我们可以去牛客网和脉脉上搜索一些部门HR或者部门工程师发布的内推信息，然后通过他们将简历定向推送到希望进入的部门。<strong>这种方式与第二种方式一样值得推荐。</strong></p></li></ul><h3 id="岗位选择">岗位选择</h3><p>岗位的选择大致需要考虑这些因素：</p><ul><li><p>岗位方向</p><p>一般来说，我们最好选择与研究方向相匹配的岗位，这样会更有优势一些。当然，完全匹配只是一种理想情况，大多数情况下我们只要保证选择的岗位和我们的研究方向有关联即可。例如，我的研究方向是分布式图计算系统的容错技术，这个方向也会要求我学习其它的分布式计算系统。所以，我在投递简历的时候会投递分布式计算系统的开发工程师。</p></li><li><p>业务的核心度</p><p>在选择岗位时，要考虑所属部门业务的核心程度，企业的核心业务一般来说获得的资源会更多一些，而且遭遇大规模裁员的概率更低一些。这样对自己日后的发展也有保障。</p></li><li><p>招聘人数</p><p>有些企业在发布岗位时也会同步发布岗位的需求人数，此时，我们应该尽可能选择人数多一些的岗位。对于没有发布需求人数的岗位，如果你有熟悉的内推人，不妨打听一下。</p></li><li><p>城市</p><p>经过去年的教训之后，我觉得最好不要太过于拘泥于哪座城市，而是要更看重前三个因素。在去年秋招的过程中，我一直将自己的岗位所在地限制在珠三角，所以像京东、小米这些公司的招聘都无法参与。秋招还是得以拿到offer为第一目标，最好不要采取一些降低成功率的做法。这里再额外补充一个小点，选择岗位时最好是选择自己学校的影响力能覆盖到的区域，这样会降低你面试的难度。</p></li></ul><p>总的来说，选择岗位时要尽可能选择需求量大和与自己研究方向有关联的岗位，并且岗位最好属于核心部门。</p><h3 id="一些隐含的坑">一些隐含的坑</h3><p>有些公司会提供两次投递机会，例如，字节和OPPO，但是在投递时不要一次性投递两个岗位。如果一次性投递两个岗位，在你在走其中一个岗位的流程时，另一个岗位的流程会卡住。如果卡住太久，HR会直接结束掉这个岗位，这样会平白无故地失去一次投递机会。</p><p>在提前批时，许多公司会宣扬面试结果不会影响正式批的投递，但实际的情况是有些公司会有影响，例如，字节。因为面试记录都有存档，后面的面试官能看到你的面试记录。所以在投递时，最好多了解下，不要一不小心掉到坑里。</p><h1 id="应聘">应聘</h1><h2 id="笔试">笔试</h2><ul><li><p>素质评测</p><p>大部分公司都不会设置这个环节，不用刻意去准备，自由发挥就好。</p></li><li><p>算法题</p><p>算法题这个部分我简单说明一下存在的风险，在你提交代码后，许多公司会用代码检测系统来检测你和其它人的代码相似度。一般情况下，只要你自己写的代码，系统都不会判定为相似代码。然而，某些公司会出那种附带模板代码以及代码注释的算法题。一旦模板题是简单题，你的思路会很容易与他人重合，写出的代码就会存在一定的相似。在这种情况下，检测系统可能会将你的代码判定为相似代码，从而导致不可控事情的出现。去年在应聘腾讯TEG部门的网络研发部就因为这种情况被面试官搞了心态，这应该是整个秋招中最糟糕的一次面试体验了。<strong>所以，在做一些简单的模板题时，请尽可能删除模板代码上的注释，变量方法命名不要太常规，以避免被定位成相似代码，然后被怀疑作弊。</strong></p></li></ul><h2 id="面试">面试</h2><p>如果你投递的公司采用大类招聘，在接到<strong>第一次面试邀请</strong>时一定要问清楚部门，弄清楚和你的技术栈存不存在重叠。如果存在很大差异，最好不要接受面试邀请，因为你很大概率被刷，这样就浪费了一次机会。然后，你就只能泡池子，等人来捞你了。并且，如果你面试表现不好，还会影响到被其它部门捞简历的概率。</p><p>一旦接受了面试邀请，我们就需要准备一个固定的1-2分钟的自我介绍模板，随后的面试开场基本都是自我介绍。这份自我介绍模板需要介绍下自己的姓名、求学经历以及在这个过程中所取得的一些成绩。例如：我叫XXX，XXXX年毕业于A大学，本科学的是B专业。在XXXX年后，我来到了B大学，从事的研究方向是D。在这期间我参与了KKK项目，负责了系统代码的修改和论文的撰写，目前论文已经发表至E会议。</p><p>在大多数情况下，我们会经历三轮面试，这三轮的面试侧重点各有不同，我们可以根据这些来有针对性地进行复习。</p><ul><li><p>一轮</p><p>在大部分情况下，这一轮的面试官会是你未来的同事，他会考察你的理论知识，以确定你的基础是否牢固。所以，在准备第一轮面试时需要对高频的理论知识考点进行温习，例如，进程和线程的区别、TCP的三次握手和四次挥手等。</p></li><li><p>二轮</p><p>在考察基础知识后，二轮的面试通常会派出你未来的直接leader来考察你的项目，确定你的实战能力。所以在准备这一轮时需要对楚项目所涉及的知识点重新进行梳理，设想一些可能出现的问题。</p></li><li><p>三轮：</p><p>进入三轮之后，派出的面试官会是部门的总监，此时会考察你的思维方式、学习能力等软实力，设置的许多问题都是开放式的。对于这一轮，我只能说看造化。</p></li></ul><p>在三轮面试中，我们都会涉及到现场编码的环节，很多面试官会固定从几个题目中挑选出一个题目来考察我们。想要知道哪些考题是高频的，我们可以通过<span class="exturl" data-url="aHR0cHM6Ly9jb2RldG9wLmNjL2hvbWU=">CodeTop<i class="fa fa-external-link-alt"></i></span>这个网站来进行查询。根据我自己的经验来看，这个网站还是有作用的，因为我曾经通过这个网站压中过算法题。</p><h2 id="复盘">复盘</h2><p>在面试过程，我们会面对很多问题，这些问题有些是我们知道的，有些是我们不知道的。对于这些不知道的问题，在面试结束之后我们要及时记录，并查找到相关答案进行总结。然而，如果我们在面试结束后进行总结将会面临到一个问题，面试的时间过长会导致我们遗忘一些问题。所以，我建议如果面试时可以录音，不妨录下整个面试过程，这样能方便后续的总结。</p><h1 id="薪酬谈判与offer选择">薪酬谈判与Offer选择</h1><p>通常，我们在秋招的尾声会收获到很多Offer，后续我们会涉及到跟HR的谈薪问题以及Offer的选择问题。这里，我分享一下我的经验。</p><p>对于薪资的谈判，在你手握多个Offer的情况下，某一家公司会率先给你开出它的报价，这个时候你可以去跟其它公司进行沟通，告诉它们有一家公司已经给我开出了薪资，并向它们了解下上报的薪资。之后，这些公司的HR肯定会来和你沟通，询问那家公司给你开出的薪资是多少。此时，你不能报出确切的数字和详细的薪酬方案，一方面这是出于保密的义务，另一方面是掌握主动权。报出的数字可以适量的上浮一些，如果对方想争取你，自然就会为你争取这个薪资。另外，对于HR的一些话术我们需要提防。例如，HR可能会跟你说，这个城市的生活水准低一些，所以我们的报价会低一些。这个时候一定要守住自己底线，不要陷入话术。</p><p>而对于Offer的选择，我们需要从两个方面进行考虑：</p><ul><li><p>工作层面</p><p>这一层面主要涉及到平台、岗位方向以及薪资等。这三个因素，我会优先考虑岗位方向。在现在越来越卷的大环境下，我认为应当选择那种门槛相对比较高的，竞争没那么激烈的岗位。这样我们的未来发展会更持久。例如，我当时获得了大数据系统开发和数据库内核开发两种Offer，尽管我没有做过数据库内核开发。但是考虑到今年学院的数据库选手薪资都特别高，并且数据库内核开发的难度要高于大数据系统开发，再加之大数据系统开发有很多Java选手在卷。所以，我最终选择了数据库内核开发这个领域。</p><p>第二个考虑的因素是平台，平台越大，接触到牛人的机会越大，这样我们能进一步成长的可能性越大。</p><p>第三个考虑的则是薪资，在前两个因素大致对等的情况下，选薪资高的。</p></li><li><p>生活层面</p><p>生活层面主要考虑定居的问题，定居一方面需要考虑房价，另一方面还需要考虑离家的距离。当然，如果你有男（女）朋友，还得考虑下对方的意见。</p></li></ul><h1 id="一些题外话">一些题外话</h1><p>这份秋招指南原本计划是在去年年底完成的，然而在拖延症的作用下，直到今年四月份才彻底完稿。对于这件事是有些遗憾的，看来需要改进的地方还有很多。总的来说，这份指南基本上对我去年秋招过程中的所思所想做了一个总结，也可以算作对研究生生涯的一个告别。我终于将遗留的事情清理掉了，可以继续往前走了。希望这份指南能给后来参加秋招的你们带来一些帮助，也希望各位能拿到满意的Offer。</p><h1 id="复习材料与简历模板">复习材料与简历模板</h1><ol type="1"><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvcE1KZXhtU3Fydmo=">复习材料与简历模板<i class="fa fa-external-link-alt"></i></span></li></ol><hr><blockquote><p>如果文中的内容有误，请通过邮箱ikroal@outlook.com与我联系🙏</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://res.craft.do/user/full/1ae7c81f-976a-6137-e5f0-8e6e6e91b9f5/doc/73C7CEB7-7670-4319-ABF4-02469D939DEB/6EFFD135-4AFA-4BF9-A76B-F91EA95E78A9_2/yWysYTGUj3vBOWmlUTnH33agfGyXuYLwPWVPgPpO5jIz/IMG_20220224_111648.jpeg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Thinking" scheme="https://www.ikroal.cn/categories/Thinking/"/>
    
    
    <category term="summary" scheme="https://www.ikroal.cn/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>Giraph 运行流程（一）</title>
    <link href="https://www.ikroal.cn/posts/f82c45a5.html"/>
    <id>https://www.ikroal.cn/posts/f82c45a5.html</id>
    <published>2019-09-14T01:34:09.000Z</published>
    <updated>2021-12-24T05:57:00.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文主要分析了 Giraph1.3 SNAPSHOT 的 Job 提交和初始化的过程。其中 Job 提交部分的分析根据运行在 Standalone 模式下的 Hadoop 部分进行，分析仅涉及本地运行时执行的代码， 而初始化部分则主要根据集群模式进行分析。</p><span id="more"></span><h2 id="示例-job">示例 Job</h2><p>该部分不属于源码，而是为了方便分析运行的一个示例 Job，Job 的具体配置和运行在 <a href="/posts/72593b40.html" title="Giraph 编程实践及源码调试">Giraph 编程实践及源码调试</a> 一文中已经说明。通常情况下， Job 提交过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GiraphConfiguration conf = <span class="keyword">new</span> GiraphConfiguration(<span class="keyword">new</span> Configuration());</span><br><span class="line"><span class="comment">//指定计算类</span></span><br><span class="line">conf.setComputationClass(Shortestpath.class);</span><br><span class="line"><span class="comment">//设置输入和输出格式</span></span><br><span class="line">conf.setVertexInputFormatClass(JsonLongDoubleFloatDoubleVertexInputFormat.class);</span><br><span class="line">conf.setVertexOutputFormatClass(IdWithValueTextOutputFormat.class);</span><br><span class="line"><span class="comment">//设置本地运行模式，方便调试查看源码</span></span><br><span class="line">conf.setLocalTestMode(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//设置 Worker 配置</span></span><br><span class="line">conf.setWorkerConfiguration(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//本地模式下运行不分 Master 和 Worker</span></span><br><span class="line">GiraphConstants.SPLIT_Master_Worker.set(conf, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">GiraphJob job = <span class="keyword">new</span> GiraphJob(conf, Shortestpath.class.getSimpleName());</span><br><span class="line"><span class="comment">//设置输入和输出路径</span></span><br><span class="line">GiraphTextInputFormat.setVertexInputPath(conf, <span class="keyword">new</span> Path(INPUT_PATH));</span><br><span class="line">GiraphTextOutputFormat.setOutputPath(job.getInternalJob(), <span class="keyword">new</span> Path(OUTPUT_PATH));</span><br><span class="line">••••••</span><br><span class="line"><span class="comment">//向 Giraph 提交 Job</span></span><br><span class="line">job.run(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>首先指定一系列参数，然后调用 job.run(true) 向 Giraph 提交 Job</p><h2 id="giraph-向-hadoop-提交-job">Giraph 向 Hadoop 提交 Job</h2><p>Giraph 是基于 Hadoop 开发的，因此在向 Giraph 提交 Job 之后，Giraph 内部还会向 Hadoop 提交 Job。本部分主要分析 Giraph 如何向 Hadoop 提交 Job。首先查看 run 方法：</p><p>org.apache.giraph.job.GiraphJob#run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runs the actual graph application through Hadoop Map-Reduce.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> verbose If true, provide verbose output, false otherwise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if success, false otherwise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">run</span><span class="params">(<span class="keyword">boolean</span> verbose)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">  <span class="comment">//更改 Job 的 counter 数量限制</span></span><br><span class="line">  setIntConfIfDefault(<span class="string">&quot;mapreduce.job.counters.limit&quot;</span>, <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置 Giraph 中 Worker 或者 Master 内存上限</span></span><br><span class="line">  setIntConfIfDefault(<span class="string">&quot;mapred.job.map.memory.mb&quot;</span>, <span class="number">1024</span>);</span><br><span class="line">  setIntConfIfDefault(<span class="string">&quot;mapred.job.reduce.memory.mb&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Speculative execution doesn&#x27;t make sense for Giraph</span></span><br><span class="line">  giraphConfiguration.setBoolean(</span><br><span class="line">      <span class="string">&quot;mapred.map.tasks.speculative.execution&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the ping interval to 5 minutes instead of one minute</span></span><br><span class="line">  Client.setPingInterval(giraphConfiguration, <span class="number">60000</span> * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置优先使用用户上传的 Jar 包的 class</span></span><br><span class="line">  giraphConfiguration.setBoolean(<span class="string">&quot;mapreduce.user.classpath.first&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">  giraphConfiguration.setBoolean(<span class="string">&quot;mapreduce.job.user.classpath.first&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//不做 Checkpoint 的时候最大尝试数为 1，为了让不能恢复的 Job 更快的结束</span></span><br><span class="line">  <span class="keyword">if</span> (giraphConfiguration.getCheckpointFrequency() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> oldMaxTaskAttempts = giraphConfiguration.getMaxTaskAttempts();</span><br><span class="line">    giraphConfiguration.setMaxTaskAttempts(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    ••••••</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  ImmutableClassesGiraphConfiguration conf =</span><br><span class="line">      <span class="keyword">new</span> ImmutableClassesGiraphConfiguration(giraphConfiguration);</span><br><span class="line">  checkLocalJobRunnerConfiguration(conf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tryCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//默认是 org.apache.giraph.job.DefaultGiraphJobRetryChecker</span></span><br><span class="line">  GiraphJobRetryChecker retryChecker = conf.getJobRetryChecker();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ••••••</span><br><span class="line"></span><br><span class="line">    tryCount++;</span><br><span class="line">    <span class="comment">//创建一个 Hadoop Job</span></span><br><span class="line">    Job submittedJob = <span class="keyword">new</span> Job(conf, jobName);</span><br><span class="line">    <span class="keyword">if</span> (submittedJob.getJar() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      submittedJob.setJarByClass(getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Giraph 不需要执行 Reduce 任务</span></span><br><span class="line">    submittedJob.setNumReduceTasks(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//设置 Mapper</span></span><br><span class="line">    submittedJob.setMapperClass(GraphMapper.class);</span><br><span class="line">    <span class="comment">//设置输入格式</span></span><br><span class="line">    submittedJob.setInputFormatClass(BspInputFormat.class);</span><br><span class="line">    <span class="comment">//设置输出格式，默认情况是 org.apache.giraph.bsp.BspOutputFormat</span></span><br><span class="line">    submittedJob.setOutputFormatClass(</span><br><span class="line">        GiraphConstants.HADOOP_OUTPUT_FORMAT_CLASS.get(conf));</span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">//提交 Job </span></span><br><span class="line">    submittedJob.submit();</span><br><span class="line">    </span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">//获取 Job 运行结果</span></span><br><span class="line">    <span class="keyword">boolean</span> passed = submittedJob.waitForCompletion(verbose);</span><br><span class="line">    </span><br><span class="line">    ••••••</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果运行失败则会尝试重启 Job</span></span><br><span class="line">    <span class="keyword">if</span> (!passed) &#123;</span><br><span class="line">      <span class="comment">//默认情况（指没有指定 JobRetryChecker 情况）返回 null，即永远不会重启 Job</span></span><br><span class="line">      String restartFrom = retryChecker.shouldRestartCheckpoint(submittedJob);</span><br><span class="line">      <span class="keyword">if</span> (restartFrom != <span class="keyword">null</span>) &#123;</span><br><span class="line">        GiraphConstants.RESTART_JOB_ID.set(conf, restartFrom);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 Job 运行成功或者失败情况下不尝试重新运行（默认情况下永远不会尝试尝试重新运行）</span></span><br><span class="line">    <span class="keyword">if</span> (passed || !retryChecker.shouldRetry(submittedJob, tryCount)) &#123;</span><br><span class="line">      <span class="keyword">return</span> passed;</span><br><span class="line">    &#125;</span><br><span class="line">    •••••••</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run 方法中首先会对 Hadoop 和 Giraph 进行配置，然后创建一个 Hadoop Job 对象。在设置好 Hadoop Job 的 MapperClass 和输入输出格式等相关信息后，即会调用 submit 向 Hadoop 提交 Job。从代码中可以看到整个过程与提交普通的 Hadoop Job 基本无异。</p><h2 id="hadoop-内部运行">Hadoop 内部运行</h2><p>在 Giraph 调用 submit 向 Hadoop 提交 Job 之后，程序的运行就会进入到 Hadoop 内部，对于该部分主要需要了解 Hadoop 如何启动 Giraph 的 MapTask。</p><h3 id="内部提交-job">内部提交 Job</h3><p>org.apache.hadoop.mapreduce.Job#submit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">  ensureState(JobState.DEFINE);</span><br><span class="line">  <span class="comment">//设置用新的 API</span></span><br><span class="line">  setUseNewAPI();</span><br><span class="line">  connect();</span><br><span class="line">  <span class="keyword">final</span> JobSubmitter submitter = </span><br><span class="line">      getJobSubmitter(cluster.getFileSystem(), cluster.getClient());</span><br><span class="line">  <span class="comment">//提交 Job 到系统</span></span><br><span class="line">  status = ugi.doAs(<span class="keyword">new</span> PrivilegedExceptionAction&lt;JobStatus&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> JobStatus <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException, </span></span><br><span class="line"><span class="function">      ClassNotFoundException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> submitter.submitJobInternal(Job.<span class="keyword">this</span>, cluster);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  state = JobState.RUNNING;</span><br><span class="line">  ••••••</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>submit 方法内部会创建 JobSubmitter 对象，然后通过 submitJobInternal 方法进一步提交 Job。</p><p>org.apache.hadoop.mapreduce.JobSubmitter#submitJobInternal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JobStatus <span class="title">submitJobInternal</span><span class="params">(Job job, Cluster cluster)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ClassNotFoundException, InterruptedException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ••••••</span><br><span class="line"></span><br><span class="line">    Configuration conf = job.getConfiguration();</span><br><span class="line">    addMRFrameworkToDistributedCache(conf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得暂存目录， 默认情况下路径生成在 /tmp/hadoop/mapred/staging 下</span></span><br><span class="line">    Path jobStagingArea = JobSubmissionFiles.getStagingDir(cluster, conf);</span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">//生成 Job ID</span></span><br><span class="line">    JobID jobId = submitClient.getNewJobID();</span><br><span class="line">    <span class="comment">//设置 Job ID</span></span><br><span class="line">    job.setJobID(jobId);</span><br><span class="line">    <span class="comment">//获得提交 Job 的目录</span></span><br><span class="line">    Path submitJobDir = <span class="keyword">new</span> Path(jobStagingArea, jobId.toString());</span><br><span class="line">    JobStatus status = <span class="keyword">null</span>;</span><br><span class="line">    ••••••</span><br><span class="line">    </span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">//实际提交 Job</span></span><br><span class="line">    status = submitClient.submitJob(</span><br><span class="line">        jobId, submitJobDir.toString(), job.getCredentials());</span><br><span class="line">    ••••••</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 submitJobInternal 中，Hadoop 会通过 submitClient 实际提交 Job。submitClient 是一个 ClientProtocol 接口，其有两个实现，由于提交 Job 的时候 Hadoop 运行在 Standalone 模式下，所以这里 submitClient 的实现是 LocalJobRunner。</p><p><img src="/posts/f82c45a5/ClientProtocol.png"></p><h3 id="启动-maptask">启动 MapTask</h3><p>org.apache.hadoop.mapred.LocalJobRunner#submitJob</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> org.apache.hadoop.mapreduce.<span class="function">JobStatus <span class="title">submitJob</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    org.apache.hadoop.mapreduce.JobID jobid, String jobSubmitDir,</span></span></span><br><span class="line"><span class="params"><span class="function">    Credentials credentials)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Job job = <span class="keyword">new</span> Job(JobID.downgrade(jobid), jobSubmitDir);</span><br><span class="line">  job.job.setCredentials(credentials);</span><br><span class="line">  <span class="keyword">return</span> job.status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.apache.hadoop.mapred.LocalJobRunner.Job#Job</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(JobID jobid, String jobSubmitDir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ••••••</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>submitJob 内部会创建一个 Job 对象，这里的 Job 是继承了 <code>Thread</code> 的 LocalJobRunner 的内部类。通过构造方法可以知道，submitJob 在创建 Job 的同时也开启了线程，所以需要查看 Job#run 方法。</p><p>org.apache.hadoop.mapred.LocalJobRunner.Job#run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JobID jobId = profile.getJobID();</span><br><span class="line">    JobContext jContext = <span class="keyword">new</span> JobContextImpl(job, jobId);</span><br><span class="line">    </span><br><span class="line">    ••••••</span><br><span class="line"></span><br><span class="line">    Map&lt;TaskAttemptID, MapOutputFile&gt; mapOutputFiles =</span><br><span class="line">        Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;TaskAttemptID, MapOutputFile&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取需要执行的任务</span></span><br><span class="line">    List&lt;RunnableWithThrowable&gt; mapRunnables = getMapTaskRunnables(</span><br><span class="line">        taskSplitMetaInfos, jobId, mapOutputFiles);</span><br><span class="line">            </span><br><span class="line">    initCounters(mapRunnables.size(), numReduceTasks);</span><br><span class="line">    ExecutorService mapService = createMapExecutor();</span><br><span class="line">    <span class="comment">//运行任务</span></span><br><span class="line">    runTasks(mapRunnables, mapService, <span class="string">&quot;map&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">// delete the temporary directory in output directory</span></span><br><span class="line">    outputCommitter.commitJob(jContext);</span><br><span class="line">    status.setCleanupProgress(<span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    ••••••</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.apache.hadoop.mapred.LocalJobRunner.Job#getMapTaskRunnables</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;RunnableWithThrowable&gt; <span class="title">getMapTaskRunnables</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        TaskSplitMetaInfo [] taskInfo, JobID jobId,</span></span></span><br><span class="line"><span class="params"><span class="function">        Map&lt;TaskAttemptID, MapOutputFile&gt; mapOutputFiles)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numTasks = <span class="number">0</span>;</span><br><span class="line">    ArrayList&lt;RunnableWithThrowable&gt; list =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;RunnableWithThrowable&gt;();</span><br><span class="line">  <span class="comment">//生成对应数量的 MapTaskRunnable</span></span><br><span class="line">    <span class="keyword">for</span> (TaskSplitMetaInfo task : taskInfo) &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> MapTaskRunnable(task, numTasks++, jobId,</span><br><span class="line">        mapOutputFiles));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.apache.hadoop.mapred.LocalJobRunner.Job#runTasks</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTasks</span><span class="params">(List&lt;RunnableWithThrowable&gt; runnables,</span></span></span><br><span class="line"><span class="params"><span class="function">        ExecutorService service, String taskType)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//提交任务</span></span><br><span class="line">    <span class="keyword">for</span> (Runnable r : runnables) &#123;</span><br><span class="line">    service.submit(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    service.shutdown(); <span class="comment">// Instructs queue to drain.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for tasks to finish; do not use a time-based timeout.</span></span><br><span class="line">    <span class="comment">// (See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6179024)</span></span><br><span class="line">    LOG.info(<span class="string">&quot;Waiting for &quot;</span> + taskType + <span class="string">&quot; tasks&quot;</span>);</span><br><span class="line">    service.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">    <span class="comment">// Cancel all threads.</span></span><br><span class="line">    service.shutdownNow();</span><br><span class="line">    <span class="keyword">throw</span> ie;</span><br><span class="line">    &#125;</span><br><span class="line">    ••••••</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Job#run 方法应该主要关注 MapTaskRunnable 的生成和执行，可以看到 Hadoop 会通过 getMapTaskRunnables 方法根据分配的 Task 的数量生成对应数量的 MapTaskRunnable，然后会调用 runTasks 方法向线程池提交任务。</p><p>MapTaskRunnable 任务提交到线程池后继续关注 MapTaskRunnable#run 方法</p><p>org.apache.hadoop.mapred.LocalJobRunner.Job.MapTaskRunnable#run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ••••••</span><br><span class="line">      MapTask map = <span class="keyword">new</span> MapTask(systemJobFile.toString(), mapId, taskId,</span><br><span class="line">        info.getSplitIndex(), <span class="number">1</span>);</span><br><span class="line">      ••••••</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ••••••</span><br><span class="line">        map.run(localConf, Job.<span class="keyword">this</span>);</span><br><span class="line">        ••••••</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.storedException = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 MapTaskRunnable#run 中可以看到其创建了一个 MapTask 对象，并调用了 MapTask#run 方法。</p><p>org.apache.hadoop.mapred.MapTask#run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> JobConf job, <span class="keyword">final</span> TaskUmbilicalProtocol umbilical)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">//org.apache.hadoop.mapreduce.Job#submit 设置了 useNewApi，所以返回 true</span></span><br><span class="line">    <span class="keyword">boolean</span> useNewApi = job.getUseNewMapper();</span><br><span class="line"></span><br><span class="line">    ••••••</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useNewApi) &#123;</span><br><span class="line">        runNewMapper(job, splitMetaInfo, umbilical, reporter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runOldMapper(job, splitMetaInfo, umbilical, reporter);</span><br><span class="line">    &#125;</span><br><span class="line">    done(umbilical, reporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MapTask#run 中会调用 runNewMapper 方法，所以继续查看该方法</p><p>org.apache.hadoop.mapred.MapTask#runNewMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt; <span class="function"><span class="keyword">void</span> <span class="title">runNewMapper</span><span class="params">(<span class="keyword">final</span> JobConf job,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">final</span> TaskSplitIndex splitIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">final</span> TaskUmbilicalProtocol umbilical,</span></span></span><br><span class="line"><span class="params"><span class="function">                    TaskReporter reporter</span></span></span><br><span class="line"><span class="params"><span class="function">                    )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException,</span></span><br><span class="line"><span class="function">                             InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// make a task context so we can get the classes</span></span><br><span class="line">    org.apache.hadoop.mapreduce.TaskAttemptContext taskContext =</span><br><span class="line">        <span class="keyword">new</span> org.apache.hadoop.mapreduce.task.TaskAttemptContextImpl(job, </span><br><span class="line">                                                                    getTaskID(),</span><br><span class="line">                                                                    reporter);</span><br><span class="line">    <span class="comment">// 反射获取设置的 MapperClass 实例对象</span></span><br><span class="line">    org.apache.hadoop.mapreduce.Mapper&lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt; mapper =</span><br><span class="line">        (org.apache.hadoop.mapreduce.Mapper&lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt;)</span><br><span class="line">        ReflectionUtils.newInstance(taskContext.getMapperClass(), job);</span><br><span class="line"></span><br><span class="line">    ••••••</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Context</span></span><br><span class="line">    org.apache.hadoop.mapreduce.MapContext&lt;INKEY, INVALUE, OUTKEY, OUTVALUE&gt; </span><br><span class="line">    mapContext = </span><br><span class="line">        <span class="keyword">new</span> MapContextImpl&lt;INKEY, INVALUE, OUTKEY, OUTVALUE&gt;(job, getTaskID(), </span><br><span class="line">            input, output, </span><br><span class="line">            committer, </span><br><span class="line">            reporter, split);</span><br><span class="line"></span><br><span class="line">    org.apache.hadoop.mapreduce.Mapper&lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt;.Context </span><br><span class="line">        mapperContext = </span><br><span class="line">            <span class="keyword">new</span> WrappedMapper&lt;INKEY, INVALUE, OUTKEY, OUTVALUE&gt;().getMapContext(</span><br><span class="line">                mapContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ••••••</span><br><span class="line">        mapper.run(mapperContext);</span><br><span class="line">        ••••••</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ••••••</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MapTask#runNewMapper 方法中会通过反射创建设置的 MapperClass 的对象，即 org.apache.giraph.job.GiraphJob#run 中设定的 GraphMapper 类的对象。在获取到 GraphMapper 对象后，系统会调用其 run 方法，从而使得程序的执行进入到 Giraph 部分。</p><h2 id="giraph-执行-job">Giraph 执行 Job</h2><p>org.apache.giraph.graph.GraphMapper#run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// Notify the master quicker if there is Worker failure rather than</span></span><br><span class="line">    <span class="comment">// waiting for ZooKeeper to timeout and delete the ephemeral znodes</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        setup(context);</span><br><span class="line">        <span class="comment">//执行计算</span></span><br><span class="line">        <span class="keyword">while</span> (context.nextKeyValue()) &#123;</span><br><span class="line">        graphTaskManager.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清理</span></span><br><span class="line">        cleanup(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ••••••</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 GraphMapper#run 方法可以看到一个 Giraph Job 的执行能够分为三个过程：</p><ul><li>初始化</li><li>执行计算</li><li>清理</li></ul><p>下面针对初始化过程进行分析</p><h3 id="初始化">初始化</h3><p>org.apache.giraph.graph.GraphMapper#setup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// Execute all Giraph-related role(s) assigned to this compute node.</span></span><br><span class="line">  <span class="comment">// Roles can include &quot;Master,&quot; &quot;Worker,&quot; &quot;zookeeper,&quot; or . . . ?</span></span><br><span class="line">  graphTaskManager = <span class="keyword">new</span> GraphTaskManager&lt;I, V, E&gt;(context);</span><br><span class="line">  graphTaskManager.setup(</span><br><span class="line">    DistributedCache.getLocalCacheArchives(context.getConfiguration()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GraphMapper#setup 方法中会创建 GraphTaskManager 对象，并调用其 setup 方法</p><p>org.apache.giraph.graph.GraphTaskManager#setup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Path[] zkPathList)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    Configuration hadoopConf = context.getConfiguration();</span><br><span class="line">    <span class="comment">//初始化一些配置</span></span><br><span class="line">    conf = <span class="keyword">new</span> ImmutableClassesGiraphConfiguration&lt;I, V, E&gt;(hadoopConf);</span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">//从配置中读取 Zookeeper 的连接信息，没有提供外部 Zookeeper 情况下为空</span></span><br><span class="line">    String serverPortList = conf.getZookeeperList();</span><br><span class="line">    <span class="comment">//如果没有提供外部 Zookeeper 则需要自己启动 Zookeeper</span></span><br><span class="line">    <span class="keyword">if</span> (serverPortList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (startZooKeeperManager()) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// ZK connect/startup failed</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createZooKeeperCounter(serverPortList);</span><br><span class="line">    &#125;</span><br><span class="line">    ••••••</span><br><span class="line">    <span class="keyword">this</span>.graphFunctions = determineGraphFunctions(conf, zkManager);</span><br><span class="line">    <span class="keyword">if</span> (zkManager != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.graphFunctions.isMaster()) &#123;</span><br><span class="line">        <span class="comment">//将由 Master 创建的文件夹标记为删除，文件系统关闭时将会删除文件</span></span><br><span class="line">        zkManager.cleanupOnExit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初始化 BSP 服务</span></span><br><span class="line">        instantiateBspService();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ••••••</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GraphTaskManager#setup 方法主要做三件事：</p><ul><li>获取 Zookeeper 连接信息</li><li>决定进程的角色</li><li>初始化 BSP 服务</li></ul><h4 id="获取-zookeeper-连接信息">获取 Zookeeper 连接信息</h4><p>GraphTaskManager#setup 中会通过 conf.getZookeeperList() 获得 Zookeeper 的连接信息。如果提供了外部 Zookeeper 则直接返回连接信息，但如果没有提供外部 Zookeeper 时，getZookeeperList() 会返回空值。此时 GraphTaskManager#setup 会调用 startZooKeeperManager 方法在某一个 Task 启动 Zookeeper。</p><p>org.apache.giraph.graph.GraphTaskManager#startZooKeeperManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and configure ZooKeeperManager for this job. This will</span></span><br><span class="line"><span class="comment"> * result in a Giraph-owned Zookeeper instance, a connection to an</span></span><br><span class="line"><span class="comment"> * existing quorum as specified in the job configuration, or task failure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if this task should terminate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startZooKeeperManager</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    zkManager = <span class="keyword">new</span> ZooKeeperManager(context, conf);</span><br><span class="line">    context.setStatus(<span class="string">&quot;setup: Setting up Zookeeper manager.&quot;</span>);</span><br><span class="line">    zkManager.setup();</span><br><span class="line">    <span class="comment">//如果计算已经结束则不需要再启动 Zookeeper，</span></span><br><span class="line">    <span class="comment">//大部分情况应该会在没有提供外部 Zookeeper 且重启 Task 时候起作用</span></span><br><span class="line">    <span class="keyword">if</span> (zkManager.computationDone()) &#123;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zkManager.onlineZooKeeperServer();</span><br><span class="line">    <span class="comment">//更新 Zookeeper 连接信息，创建计数器</span></span><br><span class="line">    String serverPortList = zkManager.getZooKeeperServerPortString();</span><br><span class="line">    conf.setZookeeperList(serverPortList);</span><br><span class="line">    createZooKeeperCounter(serverPortList);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startZooKeeperManager 中首先会创建 ZooKeeperManager 对象，然后调用其 setup 方法</p><p>org.apache.giraph.zk.ZooKeeperManager#setup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    createCandidateStamp();</span><br><span class="line">    getZooKeeperServerList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZooKeeperManager#setup 方法中会首先调用 createCandidateStamp 方法</p><p>org.apache.giraph.zk.ZooKeeperManager#createCandidateStamp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a HDFS stamp for this task.  If another task already</span></span><br><span class="line"><span class="comment"> * created it, then this one will fail, which is fine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCandidateStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ••••••</span><br><span class="line">    fs.mkdirs(baseDirectory);</span><br><span class="line">    ••••••</span><br><span class="line">    fs.mkdirs(serverDirectory);</span><br><span class="line">    ••••••</span><br><span class="line">    <span class="keyword">if</span> (!fs.getFileStatus(baseDirectory).isDir()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">&quot;createCandidateStamp: &quot;</span> + baseDirectory +</span><br><span class="line">        <span class="string">&quot; is not a directory, but should be.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">//根据 hostname 和 taskPartition 生成文件名</span></span><br><span class="line">    Path myCandidacyPath = <span class="keyword">new</span> Path(</span><br><span class="line">        taskDirectory, myHostname +</span><br><span class="line">        HOSTNAME_TASK_SEPARATOR + taskPartition);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ••••••</span><br><span class="line">        fs.createNewFile(myCandidacyPath);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;createCandidateStamp: Failed (maybe previous task &quot;</span> +</span><br><span class="line">            <span class="string">&quot;failed) to create filestamp &quot;</span> + myCandidacyPath, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 createCandidateStamp 方法中，每个 Task 会根据自己的 hostname 和 taskPartition 在 _bsp/_defaultZkManagerDir/_task 下创建对应文件，这些文件将会在系统选择某个 Task 启动 Zookeeper 服务时用到。具体结果如下图所示：</p><p><img src="/posts/f82c45a5/Giraph-CandidateStamp.png"></p><p>图中 hostname 是 localhost 的原因在于，运行源码的时候 Hadoop 处于 Standalone 模式。</p><p>在 createCandidateStamp 执行完成之后，ZooKeeperManager#setup 会接着调用 getZooKeeperServerList</p><p>org.apache.giraph.zk.ZooKeeperManager#getZooKeeperServerList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getZooKeeperServerList</span><span class="params">()</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">      InterruptedException </span>&#123;</span><br><span class="line">    String serverListFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//taskPartition 为 0 的 Task 会创建 zooKeeperServerList </span></span><br><span class="line">    <span class="keyword">if</span> (taskPartition == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//0 号 Task 如果重启检查到已经有 serverList 则不会重新创建</span></span><br><span class="line">      serverListFile = getServerListFile();</span><br><span class="line">      <span class="keyword">if</span> (serverListFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建 serverList</span></span><br><span class="line">        createZooKeeperServerList();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//其余 Task 等待 serverList 的创建</span></span><br><span class="line">      serverListFile = getServerListFile();</span><br><span class="line">      ••••••</span><br><span class="line">      <span class="keyword">if</span> (serverListFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//减少 CPU 的占用</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(pollMsecs);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;getZooKeeperServerList: Strange interrupted &quot;</span> +</span><br><span class="line">            <span class="string">&quot;exception &quot;</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析 serverList 中的信息</span></span><br><span class="line">    String[] serverHostList = serverListFile.substring(</span><br><span class="line">        ZOOKEEPER_SERVER_LIST_FILE_PREFIX.length()).split(</span><br><span class="line">            HOSTNAME_TASK_SEPARATOR);</span><br><span class="line">    ••••••</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得 Zookeeper 服务所在节点的 hostname</span></span><br><span class="line">    zkServerHost = serverHostList[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//获得应该启动 Zookeeper 服务的 Task 的 taskPartition</span></span><br><span class="line">    zkServerTask = Integer.parseInt(serverHostList[<span class="number">1</span>]);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//各个 Task 更新自己的 zkServerPortString</span></span><br><span class="line">    updateZkPortString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>getZooKeeperServerList 方法会根据 taskPartition 进行判断，如果是 0 号 Task 则会先调用 createZooKeeperServerList 创建 serverListFile（serverListFile 表明了 Zookeeper 服务所在的 hostname 和 taskPartition），而如果是非 0 号 Task 则会进行轮询来获取 serverListFile 的文件名。在获取到文件名后会对其进行解析来更新 zkServerHost、zkServerTask 以及 zkServerPortString。</p><p>接下来会对 createZooKeeperServerList 和 getZooKeeperServerList 进行分析以便更好的理解系统如何选取启动 Zookeeper 服务的 Task</p><ul><li><p>org.apache.giraph.zk.ZooKeeperManager#createZooKeeperServerList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createZooKeeperServerList</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">  String host;</span><br><span class="line">  String task;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">//返回 Task 下文件的元数据，会有一个文件名格式校验的过程，会去掉以 . 开头和 crc 结尾文件</span></span><br><span class="line">    FileStatus [] fileStatusArray = fs.listStatus(taskDirectory);</span><br><span class="line">    <span class="keyword">if</span> (fileStatusArray.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//选取第一位的元数据标识的 Task 去启动 Zookeeper 服务</span></span><br><span class="line">      FileStatus fileStatus = fileStatusArray[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">//解析信息</span></span><br><span class="line">      String[] hostnameTaskArray =</span><br><span class="line">          fileStatus.getPath().getName().split(</span><br><span class="line">              HOSTNAME_TASK_SEPARATOR);</span><br><span class="line">      ••••••</span><br><span class="line">      host = hostnameTaskArray[<span class="number">0</span>];</span><br><span class="line">      task = hostnameTaskArray[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(pollMsecs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据解析的信息生成 serverListFile 文件名</span></span><br><span class="line">  String serverListFile =</span><br><span class="line">      ZOOKEEPER_SERVER_LIST_FILE_PREFIX + host +</span><br><span class="line">      HOSTNAME_TASK_SEPARATOR + task;</span><br><span class="line">  Path serverListPath =</span><br><span class="line">      <span class="keyword">new</span> Path(baseDirectory, serverListFile);</span><br><span class="line">  ••••••</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建文件</span></span><br><span class="line">  fs.createNewFile(serverListPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createZooKeeperServerList 中会获取所有 Task 在 createCandidateStamp 方法中创建的文件的文件名，然后选取返回数组中第一个元素标识的 Task 信息去创建 serverListFile。</p></li><li><p>org.apache.giraph.zk.ZooKeeperManager#getServerListFile</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getServerListFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  String serverListFile = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//baseDirectory 是 _bsp/_defaultZkManagerDir，列出文件夹下的文件元数据</span></span><br><span class="line">  FileStatus [] fileStatusArray = fs.listStatus(baseDirectory);</span><br><span class="line">  <span class="keyword">for</span> (FileStatus fileStatus : fileStatusArray) &#123;</span><br><span class="line">    <span class="comment">//筛选文件名中含有 zkServerList_ 的文件，即 taskpartition 为 0 task 创建的 serverListFile</span></span><br><span class="line">    <span class="keyword">if</span> (fileStatus.getPath().getName().startsWith(</span><br><span class="line">        ZOOKEEPER_SERVER_LIST_FILE_PREFIX)) &#123;</span><br><span class="line">      serverListFile = fileStatus.getPath().getName();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> serverListFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getServerListFile 会获取 baseDirectory 下的文件元数据，然后筛选出对应的 serverListFile，最后返回其文件名。</p></li></ul><p>接着回到 startZooKeeperManager 方法中，在选定了启动 Zookeeper 服务的 Task 后，系统会首先判断计算是否完成，如果已经完成则表明无需再继续运行。否则会调用 onlineZooKeeperServer 方法启动 Zookeeper 服务。</p><p>org.apache.giraph.zk.ZooKeeperManager#onlineZooKeeperServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onlineZooKeeperServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//如果当前 task 的 taskPartition 等于 zkServerTask，则需要启动 Zookeeper 服务 </span></span><br><span class="line">  <span class="keyword">if</span> (zkServerTask == taskPartition) &#123;</span><br><span class="line">    File zkDirFile = <span class="keyword">new</span> File(<span class="keyword">this</span>.zkDir);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//删除旧的文件夹</span></span><br><span class="line">      ••••••</span><br><span class="line">      FileUtils.deleteDirectory(zkDirFile);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      ••••••</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成 Zookeeper 配置</span></span><br><span class="line">    generateZooKeeperConfig();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      zkRunner = createRunner();</span><br><span class="line">      <span class="comment">//启动 Zookeeper 服务</span></span><br><span class="line">      <span class="keyword">int</span> port = zkRunner.start(zkDir, config);</span><br><span class="line">      <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        zkBasePort = port;</span><br><span class="line">        updateZkPortString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once the server is up and running, notify that this server is up</span></span><br><span class="line">    <span class="comment">// and running by dropping a ready stamp.</span></span><br><span class="line">    <span class="keyword">int</span> connectAttempts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxConnectAttempts =</span><br><span class="line">        conf.getZookeeperConnectionAttempts();</span><br><span class="line">    <span class="keyword">while</span> (connectAttempts &lt; maxConnectAttempts) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ••••••</span><br><span class="line">        <span class="comment">//连接 Zookeeper 服务</span></span><br><span class="line">        InetSocketAddress zkServerAddress =</span><br><span class="line">            <span class="keyword">new</span> InetSocketAddress(myHostname, zkBasePort);</span><br><span class="line">        Socket testServerSock = <span class="keyword">new</span> Socket();</span><br><span class="line">        testServerSock.connect(zkServerAddress, <span class="number">5000</span>);</span><br><span class="line">        ••••••</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;onlineZooKeeperServers: Got &quot;</span> +</span><br><span class="line">            <span class="string">&quot;SocketTimeoutException&quot;</span>, e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;onlineZooKeeperServers: Got &quot;</span> +</span><br><span class="line">            <span class="string">&quot;ConnectException&quot;</span>, e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;onlineZooKeeperServers: Got &quot;</span> +</span><br><span class="line">            <span class="string">&quot;IOException&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ++connectAttempts;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(pollMsecs);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;onlineZooKeeperServers: Sleep of &quot;</span> + pollMsecs +</span><br><span class="line">            <span class="string">&quot; interrupted - &quot;</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超过最大的尝试数，连接失败</span></span><br><span class="line">    <span class="keyword">if</span> (connectAttempts == maxConnectAttempts) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">&quot;onlineZooKeeperServers: Failed to connect in &quot;</span> +</span><br><span class="line">              connectAttempts + <span class="string">&quot; tries!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Path myReadyPath = <span class="keyword">new</span> Path(</span><br><span class="line">        serverDirectory, myHostname +</span><br><span class="line">        HOSTNAME_TASK_SEPARATOR + taskPartition +</span><br><span class="line">        HOSTNAME_TASK_SEPARATOR + zkBasePort);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ••••••</span><br><span class="line">      <span class="comment">//创建文件表明 Zookeeper 服务已经准备好，并且提供连接的信息</span></span><br><span class="line">      fs.createNewFile(myReadyPath);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      ••••••</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//其余 Task 等待 Zookeeper 服务的启动</span></span><br><span class="line">    <span class="keyword">int</span> readyRetrievalAttempt = <span class="number">0</span>;</span><br><span class="line">    String foundServer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        FileStatus [] fileStatusArray =</span><br><span class="line">            fs.listStatus(serverDirectory);</span><br><span class="line">        <span class="comment">//检查 serverDirectory 文件夹下是否生成了 Zookeeper 连接信息文件</span></span><br><span class="line">        <span class="keyword">if</span> ((fileStatusArray != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">            (fileStatusArray.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="comment">//解析文件中的连接信息</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileStatusArray.length; ++i) &#123;</span><br><span class="line">            String[] hostnameTaskArray =</span><br><span class="line">                fileStatusArray[i].getPath().getName().split(</span><br><span class="line">                    HOSTNAME_TASK_SEPARATOR);</span><br><span class="line">            <span class="keyword">if</span> (hostnameTaskArray.length != <span class="number">3</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                  <span class="string">&quot;getZooKeeperServerList: Task 0 failed &quot;</span> +</span><br><span class="line">                      <span class="string">&quot;to parse &quot;</span> +</span><br><span class="line">                      fileStatusArray[i].getPath().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//zookeeper 服务所在地址</span></span><br><span class="line">            foundServer = hostnameTaskArray[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//zookeeper 服务的连接端口</span></span><br><span class="line">            zkBasePort = Integer.parseInt(hostnameTaskArray[<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">//更新 zookeeper 的连接信息</span></span><br><span class="line">            updateZkPortString();</span><br><span class="line">          &#125;</span><br><span class="line">          ••••••</span><br><span class="line">          <span class="comment">//查看 hostname 是否相同，相同则跳出等待，具体场景尚未想到</span></span><br><span class="line">          <span class="keyword">if</span> (zkServerHost.equals(foundServer)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ••••••</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(pollMsecs);</span><br><span class="line">        ++readyRetrievalAttempt;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        ••••••</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 onlineZooKeeperServer 实际做了两件事情：一是在选定的 Task 上启动 Zookeeper 服务，并创建文件表明服务已经准备好。二是所有未启动 Zookeeper 服务的 Task 去更新 Zookeeper 的连接信息。</p><h4 id="分配角色">分配角色</h4><p>在启动完成 Zookeeper 服务之后系统会更新 Zookeeper 相关的配置信息然后返回到 org.apache.giraph.graph.GraphTaskManager#setup 方法中，之后会调用 determineGraphFunctions</p><p>org.apache.giraph.graph.GraphTaskManager#determineGraphFunctions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> GraphFunctions <span class="title">determineGraphFunctions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  ImmutableClassesGiraphConfiguration conf,</span></span></span><br><span class="line"><span class="params"><span class="function">  ZooKeeperManager zkManager)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断是本地模式还是集群模式，本地模式只会启动一个 Task</span></span><br><span class="line">  <span class="keyword">boolean</span> splitMasterWorker = conf.getSplitMasterWorker();</span><br><span class="line">  <span class="comment">//获取当前 Task 的 taskPartition</span></span><br><span class="line">  <span class="keyword">int</span> taskPartition = conf.getTaskPartition();</span><br><span class="line">  <span class="comment">//判断是否提供了外部的 Zookeeper</span></span><br><span class="line">  <span class="keyword">boolean</span> zkAlreadyProvided = conf.isZookeeperExternal();</span><br><span class="line">  <span class="comment">//初始时刻 Task 的角色</span></span><br><span class="line">  GraphFunctions functions = GraphFunctions.UNKNOWN;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!splitMasterWorker) &#123;</span><br><span class="line">    <span class="comment">//本地模式下如果是内部启动 Zookeeper 则 Task 充当所有的角色，否则充当 Master 和 Worker</span></span><br><span class="line">    <span class="keyword">if</span> ((zkManager != <span class="keyword">null</span>) &amp;&amp; zkManager.runsZooKeeper()) &#123;</span><br><span class="line">      functions = GraphFunctions.ALL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      functions = GraphFunctions.ALL_EXCEPT_ZOOKEEPER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (zkAlreadyProvided) &#123;</span><br><span class="line">      <span class="comment">//如果有外部 Zookeeper 则 0 号 Task 就是 Master，其余的都是 Worker</span></span><br><span class="line">      <span class="keyword">if</span> (taskPartition == <span class="number">0</span>) &#123;</span><br><span class="line">        functions = GraphFunctions.Master_ONLY;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        functions = GraphFunctions.Worker_ONLY;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果是内部启动的 Zookeeper 服务，</span></span><br><span class="line">      <span class="comment">//则启动 Zookeeper 服务的 Task 充当 Master 和 zookeeper 角色，其余为 Worker</span></span><br><span class="line">      <span class="keyword">if</span> ((zkManager != <span class="keyword">null</span>) &amp;&amp; zkManager.runsZooKeeper()) &#123;</span><br><span class="line">        functions = GraphFunctions.Master_ZOOKEEPER_ONLY;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        functions = GraphFunctions.Worker_ONLY;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> functions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>determineGraphFunctions 主要是对 Task 的角色进行判断，系统提供了 6 种角色：</p><ul><li><p>UNKNOWN</p><p>表明 Task 的角色还未知</p></li><li><p>Master_ONLY</p><p>表明 Task 是 Master</p></li><li><p>Master_ZOOKEEPER_ONLY</p><p>表明 Task 既是 Master 也是 Zookeeper</p></li><li><p>Worker_ONLY</p><p>表明 Task 只是 Worker</p></li><li><p>ALL</p><p>表明 Task 既是 Master 也是 Worker 和 Zookeeper</p></li><li><p>ALL_EXCEPT_ZOOKEEPER</p><p>表明 Task 既是 Master 也是 Worker</p></li></ul><h4 id="初始化-bsp">初始化 BSP</h4><p>在决定各个 Task 的角色之后，系统会调用 instantiateBspService 初始化 BSP 服务。</p><p>org.apache.giraph.graph.GraphTaskManager#instantiateBspService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">instantiateBspService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (graphFunctions.isMaster()) &#123;</span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">//创建 Master 对象</span></span><br><span class="line">    serviceMaster = <span class="keyword">new</span> BspServiceMaster&lt;I, V, E&gt;(context, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//Master 运行在线程里面</span></span><br><span class="line">    MasterThread = <span class="keyword">new</span> MasterThread&lt;I, V, E&gt;(serviceMaster, context);</span><br><span class="line">    MasterThread.setUncaughtExceptionHandler(</span><br><span class="line">        createUncaughtExceptionHandler());</span><br><span class="line">    MasterThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (graphFunctions.isWorker()) &#123;</span><br><span class="line">    ••••••</span><br><span class="line">    <span class="comment">//创建 Worker 对象</span></span><br><span class="line">    serviceWorker = <span class="keyword">new</span> BspServiceWorker&lt;I, V, E&gt;(context, <span class="keyword">this</span>);</span><br><span class="line">    installGCMonitoring();</span><br><span class="line">    ••••••</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instantiateBspService 中对于 Master 主要是创建 serviceMaster 对象，然后启动 MasterThread 线程，对于 Worker 则是创建 serviceWorker 对象。</p><h2 id="总结">总结</h2><p>总的来说，Giraph 的 Job 提交和初始化依据以下流程来执行：</p><ol type="1"><li>用户向 Giraph 提交 Job</li><li>Giraph 向 Hadoop 提交 Job</li><li>Hadoop 启动 MapTask，并执行 GraphMapper 的 run 方法</li><li>GraphMapper 创建 GraphTaskManager 对象进行初始化</li><li>初始化过程首先获取 Zookeeper 连接信息，如果没有外置 Zookeeper 则需要从所有 MapTask 中进行选取 Task 来启动 Zookeeper 服务。</li><li>获取到 Zookeeper 连接信息之后会根据 determineGraphFunctions 分配角色，由此区分 MapTask 中的 Master 和 Worker</li><li>分配完角色之后则会通过 instantiateBspService 来初始化 BSP 服务，由此结束整个初始化过程。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要分析了 Giraph1.3 SNAPSHOT 的 Job 提交和初始化的过程。其中 Job 提交部分的分析根据运行在 Standalone 模式下的 Hadoop 部分进行，分析仅涉及本地运行时执行的代码， 而初始化部分则主要根据集群模式进行分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Giraph" scheme="https://www.ikroal.cn/categories/Giraph/"/>
    
    
    <category term="SourceCode Analysis" scheme="https://www.ikroal.cn/tags/SourceCode-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Giraph 编程实践及源码编译调试</title>
    <link href="https://www.ikroal.cn/posts/72593b40.html"/>
    <id>https://www.ikroal.cn/posts/72593b40.html</id>
    <published>2019-09-07T00:36:03.000Z</published>
    <updated>2021-12-24T05:57:00.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文主要总结了如何利用 Giraph 提供的 API 实现图计算编程，并说明了将 Giraph 源码导入 IDEA 进行调试的过程。</p><span id="more"></span><h2 id="编程实践">编程实践</h2><p>本部分通过实现最短路径算法说明 Giraph 的编程流程</p><ol type="1"><li><p>创建 Maven 工程</p><p><img src="/posts/72593b40/maven-1.png"></p><p><img src="/posts/72593b40/maven-2.png"></p></li><li><p>添加相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--添加 Giraph 依赖--&gt;</span>&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.giraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>giraph-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0-hadoop2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加 Hadoop 依赖--&gt;</span>&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建 ShortestPathComputation 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.giraph.edge.Edge;</span><br><span class="line"><span class="keyword">import</span> org.apache.giraph.graph.BasicComputation;</span><br><span class="line"><span class="keyword">import</span> org.apache.giraph.graph.Vertex;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.DoubleWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.FloatWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestPathComputation</span> <span class="keyword">extends</span> <span class="title">BasicComputation</span>&lt;<span class="title">LongWritable</span>, <span class="title">DoubleWritable</span>,</span></span><br><span class="line"><span class="class">        <span class="title">FloatWritable</span>, <span class="title">DoubleWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要计算最短路径的源顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOURCE_VERTEX = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示节点不可达</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> UNREACHABLE = Double.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> vertex 待处理的顶点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> messages vertex 接收到的来自其余顶点的 message</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">(Vertex&lt;LongWritable, DoubleWritable, FloatWritable&gt; vertex,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Iterable&lt;DoubleWritable&gt; messages)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getSuperstep() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//超步 0 时源顶点最短路径设置为 0，其余顶点设置为不可达，并且源顶点需要向其它顶点发送最短距离message</span></span><br><span class="line">            <span class="keyword">if</span> (vertex.getId().get() == SOURCE_VERTEX) &#123;</span><br><span class="line">                vertex.setValue(<span class="keyword">new</span> DoubleWritable(<span class="number">0</span>));</span><br><span class="line">                sendDist(vertex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vertex.setValue(<span class="keyword">new</span> DoubleWritable(UNREACHABLE));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历处理从其余顶点收到的 message，</span></span><br><span class="line">            <span class="comment">// 查看 message 中传递的最短距离是否小于当前的最短距离，如果是则进行更新</span></span><br><span class="line">            <span class="keyword">for</span> (DoubleWritable message : messages) &#123;</span><br><span class="line">                <span class="keyword">if</span> (message.get() &lt; vertex.getValue().get()) &#123;</span><br><span class="line">                    vertex.setValue(message);</span><br><span class="line">                    sendDist(vertex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主动将顶点置于不活跃状态，如果顶点收到 message，系统会将顶点再度激活</span></span><br><span class="line">        vertex.voteToHalt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送顶点 vertex 到其邻接顶点的最短距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendDist</span><span class="params">(Vertex&lt;LongWritable,</span></span></span><br><span class="line"><span class="params"><span class="function">            DoubleWritable, FloatWritable&gt; vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;LongWritable, FloatWritable&gt; edge : vertex.getEdges()) &#123;</span><br><span class="line">            <span class="keyword">double</span> distance = vertex.getValue().get() + edge.getValue().get();</span><br><span class="line">            sendMessage(edge.getTargetVertexId(), <span class="keyword">new</span> DoubleWritable(distance));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShortestPathComputation 继承了 BasicComputation，对于 BasicComputation 中指定的四个类型参数，其含义依次为</p><ul><li><p>Vertex id</p></li><li><p>Vertex data</p></li><li><p>Edge data</p></li><li><p>Message</p></li></ul><p>整个计算的过程可以总结为：</p><ol type="1"><li>Superstep 0 的时候进行初始化，然后源头顶点向邻接顶点发送可能的最短路径 message</li><li>下一 Superstep 邻接顶点处理接收到的 message 然后和顶点值进行比较，如果 message 小于顶点值则对顶点值进行更新，并向邻接顶点发送可能的最短路径 message。</li><li>重复 <code>2</code> 直到所有的顶点处于不活跃状态，最后结束计算进行输出。</li></ol></li><li><p>提交验证</p><p>验证部分基于 Pseudo-Distributed 模式的 Hadoop 进行</p><ul><li><p>上传测试文件到 HDFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$HADOOP_HOME/<span class="built_in">bin</span>/hdfs dfs -put giraph_data.txt &lt;your_input_path&gt;/shortestpath</span><br><span class="line"><span class="comment">#giraph_data 中的数据，格式为 [source_id,source_value,[[dest_id, edge_value],...]]，</span></span><br><span class="line"><span class="comment"># 如 [0,0,[[1,1],[3,3]]] 表示顶点序号为 0，顶点值为 0，存在序号 0 到 序号 1 的边，值为 1，存在序号 0 到序号 3 的边，值为 3。</span></span><br><span class="line">[<span class="number">0</span>,<span class="number">100</span>,[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">3</span>]]]</span><br><span class="line">[<span class="number">1</span>,<span class="number">20</span>,[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>]]]</span><br><span class="line">[<span class="number">2</span>,<span class="number">90</span>,[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">4</span>]]]</span><br><span class="line">[<span class="number">3</span>,<span class="number">50</span>,[[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">4</span>]]]</span><br><span class="line">[<span class="number">4</span>,<span class="number">80</span>,[[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>]]]</span><br></pre></td></tr></table></figure></li><li><p>将工程打包为 jar 文件，并提交到 Hadoop</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">HADOOP_HOME/bin/hadoop jar Examples.jar org.apache.giraph.GiraphRunner com.ikroal.shortestpath.ShortestPathComputation -vif org.apache.giraph.io.formats.JsonLongDoubleFloatDoubleVertexInputFormat -vip &lt;your_input_path&gt;/giraph_data.txt -vof org.apache.giraph.io.formats.IdWithValueTextOutputFormat -op &lt;your_output&gt;/shortestpaths -w 1</span></span><br></pre></td></tr></table></figure><p>提交任务的过程基本与一般的提交过程一致，只是还额外指定了 Giraph 运行所需要的参数，对于相关参数的解释请参考 <a href="/posts/a2b96c30.html" title="Giraph 环境搭建">Giraph 环境搭建</a> 。</p></li><li><p>查看结果</p><p>运行之后将会在输出路径下看到输出文件，其内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00.0</span><br><span class="line">11.0</span><br><span class="line">23.0</span><br><span class="line">32.0</span><br><span class="line">46.0</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="总结">总结</h3><p>Giraph 的编程过程可以总结为：</p><ul><li><p>继承 BasicComputation，实现 compute 方法</p><p>compute 方法主要完成顶点的计算更新和必要的消息发送</p></li><li><p>命令行提交 Job</p><p>由于系统已经提供了 GiraphRunner 的主类，所以大部分情况下用户不需要编写 Job 的配置和提交过程，但是如果 GiraphRunner 不满足用户需求，用户也可以自定义主类然后命令行提交的时候进行指定</p></li></ul><p>以上仅仅说明了最基本的 Giraph 编程过程，但如果想要实现性能最优的图计算过程，则还需要考虑编程过程中利用 <code>Aggregators</code> 和 <code>Combiners</code> 机制，相关示例可以参考 giraph 源码的 giraph-examples 部分。</p><h2 id="源码编译调试">源码编译调试</h2><h3 id="环境要求">环境要求</h3><p>Giraph 源码的编译调试要求 Java 1.8、Maven 3 以上版本以及 Hadoop2.5.1</p><h3 id="导入源码">导入源码</h3><ol type="1"><li><p>下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/giraph.git</span><br></pre></td></tr></table></figure></li><li><p>编译源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -Phadoop_2 -DskipTests clean package</span><br></pre></td></tr></table></figure><p>成功后将会输出</p><p><img src="/posts/72593b40/build-success.png"></p></li><li><p>使用 IDEA 打开 giraph 源码目录</p><p>在 Maven 的 Profies 页面选择 hadoop2 ( 默认是 hadoop1 )</p><p><img src="/posts/72593b40/select_hadoop2.png"></p></li></ol><h3 id="增加自定义入口">增加自定义入口</h3><p>Giraph 提供了一个位于 giraph-core/src/main/java/org/apache/giraph 下的入口类 GiraphRunner。但该类比较繁琐并且不能自动删除输出文件，不太利于本地调试阅读 Giraph 的源码。因此最好是增加一个自定义的入口类。</p><ul><li><p>在 org.apache.giraph 包下创建 custom 包</p></li><li><p>在 custom 包下创建用于测试的 Shortestpath 类（内容与编程实践部分一致）</p></li><li><p>在 custom 包下创建自定义入口类 CustomRunner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.giraph.conf.GiraphConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.giraph.conf.GiraphConstants;</span><br><span class="line"><span class="keyword">import</span> org.apache.giraph.io.formats.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.giraph.job.GiraphJob;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT_PATH = <span class="string">&quot;giraph-core/src/main/resources/input/graph_data.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OUTPUT_PATH = <span class="string">&quot;giraph-core/src/main/resources/output/shortestPath&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GiraphConfiguration conf = <span class="keyword">new</span> GiraphConfiguration(<span class="keyword">new</span> Configuration());</span><br><span class="line">        conf.setComputationClass(Shortestpath.class);</span><br><span class="line">        <span class="comment">//设置输入和输出格式</span></span><br><span class="line">        conf.setVertexInputFormatClass(JsonLongDoubleFloatDoubleVertexInputFormat.class);</span><br><span class="line">        conf.setVertexOutputFormatClass(IdWithValueTextOutputFormat.class);</span><br><span class="line">        <span class="comment">//设置本地运行模式</span></span><br><span class="line">        conf.setLocalTestMode(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置 worker 配置</span></span><br><span class="line">        conf.setWorkerConfiguration(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//可选，如果要学习 Checkpoint 机制应该设置</span></span><br><span class="line">        conf.setCheckpointFrequency(<span class="number">4</span>);</span><br><span class="line">        GiraphConstants.SPLIT_MASTER_WORKER.set(conf, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        GiraphJob job = <span class="keyword">new</span> GiraphJob(conf, Shortestpath.class.getSimpleName());</span><br><span class="line">        <span class="comment">//设置输入和输出路径</span></span><br><span class="line">        GiraphTextInputFormat.setVertexInputPath(conf, <span class="keyword">new</span> Path(INPUT_PATH));</span><br><span class="line">        GiraphTextOutputFormat.setOutputPath(job.getInternalJob(), <span class="keyword">new</span> Path(OUTPUT_PATH));</span><br><span class="line">        <span class="comment">//删除之前的输出</span></span><br><span class="line">        deletePath(OUTPUT_PATH, <span class="keyword">true</span>);</span><br><span class="line">        job.run(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于删除输出目录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 目录路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deletePath</span><span class="params">(String path, <span class="keyword">boolean</span> isDirectory)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="comment">//本地目录递归删除</span></span><br><span class="line">            <span class="keyword">if</span> (isDirectory) &#123;</span><br><span class="line">                File[] subFiles = file.listFiles();</span><br><span class="line">                <span class="keyword">for</span> (File subFile : subFiles) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (subFile.isFile()) &#123;</span><br><span class="line">                        subFile.delete();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        deletePath(subFile.getPath(), <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 resources 文件夹创建 input 文件夹并放入编程实践中的测试数据 graph_data.txt</p></li><li><p>验证</p><p>修改配置并运行如果在 resources 文件夹下看到输出文件，证明添加自定义入口成功，此时可以进行断点调试</p><p><img src="/posts/72593b40/editConf.png"></p></li></ul><h3 id="问题">问题</h3><ol type="1"><li><p>运行时提示 TestYarnJob 中的 MiniYARNCluster 缺失问题</p><p>对于 Test 部分的内容因为不影响源码阅读，可以将出错部分注释掉</p></li></ol><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cDovL2dpcmFwaC5hcGFjaGUub3JnL2ludHJvLmh0bWw=">Introduction to Apache Giraph<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpcmFwaC5hcGFjaGUub3JnL2J1aWxkLmh0bWw=">Building and Testing<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要总结了如何利用 Giraph 提供的 API 实现图计算编程，并说明了将 Giraph 源码导入 IDEA 进行调试的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Giraph" scheme="https://www.ikroal.cn/categories/Giraph/"/>
    
    
    <category term="SourceCode Analysis" scheme="https://www.ikroal.cn/tags/SourceCode-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Giraph 环境搭建</title>
    <link href="https://www.ikroal.cn/posts/a2b96c30.html"/>
    <id>https://www.ikroal.cn/posts/a2b96c30.html</id>
    <published>2019-08-17T08:49:45.000Z</published>
    <updated>2021-12-24T05:57:00.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文主要介绍了 Giraph 的环境搭建过程</p><span id="more"></span><h2 id="运行模式">运行模式</h2><p>Giraph 是基于 Hadoop 开发的上层应用，因此其运行模式取决于 Hadoop 的运行模式。关于 Hadoop 的运行模式请参照 <a href="/posts/fed3b37a.html" title="Hadoop基础之搭建环境">Hadoop基础之搭建环境</a> 一文。</p><h2 id="搭建过程">搭建过程</h2><p>本次环境搭建基于 Hadoop 2.5.1 以及 Giraph 1.2.0，系统环境是 Ubuntu 18.04，JDK 版本是 openjdk8。</p><ol type="1"><li><p>配置 Hadoop 的环境</p><p>首先下载 <span class="exturl" data-url="aHR0cHM6Ly9hcmNoaXZlLmFwYWNoZS5vcmcvZGlzdC9oYWRvb3AvY29yZS9oYWRvb3AtMi41LjEvaGFkb29wLTIuNS4xLnRhci5neg==">Hadoop 2.5.1<i class="fa fa-external-link-alt"></i></span>，然后参考 <a href="/posts/fed3b37a.html" title="Hadoop基础之搭建环境">Hadoop基础之搭建环境</a> 完成配置，这里为了简单起见仅使用了默认的 Standalone 模式。</p></li><li><p>配置 Giraph</p><p>下载 <span class="exturl" data-url="aHR0cDovL2FwYWNoZS5taXJyb3JzLmx1Y2lkbmV0d29ya3MubmV0L2dpcmFwaC9naXJhcGgtMS4yLjAvZ2lyYXBoLWRpc3QtMS4yLjAtaGFkb29wMi1iaW4udGFyLmd6">Giraph 1.2.0<i class="fa fa-external-link-alt"></i></span>，然后进行解压即可。</p></li><li><p>配置环境变量</p><p>为了更好使用 Giraph ，需要配置如下三个环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Setting Hadoop</span></span><br><span class="line">export HADOOP_HOME=&quot;/your_path/hadoop-2.5.1&quot;</span><br><span class="line">export HADOOP_CONF_DIR=&quot;$HADOOP_HOME/etc/hadoop&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Setting Giraph</span></span><br><span class="line">export GIRAPH_HOME=&quot;/your_path/giraph-1.2.0-hadoop2-for-hadoop-2.5.1&quot;</span><br></pre></td></tr></table></figure></li><li><p>验证环境</p><ul><li><p>在 Giraph 同级目录下创建 input 文件夹，然后在 input 文件夹内创建 tiny_graph.txt 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir input</span><br><span class="line">cd input </span><br><span class="line">touch tiny_graph.txt</span><br><span class="line">vim tiny_graph.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">在文件中输入以下数据，其格式为 [source_id,source_value,[[dest_id, edge_value],...]]，如 [0,0,[[1,1],[3,3]]] 表示顶点序号为 0，顶点值为 0，存在序号 0 到 序号 1 的边，值为 1，存在序号 0 到序号 3 的边，值为 3。</span></span><br><span class="line">[0,0,[[1,1],[3,3]]]</span><br><span class="line">[1,0,[[0,1],[2,2],[3,1]]]</span><br><span class="line">[2,0,[[1,2],[4,4]]]</span><br><span class="line">[3,0,[[0,3],[1,1],[4,4]]]</span><br><span class="line">[4,0,[[3,4],[2,4]]]</span><br></pre></td></tr></table></figure></li><li><p>在 Giraph 的同级目录下执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">GIRAPH_HOME/bin/giraph <span class="variable">$GIRAPH_HOME</span>/giraph-examples-1.2.0-hadoop2.jar org.apache.giraph.examples.SimpleShortestPathsComputation -vif org.apache.giraph.io.formats.JsonLongDoubleFloatDoubleVertexInputFormat -vip ./input/tiny_graph.txt -vof org.apache.giraph.io.formats.IdWithValueTextOutputFormat -op ./output/shortestpaths -w 1 -ca giraph.SplitMasterWorker=<span class="literal">false</span></span></span><br></pre></td></tr></table></figure><p>这行命令实质是向 Hadoop 提交一个 Job，giraph-examples-1.2.0-hadoop2.jar 是提交的 jar 文件，SimpleShortestPathsComputation 表示 Giraph 将会运行的计算类。其余的各项参数含义为：</p><ul><li><p>-vif</p><p>用于指定输入数据的格式</p></li><li><p>-vip</p><p>用于指定输入数据的路径，可以看到这里指定了前一步中创建的 tiny_graph.txt 文件</p></li><li><p>-vof</p><p>用于指定输出格式</p></li><li><p>-op</p><p>用于指定输出路径，这里指定的路径是 input 同级目录下的 output 文件夹下的 shortestpaths 文件夹</p></li><li><p>-w</p><p>用于指定 worker 的数量，这里由于在本地运行只能指定为 1 个</p></li><li><p>-ca</p><p>表明指定参数为自定义的参数，这里指定 giraph.SplitMasterWorker 为 false，表明不区分 Master 和 Worker（本地运行必须指定）。更多的自定义参数请参考 <span class="exturl" data-url="aHR0cHM6Ly9naXJhcGguYXBhY2hlLm9yZy9vcHRpb25zLmh0bWw=">🔗<i class="fa fa-external-link-alt"></i></span></p></li></ul></li><li><p>查看结果</p><p>运行结束之后进入 output/shortestpaths 将会看到输出文件 part-m-00000，其内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01.0</span><br><span class="line">10.0</span><br><span class="line">22.0</span><br><span class="line">31.0</span><br><span class="line">45.0</span><br></pre></td></tr></table></figure></li></ul><p>这里的验证是针对 Standalone 模式而言，如果需要在 Pseudo-Distributed 和 Full-Distributed 模式下进行验证，只需要把相应的输入文件上传到 HDFS，然后更改执行命令中的输入路径和输出路径即可。</p></li></ol><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cDovL2dpcmFwaC5hcGFjaGUub3JnL3F1aWNrX3N0YXJ0Lmh0bWw=">Quick Start<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要介绍了 Giraph 的环境搭建过程&lt;/p&gt;</summary>
    
    
    
    <category term="Giraph" scheme="https://www.ikroal.cn/categories/Giraph/"/>
    
    
    <category term="Deploy" scheme="https://www.ikroal.cn/tags/Deploy/"/>
    
  </entry>
  
  <entry>
    <title>Giraph 简介</title>
    <link href="https://www.ikroal.cn/posts/24b5ab82.html"/>
    <id>https://www.ikroal.cn/posts/24b5ab82.html</id>
    <published>2019-08-11T07:27:06.000Z</published>
    <updated>2021-12-24T05:57:00.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文主要阐述了 Giraph 由来及其作用，并根据 Giraph 的系统架构和计算模型简要介绍了 Giraph 的运行流程。</p><span id="more"></span><h2 id="什么是-giraph">什么是 Giraph</h2><p>Giraph 是 Google 于 2010 年发布的论文 <span class="exturl" data-url="aHR0cHM6Ly93d3cucmVzZWFyY2hnYXRlLm5ldC9wcm9maWxlL0phbWVzX0RlaG5lcnQvcHVibGljYXRpb24vMjIxMjU3MzgzX1ByZWdlbF9BX3N5c3RlbV9mb3JfbGFyZ2Utc2NhbGVfZ3JhcGhfcHJvY2Vzc2luZy9saW5rcy8wMGI3ZDUzN2M2MTU4MjFmYTQwMDAwMDAucGRm">Pregel: a system for large-scale graph processing<i class="fa fa-external-link-alt"></i></span> 的开源实现。Giraph 是以 Hadoop 为基础开发的上层应用，其系统架构和计算模型与 Pregel 保持了一致。同时也在 Pregel 模型上增加了一些新的特性，如：out-of-core computation、edge-oriented input 等。Giraph 的目的是为了解决大规模图的分布式计算问题。通过隐藏分布式和并行计算的细节以及提供一套用于描述图算法的 API，Giraph 不仅拥有了很好的可扩展性，还降低了分布式图计算的使用门槛。</p><h2 id="系统架构">系统架构</h2><!--![](Giraph简介/Giraph_Architecture.png)--><p>上图蓝色部分标识了 Giraph 的系统架构，可以看到 Giraph 实质上还是一个 Master/Slave 的架构，主要由三个部分构成：</p><ul><li><p>Master</p><p>Master 实质上运行在 Hadoop 的 MapTask 上， 其主要作用是对输入图进行分区、协调 Worker 的活动、维护一份存活的 Worker 列表（包括 Worker 的标识符、地址信息等）以及更新 Job 的状态。</p></li><li><p>Worker</p><p>与 Master 一样，Worker 也运行在 Hadoop 的 MapTask 上，其主要作用是维护已分配图的状态。</p></li><li><p>Zookeeper</p><p>在 Giraph 中 Zookeeper 的主要作用是 Master 选举、命名服务以及协调服务。图中显示的 Zookeeper 是外置状态，但实际上如果不给 Giraph 提供外置 Zookeeper，那么 Giraph 将会在 Master 所在节点上自行启动一个 Zookeeper 来提供服务。</p></li></ul><h2 id="计算模型">计算模型</h2><!--![](Giraph简介/Giraph_Computation_Model.png)--><p>上图显示了 Giraph 的整个计算模型，主要由输入、一系列 Superstep 迭代计算、输出构成，其中这些 Superstep 被称之为 BSP(Bulk Synchronous Parallelism) 模型。</p><h3 id="bsp-模型">BSP 模型</h3><p>BSP 模型是一个块同步并行模型，其由许多个 Superstep 组成。对于 BSP 模型而言，其在 Superstep 内的操作是并行的，但在两个 Superstep 之间则是由一个同步操作进行隔离的。也就是说 Superstep(N + 1) 会等待 Superstep(N) 执行完成之后才会开始。</p><!--![](Giraph简介/Giraph_Bsp.png)--><p>上图显示了 Superstep 的结构图，一个 Superstep 由<strong>局部计算</strong>、<strong>通讯</strong>、<strong>栅栏同步</strong> 三个部分构成。可以看到即使有部分的计算比较快，但最终还是会在栅栏同步这里停下等待其余的计算完成。在图计算中应用这种模型的好处是：可以解决图计算的同步问题，同步模型有利于推断程序语义（即利于编程），并且消除了死锁和数据竞争的问题。</p><h3 id="计算过程">计算过程</h3><p><img src="/posts/24b5ab82/Giraph_Compute_Progress.png"></p><p>上图展示了一个计算图中顶点最大值的过程，其中深色的顶点表示本次 Superstep 结束之后将自己标记为不活跃状态（即不再需要进行计算），当所有顶点均处于不活跃状态的时候即表明计算结束。下面针对各个 Superstep 进行分析：</p><ul><li><p>Superstep0</p><p>Superstep0 时所有的顶点处于活跃状态并沿出边发送其顶点值</p></li><li><p>Superstep1</p><p>Superstep1 时每个顶点处理 Superstep0 发来的顶点值，第一、四个顶点[从左往右计数]发现有更大的顶点值 6，所以更新其顶点值为 6 ，并沿出边发送更新之后的顶点值。而第二、三个顶点发现并没有比它们顶点值更大的顶点值，因此两个顶点将自身标记为不活跃状态。</p></li><li><p>Superstep2</p><p>Superstep2 时由于第二个顶点收到了 Superstep1 发送过来的顶点值，所以系统会将第二个顶点标记为活跃状态然后去处理接收到的顶点值，但第二个顶点依旧发现没有比它更大的顶点值，所以会再次标记自己为不活跃状态。第一、四个顶点由于没有接收到 Superstep1 发来的顶点值，所以会将其标记为不活跃状态。第三个顶点在处理 Superstep1 发来的顶点值时，发现了比它更大的顶点值 6，所以会进行更新然后沿出边发送更新之后的顶点值。</p></li><li><p>Superstep3</p><p>Superstep3 阶段只有第二、四顶点接收到了 Superstep2 发来的顶点值，所以跟 Superstep2 中处理方式一致，系统先标记为这两个顶点为活跃状态，顶点比较接收的顶点值之后将自身标记为不活跃状态。至于第一、四顶点因为处于不活跃状态且没有收到上一个超步接收到的顶点值，所以不会进行处理从而依旧保持不活跃状态。至此整个计算过程就结束了。</p></li></ul><h2 id="运行流程">运行流程</h2><p>在了解了 Giraph 的系统架构和计算模型之后，这里简单介绍一下 Giraph 的整个运行流程：</p><ol type="1"><li>Giraph 向 Hadoop 提交 Job 之后，Zookeeper 将会选出一个 MapTask 作为 Giraph 的 Master，其余的 MapTask 则作为 Worker。然后这些 Worker 会通过 Zookeeper 命名服务找到 Master，并向 Master 进行注册。</li><li>Master 将会对输入图进行分区，并发送分区信息给 Worker，Woker 会对分区进行读取，期间可能会发生 Worker 之间的分区交换。</li><li>之后 Master 会开始协调 Worker 迭代执行 Superstep，Worker 将会在 Superstep 中完成顶点的计算过程，直到所有的顶点处于不活跃状态之后结束计算。</li><li>在计算结束之后，Giraph 将会根据用户指定的格式输出结果。</li></ol><h2 id="总结">总结</h2><p>上述简要介绍了 Giraph 的核心知识，即架构和计算模型。但除此之外，Giraph 中还有重要的优化和容错机制尚未介绍，这些都需要后续学习的时候进行整理分析。</p><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVzZWFyY2hnYXRlLm5ldC9wcm9maWxlL0phbWVzX0RlaG5lcnQvcHVibGljYXRpb24vMjIxMjU3MzgzX1ByZWdlbF9BX3N5c3RlbV9mb3JfbGFyZ2Utc2NhbGVfZ3JhcGhfcHJvY2Vzc2luZy9saW5rcy8wMGI3ZDUzN2M2MTU4MjFmYTQwMDAwMDAucGRm">Pregel: a system for large-scale graph processing<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jc2hpaG9uZy5naXRodWIuaW8vMjAxOC8wNS8zMC9QcmVnZWwlRUYlQkMlODglRTUlOUIlQkUlRTglQUUlQTElRTclQUUlOTclRUYlQkMlODklRTYlOEElODAlRTYlOUMlQUYlRTUlOEUlOUYlRTclOTAlODYv">Pregel（图计算）技术原理<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHdibG9ncy5uZXQvYS81YjhhYjUzZDJiNzE3NzVkMWNlOGJhNzQvemgtY24=">BSP模型的相关讲解<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vQllSYW5zL3AvNDY4MjI4Mi5odG1s">从BSP模型到Apache Hama<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXJhcGguYXBhY2hlLm9yZy9pbnRyby5odG1s">Introduction to Apache Giraph<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要阐述了 Giraph 由来及其作用，并根据 Giraph 的系统架构和计算模型简要介绍了 Giraph 的运行流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Giraph" scheme="https://www.ikroal.cn/categories/Giraph/"/>
    
    
    <category term="Introduction" scheme="https://www.ikroal.cn/tags/Introduction/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop 基础之 HDFS 入门</title>
    <link href="https://www.ikroal.cn/posts/abb7faac.html"/>
    <id>https://www.ikroal.cn/posts/abb7faac.html</id>
    <published>2019-05-11T11:52:59.000Z</published>
    <updated>2021-12-24T05:57:00.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文主要介绍了 HDFS 的体系架构以及其执行流程，并给出了读写操作的编程实例，希望对 HDFS 有个初步的认识。</p><span id="more"></span><h2 id="简介">简介</h2><p>HDFS (Hadoop Distributed File System) 是一个运行在商业 PC 上的分布式文件系统，其设计思想源自于 Google 2003 年发布的论文 <span class="exturl" data-url="aHR0cHM6Ly9haS5nb29nbGUvcmVzZWFyY2gvcHVicy9wdWI1MQ==">The Google File System<i class="fa fa-external-link-alt"></i></span> 。HDFS的主要目的是为了解决大规模数据存储和管理的问题。</p><h2 id="体系架构">体系架构</h2><p><img src="/posts/abb7faac/HDFS-Structure.png"></p><p>上图表明 HDFS 是一个标准的 master/slave 架构，主要由三个部分构成：</p><ol type="1"><li>NameNode（master 节点）<ul><li>元数据（MetaData）的管理，其中元数据由<strong>文件路径名</strong>、<strong>数据块ID</strong>以及<strong>存储位置</strong>等信息构成</li><li>管理 HDFS 的名字空间。</li></ul></li><li>SecondaryNameNode<ul><li>定期合并 NameNode 的 edit logs（对文件系统的改动序列） 到 fsimage（对整个文件系统的快照），并拷贝修改后的 fsimage 到 NameNode。</li><li>提供一个 NameNode 的检查点（切忌认为是 NameNode 的备份），可用于 NameNode 的故障恢复。</li></ul></li><li>DataNode（slave 节点）<ul><li>提供文件存储和进行数据块操作。</li><li>周期性的向 NameNode 汇报块信息。</li></ul></li></ol><p>这里对图中出现的一些概念进行说明：</p><ol type="1"><li><p>Replication（副本）</p><p>为了保证数据的高可用，HDFS 会对写入的数据进行冗余存储，默认情况下会保存 3 份。</p></li><li><p>Blocks</p><p>Block 是最基本的存储和操作单位（默认情况下为 128M），这里的 Block 不是指物理 Block ，而是指文件系统的 Block，其大小一般是物理 Block 的整数倍。</p></li></ol><h2 id="执行流程">执行流程</h2><h3 id="读文件">读文件</h3><p><img src="/posts/abb7faac/HDFS-Read.jpg"></p><p>读文件的过程可以概括为：</p><ol type="1"><li>Client 向 NameNode 发起请求获取文件数据块位置信息</li><li>Client 按照数据块距 Client 的远近依次进行连接然后读取数据</li></ol><h3 id="写文件">写文件</h3><p><img src="/posts/abb7faac/HDFS-Write.jpg"></p><p>写文件的过程可以概括为：</p><ol type="1"><li>Client 向 NameNode 发起写文件的请求获得可写的 DataNode 列表等信息</li><li>Client 根据 HDFS 设定的分块大小对文件进行分块</li><li>Client 和 NameNode 分配的 DataNode 构成 pipeline 并进行数据写入</li><li>写入完成之后，NameNode 接收来自 DataNode 的消息进行元数据的更新</li></ol><h2 id="常用命令">常用命令</h2><h3 id="文件操作">文件操作</h3><ol type="1"><li><p>列出文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls &lt;path&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir &lt;path&gt;</span><br></pre></td></tr></table></figure></li><li><p>上传文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put &lt;localsrc&gt; &lt;dst&gt;</span><br></pre></td></tr></table></figure></li><li><p>输出文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -cat &lt;src&gt;</span><br></pre></td></tr></table></figure></li><li><p>文件复制到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -get &lt;src&gt; &lt;localdst&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除文件和目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -rm &lt;src&gt;</span><br><span class="line">hdfs dfs -rmdir &lt;dir&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="管理">管理</h3><ol type="1"><li><p>查看统计信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfsadmin -report</span><br></pre></td></tr></table></figure></li><li><p>进入和退出安全模式（该模式不允许文件系统有任何修改）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfsadmin -safemode enter</span><br><span class="line">hdfs dfsadmin -safemode leave</span><br></pre></td></tr></table></figure></li></ol><h2 id="编程实例">编程实例</h2><ol type="1"><li><p>IDEA 新建 Maven 项目</p><p><img src="/posts/abb7faac/maven-create.png"></p><p>勾选相关选项后，点击 next 填入项目相关信息即可</p></li><li><p>pom.xml 中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> //根据 Hadoop 版本进行选择</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>读写文件</p><p>创建 Sample 类编写相应的读写函数</p><ul><li><p>Sample 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataInputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ikroal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认的 HDFS 地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_FS = <span class="string">&quot;hdfs://localhost:9000&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = DEFAULT_FS + <span class="string">&quot;/tmp/demo.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_FILE = <span class="string">&quot;demo.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        FileSystem fs = <span class="keyword">null</span>;</span><br><span class="line">        conf.set(<span class="string">&quot;fs.defaultFS&quot;</span>, DEFAULT_FS); <span class="comment">//配置 HDFS 地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fs = FileSystem.get(conf);</span><br><span class="line">            write(fs, DEFAULT_FILE, PATH);</span><br><span class="line">            read(fs, PATH);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fs.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>write 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 进行文件写入</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> inputPath 待写入文件路径</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> outPath HDFS 的写入路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(FileSystem fileSystem, String inputPath, String outPath)</span> </span>&#123;</span><br><span class="line">    FSDataOutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        outputStream = fileSystem.create(<span class="keyword">new</span> Path(outPath)); <span class="comment">//获得 HDFS 的写入流</span></span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(inputPath); <span class="comment">//读取本地文件</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data = inputStream.read()) != -<span class="number">1</span>) &#123; <span class="comment">//写入操作</span></span><br><span class="line">            outputStream.write(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>read 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 进行文件读取</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> path HDFS 上待读取文件路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(FileSystem fileSystem, String path)</span> </span>&#123;</span><br><span class="line">    FSDataInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = fileSystem.open(<span class="keyword">new</span> Path(path)); <span class="comment">//获取 HDFS 读取流</span></span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">        String content;</span><br><span class="line">        <span class="keyword">while</span> ((content = reader.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">//读取并输出到控制台</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在工程文件夹的根目录下创建计划上传的文件（这里是 demo.txt），填入 Hello World！</p></li><li><p>启动 Hadoop 然后运行程序查看结果</p><p>通过 http://localhost:50070/explorer.html#/ 可以查看写入结果</p><p><img src="/posts/abb7faac/write.png"></p><p>控制台则会输出上传文件的内容</p><p><img src="/posts/abb7faac/read.png"></p></li></ol><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY29kZU9mTGlmZS9wLzUzNzUxMjAuaHRtbA==">初步掌握HDFS的架构及原理<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpbmdkdWFubGJkL2FydGljbGUvZGV0YWlscy81MTkxNDU1MCN0MjM=">深入理解HDFS：Hadoop分布式文件系统<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doZHhqYncvYXJ0aWNsZS9kZXRhaWxzLzgxMDcyMjA3">HDFS读写流程（史上最精炼详细）<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcWluZ3l1bnpvbmcvcC84NTQ4ODA2Lmh0bWw=">Hadoop学习之路（十一）HDFS的读写详解<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要介绍了 HDFS 的体系架构以及其执行流程，并给出了读写操作的编程实例，希望对 HDFS 有个初步的认识。&lt;/p&gt;</summary>
    
    
    
    <category term="Archived" scheme="https://www.ikroal.cn/categories/Archived/"/>
    
    
    <category term="HDFS" scheme="https://www.ikroal.cn/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop 基础之搭建环境</title>
    <link href="https://www.ikroal.cn/posts/fed3b37a.html"/>
    <id>https://www.ikroal.cn/posts/fed3b37a.html</id>
    <published>2019-05-04T09:52:43.000Z</published>
    <updated>2021-12-24T05:59:49.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文主要介绍了 Hadoop 的三种运行模式以及配置的方式。</p><span id="more"></span><h2 id="运行模式">运行模式</h2><p>Hadoop 的运行模式分为三种：</p><ol type="1"><li>Standalone（本地模式/单机模式/local模式） 该模式下没有任何守护进程，用户程序和 Hadoop 程序运行在同一个 Java 进程，使用的文件系统是本地文件系统而不是分布式文件系统，此模式下一般用于本地调试。</li><li>Pseudo-Distributed（伪集群模式） 在<strong>单机</strong>上模拟集群模式，各守护进程运行在单独的 Java 进程当中，使用的文件系统是 HDFS</li><li>Fully-Distributed（集群模式） 守护进程运行在集群上，使用的文件系统也是 HDFS</li></ol><h2 id="配置过程">配置过程</h2><p>本次配置基于 Hadoop2.9.2，其中 Standalone 在 CentOS 7.2 系统下进行配置， Pseudo-Distributed 模式在 MacOS 10.14.4 上进行配置，Fully-Distributed 模式在腾讯云主机上进行配置，集群由两台云主机组成，分别运行 Ubuntu 14.04.1 和 CentOS 7.2 系统。</p><h3 id="环境准备">环境准备</h3><ul><li><p>Java 7/8 Hadoop 2.7.x to 2.x 支持 Java 7/8，其它 Hadoop 版本支持的 Java 版本请点击 <span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IQURPT1AvSGFkb29wK0phdmErVmVyc2lvbnM=">🔗<i class="fa fa-external-link-alt"></i></span> 进行查询 下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install java-1.8.0-openjdk-devel //centos 安装 Java8，ubuntu 下需要用 apt-get 进行安装</span><br></pre></td></tr></table></figure><p>配置环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vi .bash_profile</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386</span><br><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure></li><li><p>ssh 和 rsync: 用 <code>ssh</code> 和 <code>rsync</code> 命令测试后发现 Centos 本身就有，所以无须进行安装。</p></li><li><p>Hadoop</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-2.9.2/hadoop-2.9.2.tar.gz</span><br><span class="line">tar -zxvf hadoop-2.9.2.tar.gz</span><br></pre></td></tr></table></figure><p>这里的下载地址最好根据云主机所在的区域进行选择，如果是国内的云主机最好使用国内的镜像地址，这样下载会快很多。</p></li></ul><h3 id="standalone-模式">Standalone 模式</h3><p>下载解压之后的 Hadoop 默认就是 Standalone 模式，可直接运行 wordcount 进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir input //hadoop 的同级目录创建</span><br><span class="line">cp hadoop-2.9.2/LICENSE.txt input/</span><br><span class="line"></span><br><span class="line">hadoop-2.9.2/bin/hadoop jar  hadoop-2.9.2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar wordcount input output //运行 wordcount</span><br><span class="line">cat output/part-r-00000 //查看结果</span><br></pre></td></tr></table></figure><p>同时再开一个终端在作业运行的时候输入 jps 查看进程</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/hadoop-standalone.png"></p><p>可以看到 Standalone 模式下 Hadoop 只会启动 RunJar 进程来运行整个作业</p><h3 id="pseudo-distributed-模式">Pseudo-Distributed 模式</h3><ol type="1"><li><p>修改 etc/hadoop/core-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="comment">&lt;!--配置访问 nameNode 的 URI--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--指定临时目录，MapReduce 和 HDFS 的许多路径配置依赖此路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--配置文件的副本数量--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    <span class="comment">&lt;!--关闭防火墙--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置免密登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost 测试能否免密登录（如果能够则跳过以下操作）</span><br><span class="line">ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 0600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/hadoop-env.sh（如果提示找不到 JAVA_HOME）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386 //上面配置的 JAVA_HOME 好像没起作用</span><br></pre></td></tr></table></figure></li><li><p>格式化 HDFS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></li><li><p>启动 HDFS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p>启动后输入 jps 看到以下进程即成功，这个时候可以通过 http://localhost:50070/ 访问 NameNode</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/hdfs%E8%BF%9B%E7%A8%8B.png"></p></li><li><p>运行 wordcount</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs dfs -mkdir /user</span><br><span class="line">bin/hdfs dfs -mkdir /user/&lt;username&gt;</span><br><span class="line">bin/hdfs dfs -mkdir /user/&lt;username&gt;/input</span><br><span class="line">bin/hdfs dfs -put LICENSE.txt /user/&lt;username&gt;/input //创建文件夹并上传文件</span><br><span class="line">bin/hadoop jar  share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar wordcount input output //运行 wordcount</span><br><span class="line">bin/hdfs dfs -cat output/part-r-00000 //显示结果</span><br></pre></td></tr></table></figure><p>在另一终端输入 jps 可以看到运行时的以下进程 <img src="https://raw.githubusercontent.com/ikroal/blog-images/master/Pseudo-Distributed.png"></p><p>依旧是用 RunJar 提交，只是读取和写入采用了 HDFS。</p></li><li><p>通过 YARN 执行 Job（可选配置，不过为了更接近真实集群还是建议配置）</p><ul><li><p>修改 etc/hadoop/mapred-site.xml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp etc/hadoop/mapred-site.xml.template etc/hadoop/mapred-site.xml</span><br><span class="line">vi etc/hadoop/mapred-site.xml</span><br></pre></td></tr></table></figure><p>增加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--表明运行在 YARN 上--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="comment">&lt;!--设置resourcemanager的hostname--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--指定 nodemanager 获取数据的方式--&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动 YARN</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><p>启动成功后可以通过 http://localhost:8088/ 访问 ResourceManager 节点，并且输入 jps 会显示以下进程</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/yarn-process.png"></p><p>其中 ResourceManager 和 NodeManager 是属于 YARN 的进程。</p></li><li><p>重复 <code>7</code> 的操作，输入 jps 查询进程</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/yarn-run-process.png"></p><p>可以看到新增加了 YarnChild 进程和 MRAppMaster 进程，之所以有两个 YarnChild 进程是因为输入文件夹中存在两个文本文件，这说明了 MapReduce 是通过创建<strong>多个进程并行</strong>计算的。</p></li></ul></li></ol><h3 id="fully-distributed-模式">Fully-Distributed 模式</h3><p>集群包括两个节点，节点名分别为 master 和 slave，master 和 slave 的节点配置过程基本一致，以下是配置过程（两个节点差异配置会进行注明，建议先配置好 master 节点的 Hadoop，然后用 scp 命令复制到 slave 节点进行修改。）：</p><ol type="1"><li><p>修改 <strong>/etc/hosts</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">152.136.76.12 master //腾讯云公网ip</span><br><span class="line">94.191.43.137 slave</span><br></pre></td></tr></table></figure></li><li><p>免密登录（<strong>⚠️两个节点的登录名必须一致，这里都为 root</strong>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">master 节点配置本机免密登录以及移动公钥到子节点</span><br><span class="line">ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 0600 ~/.ssh/authorized_keys</span><br><span class="line">scp ~/.ssh/id_rsa.pub root@slave:~/</span><br><span class="line"></span><br><span class="line">slave 节点配置 master 节点免密登录</span><br><span class="line">cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 600  ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/core-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="comment">&lt;!--配置访问 nameNode 的 URI--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--指定临时目录，MapReduce 和 HDFS 的许多路径配置依赖此路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--配置文件的副本数量--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    <span class="comment">&lt;!--关闭防火墙--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>slave:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="comment">&lt;!-- 指定secondarynamenode位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--表明运行在 YARN 上--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="comment">&lt;!--设置resourcemanager的hostname--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--指定 nodemanager 获取数据的方式--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/hadoop-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386 //master 和 slave 填入各自路径</span><br><span class="line">export HADOOP_LOG_DIR=/root/hadoop/hadoop-2.9.2/logs //可以自己选定</span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/mapred-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386</span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/yarn-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.i386 </span><br><span class="line">export YARN_LOG_DIR=/root/hadoop/hadoop-2.9.2/logs</span><br></pre></td></tr></table></figure></li><li><p>修改 etc/hadoop/slaves</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">slave</span><br></pre></td></tr></table></figure></li><li><p>启动 HDFS 和 YARN</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs namenode -format //首次运行时格式化</span><br><span class="line">sbin/start-dfs.sh</span><br><span class="line">sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><p>在 master 和 slave 节点分别输入 jps 后有</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/master.png"></p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/slave.png"></p><p>此时可以通过 http://152.136.76.12:8080 (ip 为 master 的公网 ip) 以及 http://152.136.76.12:50070 分别访问 HDFS 的 web 界面和 YARN 的 web 界面，可以看到 HDFS 下有一个 slave 节点，YARN 下有两个节点</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/HDFS-node.png"></p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/YARN-node.png"></p></li><li><p>运行 wordcount（与伪分布式中一致）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs dfs -mkdir /user</span><br><span class="line">bin/hdfs dfs -mkdir /user/&lt;username&gt;</span><br><span class="line">bin/hdfs dfs -mkdir /user/&lt;username&gt;/input</span><br><span class="line">bin/hdfs dfs -put LICENSE.txt /user/&lt;username&gt;/input </span><br><span class="line">bin/hadoop jar  share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar wordcount input output</span><br><span class="line">bin/hdfs dfs -cat output/part-r-00000</span><br></pre></td></tr></table></figure><p>继续用 jps 查看两台主机的进程</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/master-run.png"></p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/salve-run.png"></p><p>可以看到集群模式中的进程与伪集群模式中的进程没有区别，唯一的区别在于进程在不同的主机上运行。</p></li></ol><h2 id="错误">错误</h2><p>这里主要记录配置过程中遇到的一部分错误</p><ol type="1"><li><p>Container exited with a non-zero exit code 1. Error file: prelaunch.err.</p><p>该错误是在腾讯云主机上配置的伪集群模式运行 wordcount 时出现的，尝试了网上的一些办法都没有解决。最后采用自己电脑配置再运行一遍成功，可能是因为云主机的配置问题。</p></li><li><p>在 YARN 上运行 Java.net.ConnectException: Connection refused</p><p>可能是防火墙的原因，根据 <span class="exturl" data-url="aHR0cDovL3d3dy5hYm91dHl1bi5jb20vdGhyZWFkLTIwMTUzLTEtMS5odG1s">🔗<i class="fa fa-external-link-alt"></i></span> 中的提示解决</p></li><li><p>无法外网访问VM中的 Hadoop YARN 的8088端口</p><p>无法通过云主机 ip:8088 访问 YARN 的 Web 页面时，不妨通过 <code>netstat -nlp | grep java</code> 查看当前提供 web 服务的端口，如果 ip 是 127.0.0.1 证明存在问题，需要修改 hosts，具体过程见 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZG9uZ3hpdWNhaS9wLzk2NDE5NjIuaHRtbA==">🔗<i class="fa fa-external-link-alt"></i></span>。</p></li><li><p>slave: bash: line 0: cd: /root/hadoop/hadoop-2.9.2: No such file or directory</p><p>配置集群模式时出现，主要原因是手动配置 slave 时 Hadoop 存放路径与 master 不一致，只需要将 slave 的 Hadoop 放在与 master 的同一路径下即可解决。</p></li></ol><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yZDg1MThiMTllZTU=">Hadoop完全分布式部署<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdqbDM4L2FydGljbGUvZGV0YWlscy83NTgzMzc0">Hadoop三种模式介绍<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2NDQyNTUzL2FydGljbGUvZGV0YWlscy83ODcxMDE3MA==">hadoop的三种运行模式区别及配置详解<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要介绍了 Hadoop 的三种运行模式以及配置的方式。&lt;/p&gt;</summary>
    
    
    
    <category term="Hadoop" scheme="https://www.ikroal.cn/categories/Hadoop/"/>
    
    
    <category term="Deploy" scheme="https://www.ikroal.cn/tags/Deploy/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop 基础之生态圈</title>
    <link href="https://www.ikroal.cn/posts/2b10faae.html"/>
    <id>https://www.ikroal.cn/posts/2b10faae.html</id>
    <published>2019-04-21T03:14:35.000Z</published>
    <updated>2021-12-24T05:57:00.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文主要目的是介绍 Hadoop 的基本架构以及衍生出来的各种工具，以期对 Hadoop 有个整体的认识。</p><span id="more"></span><h2 id="hadoop-生态系统">Hadoop 生态系统</h2><p>Hadoop 生态系统是指以 <strong>分布式的文件系统 HDFS</strong>、<strong>分布式的计算框架 MapReduce</strong> 以及<strong>资源管理器 YARN</strong>为基础构成的分布式数据处理系统，其结构图如下图所示：</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/Hadoop%E6%9E%B6%E6%9E%84%E5%9B%BE2.0.png"></p><p>下面将对图中各项组件做一个介绍</p><h3 id="hdfs">HDFS</h3><p>HDFS 是 Google 于 2003 发表的 分布式文件系统 GFS 论文的开源实现版本，主要目的是使用普通商业电脑解决大量数据的存储以及读取速度问题，在 GFS 出现之前一般主要在<strong>单台计算机</strong>用 RAID 来提高数据存储量和读取速度。但是采用 RAID 一方面成本比较高（需求太高时可能只有超级计算机才能满足），另一方面数据量过大时可能超级计算机也无法满足需求。所以这个时候就需要采取<strong>分布式</strong>的方式去满足扩大存储（多台机器多个磁盘）和增加读取速度的需求（多台机器可以同时读）。</p><h3 id="mapreduce">MapReduce</h3><p>MapReduce 是一个分布式的计算框架，在 MapReduce 出现之前就已经有了分布式计算这个概念。但是大多数分布式计算只能专门用于处理一类运算，而 Google 在大量实践中总结出了一个通用的编程模型： <code>map</code> 和 <code>reduce</code>。其中 <code>map</code> 是指分开计算的过程，而 <code>reduce</code> 是指合并结果的过程。而在这一编程模型添加的一系列机制和操作构成了 MapReduce。MapReduce 大大降低了分布式计算的门槛，对于开发人员而言只需要编写一系列 <code>map</code> 和 <code>reduce</code> 函数即可完成所需的分布式计算过程。</p><h3 id="yarn">YARN</h3><p>YARN 是一个资源管理框架，主要作用是负责集群的资源调度和作业任务管理。YARN 的出现源于 Hadoop 不能满足统一使用集群资源的需求，因为 Hadoop1 中集群的资源调度和任务管理与 MapReduce 的执行过程是耦合在一起的，而后续出现的 Spark、Storm 等分布式计算系统其架构和执行过程与 MapReduce 不同，无法直接向 Hadoop 申请集群资源。所以为了实现集群资源的统一管理，在 Hadoop2 中对 MapReduce 进行了一个解耦，抽离出了 YARN 这个框架。</p><h3 id="zookeeper">ZooKeeper</h3><p>Zookeeper 主要作用是提供一个分布式、高可用的协调服务，解决分布式环境下的数据管理问题：统一命名，状态同步，集群管理，配置同步等。</p><h3 id="pig">Pig</h3><p>虽然 MapReduce 极大的简化了分布式计算编程的门槛，但是 Yahoo 的工程师依然觉得 MapReduce 编程太过麻烦，所以他们便开发了 Pig 这个脚本语言用于描述对大数据集的操作。这样就可以通过编译 Pig 脚本生成对应的 MapReduce 程序。</p><h3 id="hive">Hive</h3><p>为了方便使用 SQL 的工程师使用 MapReduce，Facebook 的工程师开发了 Hive，通过 Hive 熟悉数据库的工程师可以无门槛的使用 MapReduce。</p><h3 id="mahout">Mahout</h3><p>Mahout 的主要目标是创建一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便快捷地创建智能应用程序。Mahout 现在已经包含了聚类、分类、推荐引擎（协同过滤）和频繁集挖掘等广泛使用的数据挖掘方法。</p><h3 id="tez">Tez</h3><p>Tez 是 Apache 最新开源的支持 DAG 作业的计算框架，它直接源于 MapReduce 框架，核心思想是将 Map 和 Reduce 两个操作进一步拆分，即 Map 被拆分成 Input、Processor、Sort、Merge和Output， Reduce 被拆分成 Input、Shuffle、Sort、Merge、Processor 和 Output 等。</p><h3 id="hase">Hase</h3><p>HBase 是一个建立在 HDFS 之上，面向列的针对结构化数据的可伸缩、高可靠、高性能、分布式和面向列的动态模式数据库。</p><h3 id="flume">Flume</h3><p>Cloudera 开源的日志收集系统，具有分布式、高可靠、高容错、易于定制和扩展的特点。</p><h3 id="sqoop">Sqoop</h3><p>Sqoop 是 SQL-to-Hadoop 的缩写，主要用于传统数据库和 Hadoop 之前传输数据。数据的导入和导出本质上是Mapreduce 程序，充分利用了 MR 的并行化和容错性。</p><h3 id="ambari">Ambari</h3><p>Ambari 的作用来说，就是创建、管理、监视 Hadoop 的集群，是为了让 Hadoop 以及相关的大数据软件更容易使用的一个 web 工具。</p><h2 id="总结">总结</h2><p>总的来说 HDFS 、MapReduce 以及 YARN 是 Hadoop 的核心组件，而我们学习 Hadoop 最好从核心组件开始学习其原理机制，再逐渐往上层进行了解。</p><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1X2JlbGlmL2FydGljbGUvZGV0YWlscy84MzA1ODc5OA==">Hadoop生态圈总结——大数据<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjYl9kYXRhL2FydGljbGUvZGV0YWlscy84MDQwMjQxMQ==">hadoop生态圈各个组件简介<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ3JpZG1peC9wLzUxMDI2OTQuaHRtbA==">大数据技术Hadoop入门理论系列之一----hadoop生态圈介绍<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTMz">从0开始学大数据---极客时间<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要目的是介绍 Hadoop 的基本架构以及衍生出来的各种工具，以期对 Hadoop 有个整体的认识。&lt;/p&gt;</summary>
    
    
    
    <category term="Archived" scheme="https://www.ikroal.cn/categories/Archived/"/>
    
    
    <category term="Hadoop" scheme="https://www.ikroal.cn/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础之集合框架(一)：集合框架</title>
    <link href="https://www.ikroal.cn/posts/501d57d1.html"/>
    <id>https://www.ikroal.cn/posts/501d57d1.html</id>
    <published>2018-03-17T05:47:45.000Z</published>
    <updated>2021-12-24T05:57:00.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>集合类应该是平时使用的非常频繁的类了，但是对其内部构成却一直不太清晰，所以希望通过本篇文章尝试去理解集合框架的整体设计以及集合存在的必要性。在开始分析之前首先让我们思考以下问题：</p><ol type="1"><li>集合存在的意义，集合和数组的区别</li><li>集合框架的设计意图</li><li>集合的常用操作<span id="more"></span></li></ol><h2 id="集合存在的意义以及与数组的区别">集合存在的意义以及与数组的区别</h2><p>想要了解 Java 为什么会设计集合，就得先明白集合的出现解决了什么问题，关于这一问题「Java 编程思想」中是这么描述的</p><blockquote><p>如果一个程序中只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序。 通常，程序总是根据运行时才知道的某些条件去创建新对象。在此之前，不会知道所需对象的数量，甚至不知道确切的类型。</p></blockquote><p>所以之所以需要集合是因为在编程的过程中会需要保存<strong>数量不定</strong>、<strong>类型不定</strong>的数据。</p><p>针对<strong>数量不定</strong>考虑下面这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOP_FLAG = <span class="string">&quot;s&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String collection[] = <span class="keyword">new</span> String[COUNT];</span><br><span class="line">        System.out.println(<span class="string">&quot;输入即将保存的数据&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!(collection[i] = scanner.next()).equals(STOP_FLAG)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; collection.length; i++) &#123;</span><br><span class="line">            System.out.print(collection[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为一个简单的输入程序，采用数组的形式去保存用户的输入，当用户的输入超过数组可容纳的数量的时候便会抛出异常，这个问题如何解决呢？一种方式是将数组的数量分配的足够大，但是采取这种方式极有可能浪费内存空间。另一种方式则是动态扩展大小，通过动态扩展大小既能够容纳足够多的元素，又能够节约内存空间。而集合正具备动态扩展大小这一特性，所以在这种情况下，集合就体现出了它的作用。 至于<strong>类型不定</strong>，考虑另一种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rookieyang.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String datas[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        datas = <span class="keyword">new</span> String[COUNT];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//也可自行对数组进行动态扩展，这里只是测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addData</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datas[index] = data;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;超出最大的存储范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rookieyang.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataCollection</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; datas;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        datas.add(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出对于数组而言在动态添加数据会略显麻烦，而且只能保存 String 类型数据，但对于采用集合而言，使用起来不仅简单而且其扩展性也强，我们可以根据自己的需求决定集合中保存何种类型数据，这就实现了代码的复用。 对于集合和数组而言，其主要区别如下</p><ul><li>数组是静态的，一个数组实例具有固定的大小，集合是动态的，可以根据实际需要动态扩展大小</li><li>数组既可以保存基本类型，也可保存引用类型，集合只能保存引用类型，在保存基本类型的时候会自动装箱</li></ul><h2 id="集合整体框架分析">集合整体框架分析</h2><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/collections-all-structure.png"></p><p>首先看下集合的整体框架图，对于集合而言主要分为两个部分：Collection 和 Map，其中 Collection 主要保存的是单个元素，而 Map 则可以将某些对象与其它一些对象存在的关系用 key-value 方式保存下来。接下来我们将就这两个部分展开分析。</p><h3 id="collection-接口">Collection 接口</h3><h4 id="结构分析">结构分析</h4><p>这里为了方便分析只展示了接口的继承结构</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/collection-structure.png"></p><p>首先查看 Iterable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Itrable 接口中拥有一个 iterator 方法以及两个 1.8 添加的默认方法：</p><ul><li>iterator：返回一个迭代器用于遍历</li><li>forEach：根据给定的 action 处理每个元素</li><li>spliterator：提供了一个用于并行遍历的迭代器，由于这里主要探讨结构设计，所以暂且不展开说明</li></ul><p>看到这里我产生了第一个疑问，为什么 Collection 不直接继承 Iterator 接口，而需要用 Iterable 进行包装之后再继承呢？ 这里假设存在一个 CustomizeCollection 接口在包含了 Collection 接口方法的基础上继承了 Iterator 接口而不是 Iterable（或者是直接包含了 Collection 接口方法以及 Iterator 接口方法），那么当我们实现 CustomizeCollection 接口的时候所得到的 CustomizeClass 类结构将如下图所示：</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/customizeClass.png"> 可以看到如果想实现 CustomizeCollection 则必须要实现 Iterator 接口方法，很显然采用这种方式可能导致在不同的 CustomizeCollection 接口实现类中存在相同的 Itrator 接口方法实现（遍历这一操作某些时候可能是通用的），这样一来就降低了<strong>代码的复用性</strong>，另外从<strong>单一职责</strong>的角度来考虑，CustomizeCollection 接口中揉合了集合元素的管理功能以及迭代器的功能，而采用 Iterable 包装之后则可以将这两个功能进行一定程度上的分割。</p><p>接着从 Collection 又延展出三个接口，这三个接口是对集合功能的具体化：</p><ul><li>Set 表示的是无序、不存在重复元素的集合</li><li>List 表示的是一种有序、可重复元素的集合</li><li>Queue 表示的是一种队列，其实队列也是一种有序的集合，但之所以会单独设计出一个接口的原因在于，Queue 接口去除了很多不需要的功能，使得接口本身更符合<strong>单一职责</strong>以及<strong>接口隔离</strong>原则。</li></ul><h4 id="功能分析">功能分析</h4><p>Collection 接口的功能大致概括如下（暂不介绍 1.8 引入的默认方法）</p><ul><li>增加<ul><li>boolean add(E e) 增加单元元素</li><li>boolean addAll(Collection&lt;? extends E&gt; c) 增加集合 c 的元素</li></ul></li><li>删除<ul><li>boolean remove(Object o) 移除元素</li><li>boolean removeAll(Collection&lt;?&gt; c) 移除集合 c 的元素</li><li>void clear() 清空集合</li></ul></li><li>查询<ul><li>boolean contains(Object o) 查询集合是否存在元素 o</li><li>boolean containsAll(Collection&lt;?&gt; c)查询当前集合是否存在集合 c 中的所有元素</li><li>boolean isEmpty() 查询是否集合为空</li><li>int size() 查询集合的大小</li></ul></li><li>其它<ul><li>Iterator<E> iterator() 返回迭代器</E></li><li>boolean retainAll(Collection&lt;?&gt; c) 取当前集合和集合 c 的交集</li></ul></li></ul><p>Set 接口与 Colleciton 接口定义的方法完全一致</p><p>List 接口在 Collectiion 接口基础上新增了一些与索引有关的方法</p><ul><li>增加<ul><li>void add(int index, E element) 在 index 处插入元素</li></ul></li><li>删除<ul><li>E remove(int index) 删除 index 处的元素</li></ul></li><li>修改<ul><li>E set(int index, E element) 修改 index 的元素为 element</li></ul></li><li>查询<ul><li>E get(int index) 获取 index 处的元素</li><li>int indexOf(Object o) 获取元素 o 第一次出现的 index</li><li>int lastIndexOf(Object o) 获取元素 o 最后一次出现的 index</li></ul></li><li>其它<ul><li>ListIterator<E> listIterator() 返回 ListIterator 类型的迭代器</E></li><li>ListIterator<E> listIterator(int index) 返回从 index 开始的 ListIterator 类型的迭代器</E></li></ul></li></ul><p>Queue 接口新增的方法如下</p><ul><li>出队<ul><li>E peek() 出队但是不删除元素，在队列为空的时候返回 null</li><li>E element() 出队但是不删除元素，在队列为空的时候抛出异常</li><li>E poll() 出队并且删除元素，在队列为空的时候返回null</li><li>E remove() 出队并且删除元素，在队列为空的时候抛出异常</li></ul></li><li>入队<ul><li>boolean offer(E e)</li></ul></li></ul><h3 id="map-接口">Map 接口</h3><h4 id="结构分析-1">结构分析</h4><p>Map 是一个单一的接口，并没有在此基础上进行扩展，但在 Map 接口的内部有一个 Entry 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Entry 里面封装的都是和 Map 中元素有关的操作，这一接口主要用来规定 Map 中用来存储 key-value 所需要提供的功能</p><h4 id="功能分析-1">功能分析</h4><p>Map 接口的功能大致如下：</p><ul><li>增加或修改<ul><li>V put(K key, V value) 存储 key 和 value，如果 key 已经存在则会将原来的 value 替换为新的 value</li><li>void putAll(Map&lt;? extends K, ? extends V&gt; m) 将 m 中的 key 和 value 添加到当前 Map 中</li></ul></li><li>删除<ul><li>V remove(Object key) 移除指定的 key 以及关联的 value</li><li>void clear() 清空 Map</li></ul></li><li>查找<ul><li>V get(Object key) 获取 key 关联的 value</li><li>boolean containsKey(Object key) 判断当前 Map 是否包含指定的 key</li><li>boolean containsValue(Object value) 判断当前Map 是否包含指定的 value</li><li>boolean isEmpty() 判断当前 Map 是否为空</li><li>int size() 获取当前 Map 的大小</li></ul></li><li>其它<ul><li>Set<K> keySet() 将 key 生成 Set 集合</K></li><li>Collection<V> values() 将 value 生成集合</V></li><li>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 将 Map 中保存的元素生成 Set 集合，一般用于遍历集合</li></ul></li></ul><p>从 Map 接口所提供的方法来看，大部分方法其实与 Collection 接口中无异，只是在 Collection 中是对单个元素进行操作，但是在 Map 接口中是对 key-value 这种关联元素进行操作。</p><h2 id="总结">总结</h2><p>Java 集合框架以 Colleciton 和 Map 为基础，高度抽象了对单个元素以及键值对的操作，而在此基础上为了减轻业务开发难度，集合框架又提供了多个实现类以供使用，尽管看起来错综复杂，但是只要了解核心的接口之间的继承关系便可对集合框架有个较为清晰的认识。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;集合类应该是平时使用的非常频繁的类了，但是对其内部构成却一直不太清晰，所以希望通过本篇文章尝试去理解集合框架的整体设计以及集合存在的必要性。在开始分析之前首先让我们思考以下问题：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;集合存在的意义，集合和数组的区别&lt;/li&gt;
&lt;li&gt;集合框架的设计意图&lt;/li&gt;
&lt;li&gt;集合的常用操作&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Archived" scheme="https://www.ikroal.cn/categories/Archived/"/>
    
    
    <category term="Java" scheme="https://www.ikroal.cn/tags/Java/"/>
    
    <category term="集合" scheme="https://www.ikroal.cn/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Android启动过程简析（四）之Lanucher的启动</title>
    <link href="https://www.ikroal.cn/posts/3c13d9e0.html"/>
    <id>https://www.ikroal.cn/posts/3c13d9e0.html</id>
    <published>2018-02-28T14:55:07.000Z</published>
    <updated>2021-12-24T05:57:00.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>通过<a href="/posts/62e007c4.html" title="Android启动过程简析（三）">Android启动过程简析（三）</a>这篇文章我们已经大致了解了服务是如何被启动的，接着本文将会分析系统启动的最后一步，即 Launcher 的启动。<span id="more"></span></p><h2 id="lanucher的启动流程">Lanucher的启动流程</h2><p>在 SystemServer 中启动的这么多服务当中 ActivityManagerService 是负责四大组件的启动、切换、调度的，所以 Launcher 的启动与 ActivityManagerService 离不开关系</p><p>frameworks/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We now tell the activity manager it is okay to run third party</span></span><br><span class="line">    <span class="comment">// code.  It will call back into us once it has gotten to the state</span></span><br><span class="line">    <span class="comment">// where third party code can really run (but before it has actually</span></span><br><span class="line">    <span class="comment">// started launching the initial applications), for us to complete our</span></span><br><span class="line">    <span class="comment">// initialization.</span></span><br><span class="line">    mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startSystemUi(context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">&quot;starting System UI&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 startOtherServices 中调用了 mActivityManagerService 的 systemReady 方法，并在传入的 Runnable 对象中启动了 SystemUi，接着继续查看 systemReady 方法</p><p>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//第一次为false不会进入</span></span><br><span class="line">        <span class="keyword">if</span> (mSystemReady) &#123;</span><br><span class="line">            <span class="comment">// If we&#x27;re done calling all the receivers, run the next &quot;boot phase&quot; passed in</span></span><br><span class="line">            <span class="comment">// by the SystemServer</span></span><br><span class="line">            <span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                goingCallback.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line">        mSystemReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// Make sure we have no pre-ready processes sitting around.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//执行传入的Runnable对象</span></span><br><span class="line">    <span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) goingCallback.run();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// Only start up encryption-aware persistent apps; once user is</span></span><br><span class="line">        <span class="comment">// unlocked we&#x27;ll come back around and start unaware apps</span></span><br><span class="line">        startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start up initial activity.</span></span><br><span class="line">        mBooting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// Enable home activity for system user, so that the system can always boot</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//启动Lanucher的主Activity</span></span><br><span class="line">        startHomeActivityLocked(currentUserId, <span class="string">&quot;systemReady&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        mUserController.sendUserSwitchBroadcastsLocked(-<span class="number">1</span>, currentUserId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 systemReady 方法中会调用 startHomeActivityLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startHomeActivityLocked</span><span class="params">(<span class="keyword">int</span> userId, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL</span><br><span class="line">            &amp;&amp; mTopAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We are running in factory test mode, but unable to find</span></span><br><span class="line">        <span class="comment">// the factory test app, so just sit around displaying the</span></span><br><span class="line">        <span class="comment">// error message and don&#x27;t try to start anything.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建启动Lanucher主Activity的Intent对象</span></span><br><span class="line">    Intent intent = getHomeIntent();</span><br><span class="line">    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">        <span class="comment">// Don&#x27;t do this if the home app is currently being</span></span><br><span class="line">        <span class="comment">// instrumented.</span></span><br><span class="line">        aInfo = <span class="keyword">new</span> ActivityInfo(aInfo);</span><br><span class="line">        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">        ProcessRecord app = getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                aInfo.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span> || app.instrumentationClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            <span class="comment">//启动Lanucher主Activity</span></span><br><span class="line">            mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">&quot;No home screen found for &quot;</span> + intent, <span class="keyword">new</span> Throwable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 startHomeActivityLocked 方法之后可以看到调用了 getHomeIntent 返回了一个 Intent，我们都知道启动一个 Activity 的信息都是通过 Intent 进行传递的，所以继续查看 getHomeIntent 看看 Intent 包含的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Intent <span class="title">getHomeIntent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mTopAction 是 android.intent.action.MAIN</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(mTopAction, mTopData != <span class="keyword">null</span> ? Uri.parse(mTopData) : <span class="keyword">null</span>);</span><br><span class="line">    intent.setComponent(mTopComponent);</span><br><span class="line">    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getHomeIntent 中首先创建了一个 Intent 对象，然后给这个对象增加了一个 category，category 对应的信息是 android.intent.category.HOME，查找 Lanucher3 的 AndroidManifest.xml 可以看见</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.android.launcher3.Launcher&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:clearTaskOnLaunch</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:stateNotNeeded</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;adjustPan&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;nosensor&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">&quot;keyboard|keyboardHidden|navigation&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:resumeWhilePausing</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.HOME&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.MONKEY&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这说明即将启动的 Activity 是 com.android.launcher3.Launcher，现在回到 startHomeActivityLocked 方法中，继续往下看可以知道在得到 Intent 对象之后，最后是通过 ActivityStarter 的 startHomeActivityLocked 启动了 Launcher。之后的部分由于涉及到 Lanucher 源码和 Activity 启动的细致流程，所以就暂时不做分析了。</p><h2 id="总结">总结</h2><p>通过四篇文章的分析对系统启动的过程有了一个大致的了解，但是限于水平有限，有些部分分析的比较粗糙，希望之后在水平提升之后能够对各个部分进行进一步的完善，例如：Binder、ActivityManagerService、Acitvity 的启动过程等等。 最后借用 Gityuan <span class="exturl" data-url="aHR0cDovL2dpdHl1YW4uY29tL2FuZHJvaWQv">Android系统开篇<i class="fa fa-external-link-alt"></i></span>中的一张图片说明系统启动的过程</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/Android-start.png"></p><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRhY2hpODUvYXJ0aWNsZS9kZXRhaWxzLzU2NjY5ODA4">Android系统启动流程（四）Launcher启动过程与系统启动流程<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;通过&lt;a href=&quot;/posts/62e007c4.html&quot; title=&quot;Android启动过程简析（三）&quot;&gt;Android启动过程简析（三）&lt;/a&gt;这篇文章我们已经大致了解了服务是如何被启动的，接着本文将会分析系统启动的最后一步，即 Launcher 的启动。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.ikroal.cn/categories/Android/"/>
    
    
    <category term="SourceCode Analysis" scheme="https://www.ikroal.cn/tags/SourceCode-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>白话深度学习-基础篇</title>
    <link href="https://www.ikroal.cn/posts/f2af5d79.html"/>
    <id>https://www.ikroal.cn/posts/f2af5d79.html</id>
    <published>2018-01-28T04:06:04.000Z</published>
    <updated>2021-12-24T05:57:00.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="收获">收获</h2><p>「白话深度学习与TensorFlow」的基础篇主要内容为“机器学习是什么”、“深度学习是什么”以及“TensorFlow”框架特性与安装，通过阅读基础篇的内容大致了解了以下几个部分：</p><ul><li>机器学习与深度学习的概念</li><li>机器学习与深度学习的区别</li><li>机器学习的常用方法</li><li>安装TensorFlow框架</li></ul><span id="more"></span><h2 id="第一章">第一章</h2><h3 id="机器学习是什么">机器学习是什么</h3><p>机器学习是人类定义一定的计算机算法，让计算机根据输入的样本和一些人类的干预来总结并归纳其特征和特点，并用这些特征和特点与一定的学习目标形成映射关系，进而自动化地做出相应反应的过程。</p><h3 id="机器学习的目的">机器学习的目的</h3><p>人类学习的目的是掌握知识、掌握能力、掌握技巧然后最终能够进行比较复杂的或者高要求的工作。相似的机器学习的最终目的在于让计算机能够独立或者半独立的进行相对复杂或者高要求的工作。</p><blockquote><p>机器学习与非机器学习的区别在于过去的计算机在程序给定的情况下，其行为逻辑就已经确定了，而机器学习则需要通过样本进行统计归纳然后才会确定其行为逻辑。所以通过机器学习可以进行相片识别信息、新闻的自动分类等工作。因为计算机事先是不会知道需要提取的信息在给定的相片中所具备的特征，只有通过机器学习不断的统计归纳才能得出适合识别大多数相片中所需提取的信息的模型。</p></blockquote><h3 id="机器学习的分类">机器学习的分类</h3><p>从学习的种类来说，机器学习一般分为两种：有监督学习和无监督学习<br>有监督学习是指先对给予的样本进行总结得出分类规则，之后根据这个规则进行分类操作，对于有监督学习而言基本分为三个过程：</p><ul><li>训练 训练的过程主要是拿一定具有标签的样本进行统计和归纳总结出一个模型</li><li>验证 验证的过程主要是拿一些未分类的样本对这个模型进行验证，判断其是否具有泛化性(generalization)。</li><li>测试 测试则是用<strong>一定量</strong>的样本判断模型的识别能力</li></ul><p>无监督学习则是在获得训练的向量数据后在没有标签的情况下尝试找出其内部蕴含关系的一种挖掘工作。</p><blockquote><p>有监督学习和无监督学习的区别在于前者的输入数据具有标签，而后者的输入数据没有标签</p></blockquote><h3 id="机器学习的常用方法">机器学习的常用方法</h3><h4 id="聚类">聚类</h4><p>聚类是指将物理对象或抽象对象的集合分组为由彼此类似的对象组成多个类的分析过程</p><blockquote><p>特征形态的相同或近似的划在一个概念下，特征形态不同的划在不同概念下</p></blockquote><p>聚类常用的算法有 K-Means、DBSCAN 等几种，其基本思路都是<strong>利用每个向量之间的距离，从远近判断是否从属于同一类别。</strong></p><h4 id="回归">回归</h4><p>回归是一个「由果索因」的过程，是一种归纳的思想，当我们看到大量的事实所呈现的样态去推断原因或客观蕴含的关系是如何的。 回归的训练过程一般如下：</p><ul><li><p>根据观察和归纳样本（训练集）的结果推断向量和最终的函数值呈现如下映射关系 <span class="math display">\[y=f(x)=wx+b\]</span> 这里的 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(x\)</span> 分别是 <span class="math inline">\(1*n\)</span> 和 <span class="math inline">\(n*1\)</span> 的矩阵，也就是说接下来的问题是求解 w 和 b</p></li><li><p>代入样本值（验证集）得到误差和 <span class="math inline">\(Loss\)</span> <span class="math display">\[Loss=\sum_{i=1}^n|wx_i+b-y_i|\]</span> 这里的 <span class="math inline">\(wx_i+b\)</span> 是根据第一步推断关系计算出的值，<span class="math inline">\(y_i\)</span> 是实际观测到的值，将所有测试的误差相加之后即可得到总的误差，<span class="math inline">\(Loss\)</span> 越小则代表映射关系越精确</p></li></ul><blockquote><p>这里以线性回归为例，至于非线性回归过程是一致的，只是映射关系和 <span class="math inline">\(Loss\)</span> 函数有些不同。</p></blockquote><h4 id="分类">分类</h4><p>分类这个概念一直都很熟悉，具体到机器学习当中则是利用我们编写的分类器对样本进行分类，而判断这种分类器是否合理的原则在于<code>召回率</code>和<code>精确率</code>这两个指标</p><ul><li>召回率是检索出的相关样本和样本库中所有的相关样本的比率，衡量的是分类器的查全率</li><li>精确率是检索出的相关样本数与检索出样本总数的比率，衡量的是分类器的查准率</li></ul><p>分类的训练过程和回归的训练过程基本一致：</p><ol type="1"><li>输入样本和分类标签</li><li>建立映射假说的某个<span class="math inline">\(y=f(x)\)</span></li><li>求解出全局的损失函数<span class="math inline">\(Loss\)</span>和待定系数<span class="math inline">\(w\)</span>的映射关系，<span class="math inline">\(Loss=g(w)\)</span></li><li>通过迭代优化逐步降低<span class="math inline">\(Loss\)</span>，最终找到一个<span class="math inline">\(w\)</span>能使召回率和精确率满足当前场景需要</li></ol><h2 id="第二章">第二章</h2><h3 id="深度学习是什么">深度学习是什么</h3><p>深度学习是指基于深度神经网络「deep neural networks」的学习，也就是深度人工神经网络所进行的学习过程。</p><h3 id="深度神经网络的组成">深度神经网络的组成</h3><p>深度神经网络由多个神经元组成，而神经元是人类受到生物神经细胞结构启发而研究出的一种算法体系，一个完整的神经元由<code>线性模型</code>和<code>激励函数</code>两部分首尾相接组成。基本模型如下：其中<span class="math inline">\(wx+b\)</span>是线性模型，<span class="math inline">\(\int\)</span>表示激励函数</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/Neurons.png"></p><p>常见的激励函数有如下几种：</p><ol type="1"><li><p>Sigmoid 函数 <span class="math display">\[f(x)={1 \over 1+e^{-(wx+b)}}\]</span></p></li><li><p>Tanh 函数 <span class="math display">\[tanh(x)={e^x-e^{-x}\over e^x+e^{-x}}\]</span></p></li><li><p>ReLu 函数 <span class="math display">\[y=max(x,0)\]</span></p></li><li><p>Linear 函数 <span class="math display">\[f(x)=x\]</span></p></li></ol><p>对于神经网络而言主要分为三层：输入层 (input layer)、隐藏层 (hidden layer)、输出层 (output layer)</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/NeuralNetworks.png"></p><p>输入层直接接收输入的向量，不对数据进行任何处理 隐藏层可以有一层或者多层 输出层是最后一层，用于输出整个网络处理的值，这个值可能是一个分类向量值，也可能是一个类似线性回归产生的连续的值</p><h3 id="深度学习和机器学习的区别">深度学习和机器学习的区别</h3><p>深度学习是机器学习的子集，当深度学习和传统的机器学习的区别在于，传统的机器学习通常是需要人提前进行特征提取，把提取过的特征向量化后再丢给模型去训练，这里人要做相当的前置工作。而深度学习通常可以采用 End-to-End 的学习方式，输入的内容只需要做很少的一些归一化 (normalization)、白化 (whitening) 等处理就可以丢给模型去训练，通常不需要人做特征提取的工作。</p><h2 id="第三章">第三章</h2><h3 id="安装-tensorflow-框架">安装 TensorFlow 框架</h3><p>本次安装环境是 macos、Python3</p><ol type="1"><li><p>安装 Anaconda 在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5hY29uZGEuY29tL2Rvd25sb2FkLyNtYWNvcw==">Anaconda 官网<i class="fa fa-external-link-alt"></i></span> 下载 Python3.6 版本 pkg 文件进行安装</p></li><li><p>建立 TensorFlow 运行环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow python=<span class="number">3.6</span></span><br><span class="line">source activate tensorflow</span><br></pre></td></tr></table></figure></li><li><p>安装 TensorFlow</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tensorflow</span><br></pre></td></tr></table></figure></li><li><p>测试 TensorFlow</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello = tf.constant(<span class="string">&#x27;Hello,TensorFlow!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sess = tf.Session()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(sess.run(hello))</span><br><span class="line"><span class="string">b&#x27;Hello,TensorFlow!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = tf.constant(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = tf.constant(<span class="number">32</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(sess.run(a + b))</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;收获&quot;&gt;收获&lt;/h2&gt;
&lt;p&gt;「白话深度学习与TensorFlow」的基础篇主要内容为“机器学习是什么”、“深度学习是什么”以及“TensorFlow”框架特性与安装，通过阅读基础篇的内容大致了解了以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器学习与深度学习的概念&lt;/li&gt;
&lt;li&gt;机器学习与深度学习的区别&lt;/li&gt;
&lt;li&gt;机器学习的常用方法&lt;/li&gt;
&lt;li&gt;安装TensorFlow框架&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Reading Notes" scheme="https://www.ikroal.cn/categories/Reading-Notes/"/>
    
    
    <category term="Deep Learning" scheme="https://www.ikroal.cn/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Android启动过程简析（三）之 SystemServer 进程</title>
    <link href="https://www.ikroal.cn/posts/62e007c4.html"/>
    <id>https://www.ikroal.cn/posts/62e007c4.html</id>
    <published>2018-01-22T15:34:45.000Z</published>
    <updated>2021-12-24T05:57:00.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在<a href="/posts/32f3dbe6.html" title="Android启动过程简析（二）">Android启动过程简析（二）</a>中已经大致分析了 zygote 进程的启动过程当中所做的主要工作，本篇将继续对 SystemServer 的启动过程进行分析。<span id="more"></span></p><h2 id="systemserver-启动过程">SystemServer 启动过程</h2><p>上文说到 SystemServer 进程在 ZygoteInit.java 中被创建，然后便会在 SystemServer 进程调用 handleSystemServerProcess 方法处理 SystemServer 进程的剩余工作</p><p>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SystemServer 进程不需要进行Socket通信，所以关闭</span></span><br><span class="line">    closeServerSocket();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置进程名为system_server</span></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">final</span> String systemServerClasspath = Os.getenv(<span class="string">&quot;SYSTEMSERVERCLASSPATH&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里 parsedArgs.invokeWith 为 null</span></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//创建 SystemServer 的类加载器对象</span></span><br><span class="line">            cl = createSystemServerClassLoader(systemServerClasspath,</span><br><span class="line">                                               parsedArgs.targetSdkVersion);</span><br><span class="line">            </span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将剩余参数传递给 SystemServer</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should never reach here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 handleSystemServerProcess 方法中首先会关闭掉 Socket 连接，然后会根据传递过来的参数设置进程名称，在设置完进程名称之后，由于 parseArgs 的成员 invokeWith 为 null，所以会利用 systemServerClasspath 创建对应的类加载器对象，最后会通过 RuntimeInit 的 zygoteInit 方法将剩余参数传递给 SystemServer。</p><h3 id="runtimeinit-分析">RuntimeInit 分析</h3><p>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;RuntimeInit: Starting application from zygote&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;RuntimeInit&quot;</span>);</span><br><span class="line">    redirectLogStreams();</span><br><span class="line"></span><br><span class="line">    commonInit();</span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zygoteInit 中依次调用了 nativeZygoteInit 和 applicationInit，其中前者启动了一个线程池，而后者则会调用了 SystemServer 类的 main 方法。</p><h4 id="启动线程池">启动线程池</h4><p>nativeZygoteInit 实际上对应着 com_android_internal_os_RuntimeInit_nativeZygoteInit</p><p>frameworks/base/core/jni/AndroidRuntime.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;nativeFinishInit&quot;</span>, <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;nativeZygoteInit&quot;</span>, <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;nativeSetExitWithoutCleanup&quot;</span>, <span class="string">&quot;(Z)V&quot;</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_com_android_internal_os_RuntimeInit</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">jniRegisterNativeMethods</span>(env, <span class="string">&quot;com/android/internal/os/RuntimeInit&quot;</span>,</span><br><span class="line">        gMethods, <span class="built_in">NELEM</span>(gMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看 com_android_internal_os_RuntimeInit_nativeZygoteInit 可以知道最终调用了 gCurRuntime 的 onZygoteInit 方法，而 gCurRuntime 实际上是一个 AndroidRuntime 的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;<span class="built_in">onZygoteInit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onZygoteInit 的具体实现在 AndroidRuntime 的子类 AppRuntime 中，可以看到最终通过 startThreadPool 启动了线程池</p><p>frameworks/base/cmds/app_process/app_main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::<span class="built_in">self</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;App process: starting thread pool.\n&quot;</span>);</span><br><span class="line">    proc-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用-systemserver-的-main-方法">调用 SystemServer 的 main 方法</h4><p>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 argv 构建 RuntimeInit.Arguments，这里的 argv[] 实际上是 “com.android.server.SystemServer”</span></span><br><span class="line">    <span class="keyword">final</span> Arguments args;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        Slog.e(TAG, ex.getMessage());</span><br><span class="line">        <span class="comment">// let the process exit</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The end of of the RuntimeInit event (see #zygoteInit).</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining arguments are passed to the start class&#x27;s static main</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 applicationInit 方法中会对 argv 进行解析创建 RuntimeInit.Arguments 参数，然后会调用 invokeStaticMain</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取SystemServer的Class对象</span></span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Missing class when invoking static main &quot;</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取 main 方法</span></span><br><span class="line">        m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Missing static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Problem getting static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取方法修饰符，判断是否是入口 main 方法</span></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Main method is not public and static on &quot;</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">     * by invoking the exception&#x27;s run() method. This arrangement</span></span><br><span class="line"><span class="comment">     * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">     * up the process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 invokeStaticMain 方法中会通过方法签名获取到 SystemServer 的 main 方法，之后会抛出 MethodAndArgsCaller 异常，然后在 ZygoteInit 的 main 方法中进行捕获，捕获之后会执行 MethodAndArgsCaller 的 run 方法，而在 run 方法中会完成对 SystemServer 的 main 方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MethodAndArgsCaller 的 run 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        Throwable cause = ex.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ZygoteInit 捕获异常</span></span><br><span class="line"><span class="comment">//frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="systemserver-分析">SystemServer 分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SystemServer 的 main 方法中创建了一个 SystemServer 对象，并调用了其 run 方法，所以继续看 run 方法部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//创建 SystemServer 主线程的 Looper</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 mSystemContext</span></span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 SystemServiceManager 对象</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For debug builds, log event loop stalls to dropbox for analysis.</span></span><br><span class="line">    <span class="keyword">if</span> (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Enabled StrictMode for system server main thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 run 方法中，首先调用 Looper.prepareMainLooper() 创建了当前主线程的 Looper，之后会调用 createSystemContext 初始化 mSystemContext 实例，这里的 mSystemContext 是一个 ContextImpl 实例，主要用于初始化一些 Service，最后则是启动系统各项服务。</p><h4 id="启动系统服务">启动系统服务</h4><p>从启动服务的过程中看，系统将服务分为三类：</p><ol type="1"><li><p>引导服务----------startBootstrapServices()</p><p>Installer、ActivityManagerService、PackageManagerService 等</p></li><li><p>核心服务----------startCoreServices()</p><p>BatteryService、UsageStatsService、WebViewUpdateService</p></li><li><p>其它服务----------startOtherServices()</p><p>AlarmManagerService、VibratorService 等</p></li></ol><p>而对于服务的启动方式而言也分为三种（启动方式与服务类别并不对应）：</p><ol type="1"><li><p>mSystemServiceManager.startService()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> String name = serviceClass.getName();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//创建Service实例</span></span><br><span class="line">        <span class="keyword">final</span> T service;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);</span><br><span class="line">            service = constructor.newInstance(mContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入 List&lt;SystemService&gt; 当中</span></span><br><span class="line">        mServices.add(service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回调 Service 的 onStart 方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            service.onStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failed to start service &quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;: onStart threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出 startService 启动的服务都是 SystemService 的子类，启动的过程是先对服务类进行加载，加载之后进行实例化，实例化之后则会调用实例的 onStart 方法。</p></li><li><p>xxxService.main()</p><p>这种方式主要在启动以下三个服务中用到</p><ul><li><p>PackageManagerService</p></li><li>OtaDexoptService</li><li><p>WindowManagerService</p></li></ul><p>这里以 PackageManagerService 为例进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PackageManagerService <span class="title">main</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Self-check for initial settings.</span></span><br><span class="line">    PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line"></span><br><span class="line">    PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context, installer,</span><br><span class="line">            factoryTest, onlyCore);</span><br><span class="line">    m.enableSystemUserPackages();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册启动服务</span></span><br><span class="line">    ServiceManager.addService(<span class="string">&quot;package&quot;</span>, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 main 方法中直接创建了 PackageManagerService 的实例，然后通过 ServiceManager 进行注册启动。</p></li><li><p>ServiceManager.addService()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceManager.addService(<span class="string">&quot;scheduling_policy&quot;</span>, <span class="keyword">new</span> SchedulingPolicyService());</span><br></pre></td></tr></table></figure><p>ServiceManager 涉及到 Binder 暂不做分析</p></li></ol><p>上文中提到了服务的注册，对于服务的注册而言实际上分为两种：一是 ServiceManager.addService，二是 LocalServices.addService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class is used in a similar way as ServiceManager, except the services registered here</span></span><br><span class="line"><span class="comment"> * are not Binder objects and are only available in the same process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Once all services are converted to the SystemService interface, this class can be absorbed</span></span><br><span class="line"><span class="comment"> * into SystemServiceManager.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalServices</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LocalServices</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayMap&lt;Class&lt;?&gt;, Object&gt; sLocalServiceObjects =</span><br><span class="line">            <span class="keyword">new</span> ArrayMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a service instance of the specified interface to the global registry of local services.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addService</span><span class="params">(Class&lt;T&gt; type, T service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLocalServiceObjects) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sLocalServiceObjects.containsKey(type)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Overriding service registration&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sLocalServiceObjects.put(type, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 LocalServices 的类描述可以知道 LocalServices 与 ServiceManager 用处类似，不同点在于ServiceManager 用于不同进程间获取 Service，而 LocalServices 只能够用于同一进程中获取 Service。</p><h2 id="总结">总结</h2><p>至此大概就能知道在 SystemServer 启动过程中主要做了三件事</p><ol type="1"><li>开启线程池</li><li>创建 SystemServerManager 对象负责继承自 SystemService 的服务的创建、启动以及生命周期的管理</li><li>启动系统的服务</li></ol><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cDovL2dpdHl1YW4uY29tLzIwMTYvMDIvMTQvYW5kcm9pZC1zeXN0ZW0tc2VydmVyLw==">Android系统启动-SystemServer上篇<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpdHl1YW4uY29tLzIwMTYvMDIvMjAvYW5kcm9pZC1zeXN0ZW0tc2VydmVyLTIv">Android系统启动-SystemServer下篇<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpdHl1YW4uY29tLzIwMTYvMTAvMDEvc3lzdGVtX3NlcnZpY2VfY29tbW9uLw==">Android系统服务的注册方式<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRhY2hpODUvYXJ0aWNsZS9kZXRhaWxzLzU2NjY5ODA4">Android系统启动流程（三）解析SyetemServer进程启动过程<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;/posts/32f3dbe6.html&quot; title=&quot;Android启动过程简析（二）&quot;&gt;Android启动过程简析（二）&lt;/a&gt;中已经大致分析了 zygote 进程的启动过程当中所做的主要工作，本篇将继续对 SystemServer 的启动过程进行分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.ikroal.cn/categories/Android/"/>
    
    
    <category term="SourceCode Analysis" scheme="https://www.ikroal.cn/tags/SourceCode-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之注解</title>
    <link href="https://www.ikroal.cn/posts/7f462002.html"/>
    <id>https://www.ikroal.cn/posts/7f462002.html</id>
    <published>2018-01-15T14:07:15.000Z</published>
    <updated>2021-12-24T05:57:00.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>关于注解首先请思考一下以下问题：</p><ul><li>注解是什么？</li><li>注解的主要使用场景？</li><li>注解可以分为哪些类型？</li><li>注解的处理过程？</li></ul><p>接下来我们将对这几个问题进行探讨<span id="more"></span></p><h2 id="注解简介">注解简介</h2><blockquote><p><em>Annotations</em>, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.</p></blockquote><p>上述是官方给出的关于注解的定义，大致意思是注解是<strong>元数据</strong>（MetaData）的一种形式，它用于提供一些和程序元素有关的元数据，这些数据本身不属于程序，并且也不会直接影响程序的操作。 为了更直观的理解注解的概念，我们还需要进一步了解元数据这个概念，关于元数据 Wiki 上的描述如下：</p><blockquote><p><strong>Metadata</strong> is &quot;data [information] that provides information about other data&quot;，For example, a digital image may include metadata that describes how large the picture is, the color depth, the image resolution, when the image was created, the shutter speed, and other data.</p></blockquote><p>元数据是描述数据的数据，对于一张相片而言元数据包括相片的大小、色彩深度、图片的分辨率、图片建立时间以及快门速度等相关数据。 结合两者可以得到：<strong>注解是一种用于描述程序元素信息的修饰符，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量。</strong> 这里再结合具体的场景进行理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindView(R.id.toolbar)</span></span><br><span class="line"><span class="keyword">public</span> Toolbar mToolbar;</span><br></pre></td></tr></table></figure><p>对于成员变量 mToolbar 而言，其基本的信息包含 width、heigth、id，通过注解我们能够很明确的描述它的 id 信息。</p><h2 id="注解的主要使用场景">注解的主要使用场景</h2><p>要明白注解的使用场景，首先需要了解的是注解的主要作用：</p><blockquote><ul><li><p><strong>Information for the compiler</strong>— Annotations can be used by the compiler to detect errors or suppress warnings.</p></li><li><p><strong>Compile-time and deployment-time processing</strong>— Software tools can process annotation information to generate code, XML files, and so forth.</p></li><li><p><strong>Runtime processing</strong>— Some annotations are available to be examined at runtime.</p></li></ul></blockquote><p>接下来举几个常见的例子说明：</p><ol type="1"><li><p>为编译器提供信息用于检测错误或者抑制警告</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItems</span><span class="params">(<span class="meta">@NonNull</span> String item)</span> </span>&#123;</span><br><span class="line">  List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  list.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译时和部署时通过对注解进行处理生成代码、XML 文件等</p><p>比较常见的如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0pha2VXaGFydG9uL2J1dHRlcmtuaWZl">butterknife<i class="fa fa-external-link-alt"></i></span>，butterknife 能够通过注解自动生成 findViewById 的代码，<strong>有助于减轻样板代码的负担</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindView(R.id.toolbar)</span></span><br><span class="line"><span class="keyword">public</span> Toolbar mToolbar;</span><br></pre></td></tr></table></figure></li><li><p>运行时通过注解进行检查处理</p><p>在运行时我们可以通过反射机制对注解提供的信息进行处理，然后实现需要的功能。</p></li></ol><p>在明确了注解的主要作用之后，注解的使用场景就已经呼之欲出了，<strong>当我们需要为程序中的元素提供信息，并且这些信息需要得到处理的时候，就可以考虑使用注解。</strong></p><h2 id="注解的分类">注解的分类</h2><h3 id="基本注解">基本注解</h3><p>Java 提供了 5 个基本的 Annotation</p><table><thead><tr class="header"><th style="text-align: left;">注解名</th><th style="text-align: left;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><span class="citation" data-cites="Override">@Override</span></td><td style="text-align: left;">限定重写父类方法</td></tr><tr class="even"><td style="text-align: left;"><span class="citation" data-cites="Deprecated">@Deprecated</span></td><td style="text-align: left;">表示某个程序元素已经过时</td></tr><tr class="odd"><td style="text-align: left;"><span class="citation" data-cites="SuppressWarnings">@SuppressWarnings</span></td><td style="text-align: left;">抑制编译器的警告</td></tr><tr class="even"><td style="text-align: left;"><span class="citation" data-cites="SafeVarargs">@SafeVarargs</span></td><td style="text-align: left;">抑制堆污染警告</td></tr><tr class="odd"><td style="text-align: left;"><span class="citation" data-cites="FunctionalInterface">@FunctionalInterface</span></td><td style="text-align: left;">指定某个接口必须是函数式接口</td></tr></tbody></table><p>接下来聊聊它们的使用</p><ol type="1"><li><p>Override</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FatherClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overridedMethod</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAnnotationUse</span> <span class="keyword">extends</span> <span class="title">FatherClass</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overridedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.overridedMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Override的主要作用是：<ol type="1"><li><p>帮助检查是否正确的复写了父类中的已有方法（如果不小心拼写错误或者方法签名对不上被覆盖的方法，编辑器都会发出警告信息）</p></li><li><p>表示当前方法定义将覆盖超类的方法。</p><p>如果没有正确的复写父类中的方法则会提示 <strong>Method does not override method from its superclass</strong>。</p><p><img src="/posts/7f462002/Override-error.jpg"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnhpc8zywyj30el00qglf.jpg"></p></li></ol></li><li><p>Deprecated 在 FatherClass 增加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deprecatedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 BaseAnnotationUse 中增加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDeprecatedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> deprecatedMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候将会看到 deprecatedMethod() 显示红色，并且编辑器提示<strong>deprecatedMethod() 已经过时了</strong></p></li></ol><p><img src="/posts/7f462002/deprecated-error.jpg"></p><ol start="3" type="1"><li><p>SuppressWarning 对 BaseAnnotationUse 中的 useDeprecatedMethod 方法进行如下修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDeprecatedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> deprecatedMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过增加 SuppressWarning 抑制了 Deprecated 的警告，deprecatedMethod() 的红色将会消失</p></li></ol><p><img src="/posts/7f462002/suppressWarning.jpg"></p><ol start="4" type="1"><li><p>SafeVarargs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">faultyMethod</span><span class="params">(List&lt;String&gt;... listStrArray)</span> </span>&#123;</span><br><span class="line">  List[] listArray = listStrArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当把一个不带泛型的对象赋给一个带泛型的变量的时候，往往将会导致”堆污染“，所以在 Java 7 中增加了 SafeVarargs 用于抑制堆污染的警告，SafeVarargs 只能用在参数长度可变的方法或构造方法上，且方法必须声明为static或final，否则会出现编译错误。</p><p><img src="/posts/7f462002/SafeVarargs.jpg"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnhpc97402j30ns00wglh.jpg"></p></li><li><p>FunctionalInterface</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseInterface</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FunctionalInterface 是 Java 8 专门为 Lambda 表达式新增的，通过 FunctionalInterface 可以限制接口中只能存在一个抽象方法，如果在 BaseInterface 接口中新增抽象方法，编译时将会提示 BaseInterface 不是函数式接口。</p><p><img src="/posts/7f462002/FunctionalInterface.jpg"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnhpc8exc7j30od01vgll.jpg"></p></li></ol><h3 id="元注解">元注解</h3><p>JDK 在 java.lang.annotation 中内置了 6 种元注解，除了 Native 之外都用于修饰其它的 Annotation 定义</p><table><thead><tr class="header"><th style="text-align: left;">注解名</th><th style="text-align: left;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><span class="citation" data-cites="Retention">@Retention</span></td><td style="text-align: left;">指定被修饰的注解的保留时间</td></tr><tr class="even"><td style="text-align: left;"><span class="citation" data-cites="Target">@Target</span></td><td style="text-align: left;">指定被修饰的注解可以修饰的程序元素</td></tr><tr class="odd"><td style="text-align: left;"><span class="citation" data-cites="Documented">@Documented</span></td><td style="text-align: left;">指定被修饰的注解可以被 javadoc 提取成文档</td></tr><tr class="even"><td style="text-align: left;"><span class="citation" data-cites="Inherited">@Inherited</span></td><td style="text-align: left;">指定被修饰的注解具有继承性，如果某个类使用了被 <span class="citation" data-cites="Inherited">@Inherited</span> 修饰的注解，那么其子类将自动被该注解修饰</td></tr><tr class="odd"><td style="text-align: left;"><span class="citation" data-cites="Repeatable">@Repeatable</span></td><td style="text-align: left;">用于定义重复注解</td></tr><tr class="even"><td style="text-align: left;"><span class="citation" data-cites="Native">@Native</span></td><td style="text-align: left;">表示定义常量值的字段可以从本地代码引用。</td></tr></tbody></table><p>接下来主要介绍前五种，<span class="citation" data-cites="Native">@Native</span> 实在是不常用</p><ol type="1"><li><p>Retention</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the retention policy.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Retention的定义如上，其拥有一个 RetentionPolicy 类型的成员变量，RetentionPolicy 是枚举类，主要有三个枚举值：</p><ul><li>RetentionPolicy.SOURCE 注解只能保留在源文件当中，编译器不会编译这种注解</li><li>RetentionPolicy.CLASS 注解能够保留在 class 文件当中，但是当程序运行的时候，JVM 不能够获取到注解信息</li><li>RetentionPolicy.RUNTIME 注解能够保留在 class 文件当中，程序运行的时候，JVM 也能够获取到注解信息，程序能够通过反射去获取到 Annotation 信息</li></ul></li><li><p>Target</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">  * can be applied to.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">  * can be applied to</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ElementType 也是一个枚举类，其枚举值和意义是：</p><ul><li>ElementType.TYPE 表明注解可以修饰类、接口或者枚举定义</li><li>ElementType.FIELD 表明注解可以修饰成员变量</li><li>ElementType.METHOD 表明注解可以修饰方法定义</li><li>ElementType.PARAMETER 表明注解可以修饰参数</li><li>ElementType.CONSTRUCTOR 表明注解可以修饰构造函数</li><li>ElementType.LOCAL_VARIABLE 表明注解可以修饰局部变量</li><li>ElementType.ANNOTATION_TYPE 表明注解可以修饰注解</li><li>ElementType.PACKAGE 表明注解可以修饰包定义</li><li>ElementType.TYPE_PARAMETER 表明注解只能定义程序元素的修饰</li><li>ElementType.TYPE_USE 表明注解不仅可以在定义程序元素的时候使用，还可以在<strong>创建对象、类型转换、使用 implements 实现接口、使用 throws 声明抛出异常</strong>的时候使用</li></ul></li><li><p>Documented 对于使用被 <span class="citation" data-cites="Documented">@Documented</span> 修饰的注解和不带 <span class="citation" data-cites="Documented">@Documented</span> 修饰的注解，其区别如下：</p></li></ol><figure><img src="/posts/7f462002/Documented.jpg" alt="annotation_1"><figcaption>annotation_1</figcaption></figure><figure><img src="/posts/7f462002/noDocumented.jpg" alt="annotation_2"><figcaption>annotation_2</figcaption></figure><ol start="4" type="1"><li><p>Inherited</p><p>Inherited 的继承作用可以通过以下例子来体现，首先创建一个 Interitable 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inheritable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个由 Inheritable 修饰的 Base 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inheritable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后创建一个继承自 Base 类的 InheritableTest 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableTest</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否被 Inheritable 注解</span></span><br><span class="line">    System.out.println(InheritableTest.class.isAnnotationPresent(Inheritable.class));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后可以发现结果为 true</p></li><li><p>Repeatable</p><p>Repeatable 是 Java8 新增的注解，用于定义重复注解，在 Java8 之前的重复注解只能写成以下形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Infos(&#123;@Info(name = &quot;zhangsan&quot;), @Info(name = &quot;lisi&quot;)&#125;)</span><br><span class="line">private Person mPerson;</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String mName;</span><br><span class="line">    private int mAge;</span><br><span class="line">    private int mHeight;</span><br><span class="line">    private int mWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 Info 和 Infos 分别是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Info &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Infos &#123;</span><br><span class="line">  </span><br><span class="line">  Info[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Infos 中保留了 Info 的信息，所以 Infos 的保留时间不能比 Info 少，否则编译器将会报错。如果 Info 的保留时间是 RUNTIME，而 Infos 的保留时间是 SOURCE，那么 JVM 最终会丢弃 Infos 以及 Infos 中的 Info 信息，这与 Info 期望的保留时间相矛盾。</p></li></ol><h3 id="自定义注解">自定义注解</h3><p>JDK 内置的注解并不能完全满足我们的需求，大多数情况下我们还需要学会自定义注解，定义一个注解需要用到 <span class="citation" data-cites="Interface">@Interface</span> 关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> View 的 Id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindOnClickListener &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 实现 OnClickListener 接口的类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Class&lt;? extends OnClickListener&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了两个注解用于绑定 View 的 id 以及 点击事件，并且指定了注解可以修饰的元素以及保留时间，可以看到定义一个注解与定义一个接口非常类似，而实际上每个注解都是继承自 Annotation 接口的接口，反编译 BindView 生成的 class 文件可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;BindView.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">com</span>.<span class="title">rookieyang</span>.<span class="title">runtimeannotation</span>.<span class="title">customizeannotation</span>.<span class="title">BindView</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里自定义的注解都是含有成员变量的，而注解除了按照基本注解、元注解、自定义注解进行分类之外，我还可以根据是否包含成员变量将它分为两类：</p><ul><li><p>标记注解：这种注解没有成员变量，它仅仅通过是否存在来提供信息，如@Override、<span class="citation" data-cites="Deprecated">@Deprecated</span></p></li><li><p>元数据注解：这种注解包含成员变量，它通过成员变量提供更多的信息，如@Retention、<span class="citation" data-cites="Target">@Target</span></p></li></ul><h2 id="注解的处理">注解的处理</h2><p>在使用自定义的注解的时候，如果不提供注解的处理工具，注解是不会自动生效的，注解的处理方法主要有两种，一种是运行时处理注解，一种是编译时处理注解。</p><ol type="1"><li><p>运行时处理注解</p><p>运行时处理注解主要利用 Java 的反射机制，接下来将结合具体实例说明如何通过反射处理注解。</p><p>首先利用自定义注解部分定义的两个注解 BindView 和 BindOnClickListener 对 View 进行注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindView(R.id.hello_world)</span></span><br><span class="line"><span class="meta">@BindOnClickListener(CustomizeOnClickListener.class)</span></span><br><span class="line"><span class="keyword">private</span> Button mHelloWorld;</span><br></pre></td></tr></table></figure><p>然后在 Activity 中定义一个 CustomizeOnClickListener 内部类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CustomizeOnClickListener implements OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View view) &#123;</span><br><span class="line">    Toast.makeText(MainActivity.this, R.string.hello_world,</span><br><span class="line">    Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着定义一个处理注解的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Field[] fields = obj.getClass().getDeclaredFields();</span><br><span class="line">    Activity activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Activity)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的参数不是Activity&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    activity = (Activity) obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        View view = <span class="keyword">null</span>;</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span> );</span><br><span class="line">        BindView bindView = field.getAnnotation(BindView.class);</span><br><span class="line">        BindOnClickListener bindOnClickListener = field</span><br><span class="line">        .getAnnotation(BindOnClickListener.class);</span><br><span class="line">        <span class="comment">//判断是否是 View</span></span><br><span class="line">        <span class="keyword">boolean</span> isView = View.class.isAssignableFrom(field.getType());</span><br><span class="line">        <span class="keyword">if</span> (bindView != <span class="keyword">null</span> &amp;&amp; isView) &#123;</span><br><span class="line">          view = activity.findViewById(bindView.value());</span><br><span class="line">          <span class="comment">//设置 obj 对象当中的 field 值为 view</span></span><br><span class="line">          field.set(obj, view);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bindOnClickListener != <span class="keyword">null</span> &amp;&amp; isView &amp;&amp; view != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Class&lt;? extends OnClickListener&gt; listener = bindOnClickListener.value();</span><br><span class="line">          <span class="comment">//实例化 CustomizeOnClickListener 内部类</span></span><br><span class="line">          OnClickListener onClickListener = listener.getConstructor(</span><br><span class="line">          obj.getClass()).newInstance(activity);</span><br><span class="line">          view.setOnClickListener(onClickListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.i(obj.getClass().getSimpleName(), e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 Activity 中调用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationProcess.process(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li><li><p>编译时处理注解</p><p>相对与运行时利用反射处理注解会有性能损失而言，编译时处理注解利用 APT（Annotation Processing Tool）对注解进行处理然后生成代码、XML 文件，利用 APT 去处理注解性能更好。参照 JDK 文档中对于 Processor 接口的描述，我们可以大致知道注解处理器的工作流程</p><blockquote><ol type="1"><li>If an existing Processor object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</li><li>Next, the tool calls the init method with an appropriate ProcessingEnvironment.</li><li>Afterwards, the tool calls getSupportedAnnotationTypes, getSupportedOptions, and getSupportedSourceVersion. These methods are only called once per run, not on each round.</li><li>As appropriate, the tool calls the process method on the Processor object; a new Processor object is not created for each round.</li></ol></blockquote><p>编译工具将会通过注解处理器的无参构造函数实例化一个注解处理器对象，然后调用注解处理器的 init 方法并传入 ProcessingEnvironment，之后则调用 getSupportedAnnotationTypes，getSupportedOptions和getSupportedSourceVersion，最后将会调用 process 方法。 接下来将说明如何利用 APT 生成一个类文件用于显示 HelloWorld：</p><p>首先需要明确希望生成的类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rookieyang.myannotationtwo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(context, <span class="string">&quot;HelloWorld&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要生成这个类文件需要获取到两点信息：<strong>包名和类名</strong>，通过包名可以使类文件生成在使用注解的包下，便于解析注解的时候加载类文件，通过类名加上 &quot;_HelloWorld&quot; 确保生成的类文件唯一存在，同时也达到了使用注解的类和生成的类绑定的效果。</p><p>接下来需要创建两个 Module，其中一个定义了所有的注解，另外一个定义了 APT，之所以需要定义两个 Module 的原因，其一为了让工程结构更清晰，另一方面定义 APT 需要用到 javax 包。整体的工程结构如下图所示：</p><p><img src="/posts/7f462002/project-structure.jpg"></p><p>之后需要为 annotations-compiler 和 app 模块引入相关依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">annotations-compiler 模块</span><br><span class="line">compile <span class="string">&#x27;com.google.auto.service:auto-service:1.0-rc3&#x27;</span></span><br><span class="line"><span class="function">compile <span class="title">project</span><span class="params">(path: <span class="string">&#x27;:annotations&#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">app 模块</span></span><br><span class="line"><span class="function">compile <span class="title">project</span><span class="params">(path: <span class="string">&#x27;:annotations&#x27;</span>)</span></span></span><br><span class="line"><span class="function">annotationProcessor <span class="title">project</span><span class="params">(<span class="string">&#x27;:annotations-compiler&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure><p>其中 auto-service 的作用是帮助我们生成下列文件，主要作用是声明注解处理器。</p><p><img src="/posts/7f462002/META-INF.jpg"></p><p>annotationProcessor 则是为模块指定注解处理器</p><p>配置之后首先在 annotations 模块定义一个 HelloWorld 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 annotations-compiler 模块编写对应注解处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识一个注解处理器</span></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationsCompiler</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Elements mElements;</span><br><span class="line">  <span class="keyword">private</span> Filer mFiler;</span><br><span class="line">  <span class="keyword">private</span> Messager mMessager;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 用于初始化 mElements、mFiler、mMessager</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.init(processingEnvi);</span><br><span class="line"></span><br><span class="line">    mElements = processingEnvi.getElementUtils();</span><br><span class="line">    mFiler = processingEnvi.getFiler();</span><br><span class="line">    mMessager = processingEnvi.getMessager();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> elements 实际上传入的都是 &#123;<span class="doctag">@link</span> #getSupportedAnnotationTypes()&#125;</span></span><br><span class="line"><span class="comment">  * 中支持的并且被扫描到（使用过）注解元素，例如这里获取到的类元素就是 HelloWorld 注解</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> roundEnvi 一个注解处理工具框架，通过它可以查询到使用了注解的元素</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回处理结果</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements,</span></span></span><br><span class="line"><span class="params"><span class="function">  RoundEnvironment roundEnvi)</span> </span>&#123;</span><br><span class="line">    String packageName;</span><br><span class="line">    String className;</span><br><span class="line">    <span class="comment">//获取使用了 HelloWorld 注解的元素</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : roundEnvi.getElementsAnnotatedWith(HelloWorld.class)) &#123;</span><br><span class="line">      <span class="comment">//通过 Elements 去获取包名</span></span><br><span class="line">      packageName = mElements.getPackageOf(element).toString();</span><br><span class="line">      <span class="comment">//HelloWorld 注解只能被用在成员变量，所以通过获取外层元素就可以获取到使用注解的元素所在的类</span></span><br><span class="line">      className = element.getEnclosingElement().getSimpleName() + <span class="string">&quot;_HelloWorld&quot;</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过 Filer 指定的路径下创建一个 java 源文件，然后写入对应的代码</span></span><br><span class="line">        JavaFileObject javaFileObject = mFiler.createSourceFile(</span><br><span class="line">        packageName + <span class="string">&quot;.&quot;</span> + className);</span><br><span class="line">        Writer writer = javaFileObject.openWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;package &quot;</span> + packageName + <span class="string">&quot;;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import android.content.Context;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import android.widget.Toast;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;public class &quot;</span> + className + <span class="string">&quot; &#123;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;\tpublic static void show(Context context) &#123;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;\t\tToast.makeText(context,&quot;</span></span><br><span class="line">        + <span class="string">&quot; \&quot;HelloWorld\&quot;, Toast.LENGTH_SHORT).show();\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;\t&#125;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;\n&#125;&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回注解处理器支持的 Java 版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回注解处理器支持的注解集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; annotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span><br><span class="line">      annotationTypes.add(annotation.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> annotationTypes;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回支持的注解类型集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123;</span><br><span class="line">    Set&lt;Class&lt;? extends Annotation&gt;&gt; annotationSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    annotationSet.add(HelloWorld.class);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> annotationSet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来说下几个有助于理解注解处理器的点：</p><ul><li><p>Elements 是一个获取程序元素信息的接口，例如获取元素的包名、判断是否是重写方法，例如</p><p><img src="/posts/7f462002/Elements.jpg"></p></li><li><p>Filer 则是一个支持通过注解处理器创建文件的接口，可以用于创建 Class文件、源文件、资源文件</p><p><img src="/posts/7f462002/Filer.jpg"></p></li><li><p>Messager 则是为注解处理器提供的输出错误信息的接口。</p><p><img src="/posts/7f462002/Messager.jpg"></p></li><li><p>Element 与 Elements 区别在于 Element 是获取单个程序元素信息的接口，而 Elements 可以获取整个程序的元素信息。除了 Element 之外，上述程序还可以看到 TypeElement，而 TypeElement 是一个继承了 Element 接口的接口，用于表示类元素。实际上 JDK 还提供了很多继承自 Element 的接口用于表示程序中的各项元素，具体的 Element 继承结构如下图所示：</p><p><img src="/posts/7f462002/Element.jpg"></p></li></ul><p>在编写完注解处理器之后，最后在 App 模块中编写对应的调用代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获得生成的类的 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; helloClass = Class.forName(getPackageName() + <span class="string">&quot;.&quot;</span></span><br><span class="line">    + getClass().getSimpleName() + <span class="string">&quot;_HelloWorld&quot;</span>);</span><br><span class="line">    <span class="comment">//利用反射取得 show 方法，然后执行对应的方法即可</span></span><br><span class="line">    Method showMethod = helloClass.getMethod(<span class="string">&quot;show&quot;</span>, Context.class);</span><br><span class="line">    showMethod.invoke(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上编译时注解的整个处理过程是利用注解处理器对程序中使用了注解的元素进行遍历，从元素中提取所需的信息，然后生成类文件，最后在程序中加载生成的类并调用其中的方法。</p><p>最后给出本次测试的工程链接 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZpcnN0ZHJlYW0xMC9BbmRyb2lkLVN0dWR5LVByb2plY3QvdHJlZS9tYXN0ZXIvQW5ub3RhdGlvbg==">Annotation 测试<i class="fa fa-external-link-alt"></i></span></p></li></ol><h2 id="总结">总结</h2><p>最后让我们回答开始的几个问题</p><ol type="1"><li><p>注解是一种用于描述程序元素信息的修饰符，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量。</p></li><li><p>当我们需要为程序中的元素提供信息，并且这些信息得到处理的时候，就可以考虑使用注解。</p></li><li><p>按照系统内置的注解，可以分为<strong>基本注解、元注解、自定义注解</strong>。按照是否有成员变量可以分为<strong>标记注解、元数据注解</strong>。按照处理方式，可以分为<strong>运行时注解、编译时注解</strong>。</p></li><li><p>注解的处理过程主要为运行时通过反射处理和编译时通过注解处理器进行处理。</p></li></ol><h2 id="thanks">Thanks</h2><ul><li>《Java 编程思想》</li><li>《疯狂 Java 讲义》</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2phdmEvYW5ub3RhdGlvbnMvaW5kZXguaHRtbA==">Annotation Tutorials<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZG9jX3NnbC9hcnRpY2xlL2RldGFpbHMvNTAzNjcwODM=">自己动手实现Java注解（Java Annotation in Action）<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2I2YjMyODM5NjhlMA==">注解处理器（Annotation Processor）原理简析<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS93aG9pc2xjai9wLzYxNjg2NDEuaHRtbA==">Android注解使用之通过annotationProcessor注解生成代码实现自己的ButterKnife框架<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS93aG9pc2xjai9wLzYxNDg0MTAuaHRtbA==">Android注解使用之注解编译android-apt如何切换到annotationProcessor<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;关于注解首先请思考一下以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注解是什么？&lt;/li&gt;
&lt;li&gt;注解的主要使用场景？&lt;/li&gt;
&lt;li&gt;注解可以分为哪些类型？&lt;/li&gt;
&lt;li&gt;注解的处理过程？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们将对这几个问题进行探讨&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.ikroal.cn/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.ikroal.cn/tags/Java/"/>
    
    <category term="注解" scheme="https://www.ikroal.cn/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动过程简析（二）之 zygote 进程</title>
    <link href="https://www.ikroal.cn/posts/32f3dbe6.html"/>
    <id>https://www.ikroal.cn/posts/32f3dbe6.html</id>
    <published>2017-11-05T15:30:49.000Z</published>
    <updated>2021-12-24T05:57:00.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在 <a href="/posts/da66bd78.html" title="Android启动过程简析（一）">Android启动过程简析（一）</a>中我们已经分析过了 init 进程是如何被启动的，本篇文章将会继续分析 zygote 启动过程以及作用。<span id="more"></span></p><h2 id="zygote-启动过程">zygote 启动过程</h2><p>zygote 进程创建之后会首先进入到 app_main.cpp 的 main 函数当中去，所以首先对 app_main 进行分析</p><h3 id="app_main-分析">app_main 分析</h3><p>frameworks/base/cmds/app_process/app_main.cpp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建 AppRuntime 对象</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv)</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析运行时参数，当遇到无法识别的选项时停止</span></span><br><span class="line">    bool zygote = <span class="keyword">false</span>;</span><br><span class="line">    bool startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">    bool application = <span class="keyword">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused &quot;parent dir&quot; argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">      <span class="comment">//如果传入的参数有 ”--zygote“ 则将 zygote 置为 true</span></span><br><span class="line">        <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="keyword">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">          <span class="comment">//如果传入的参数有 &quot;--start-system-server&quot; 则将 startSystemServer 置为 true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">  <span class="comment">//非 zygote 模式处理</span></span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re not in zygote mode, the only argument we need to pass</span></span><br><span class="line">        <span class="comment">// to RuntimeInit is the application argument.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The Remainder of args get passed to startup class main(). Make</span></span><br><span class="line">        <span class="comment">// copies of them before we overwrite them with the process name.</span></span><br><span class="line">        args.add(application ? String8(<span class="string">&quot;application&quot;</span>) : String8(<span class="string">&quot;tool&quot;</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//zygote 模式下的处理</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果 startSystemServer 为 true 则将 &quot;start-system-server&quot; 添加到 args</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">&quot;start-system-server&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, NULL) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: Unable to determine ABI list from property %s.&quot;</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">&quot;--abi-list=&quot;</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.string());</span><br><span class="line">        set_process_name(niceName.string());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果 zygote 为 true 则启动 zygote</span></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">      <span class="comment">//通过 runtime 对象启动 zygote</span></span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 main 函数中首先创建了一个 AppRuntime 对象，然后就会根据传入的参数对一些标志位进行相应的置位，这里值得注意的一个标志位是 startSystemServer，上文说过 Android 5.0 之后系统可能会启动两个 zygote 进程，而 SystemServer 只需要启动一次，所以通过这个标志位控制只在启动主 zygote 进程的时候将 &quot;start-system-server&quot; 增加到 args，然后则会通过 AppRuntime 的 start 函数调用 Java 层的 zygote 代码。</p><h3 id="androidruntime-分析">AndroidRuntime 分析</h3><p>由于 AppRuntime 继承自 AndroidRuntime，所以想要了解系统是如何调用 Java 层的 zygote 代码则需要继续了解 AndroidRuntime 的 start 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppRuntime</span> :</span> <span class="keyword">public</span> AndroidRuntime</span><br></pre></td></tr></table></figure><p>AndroidRuntime 位于 frameworks/base/core/jni</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start the Android runtime.  This involves starting the virtual machine</span></span><br><span class="line"><span class="comment"> * and calling the &quot;static void main(String[] args)&quot; method in the class</span></span><br><span class="line"><span class="comment"> * named by &quot;className&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Passes the main function two arguments, the class name and the specified</span></span><br><span class="line"><span class="comment"> * options string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">&quot;start-system-server&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &#x27;startSystemServer == true&#x27; means runtime is obsolete and not run from</span></span><br><span class="line"><span class="comment">     * init.rc anymore, so we print out the boot start event here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="comment">//只有 startSystemServer == true，options 才会有 start-system-server</span></span><br><span class="line">        <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">           <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">           <span class="built_in">LOG_EVENT_LONG</span>(LOG_BOOT_PROGRESS_START,  <span class="built_in">ns2ms</span>(<span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);</span></span><br><span class="line">    <span class="comment">//ALOGD(&quot;Found LD_ASSUME_KERNEL=&#x27;%s&#x27;\n&quot;, kernelHack);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.<span class="built_in">Init</span>(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//创建启动 DVM</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">onVmCreated</span>(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//注册 JNI 方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startReg</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment">     * Create an array to hold them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将 options 转化为 java 中的 String 数组</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建对象数组，类型为 stringClass（即 String 类型），长度为 options.size() + 1</span></span><br><span class="line">    strArray = env-&gt;<span class="built_in">NewObjectArray</span>(options.<span class="built_in">size</span>() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;<span class="built_in">NewStringUTF</span>(className);</span><br><span class="line">    <span class="built_in">assert</span>(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;<span class="built_in">SetObjectArrayElement</span>(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将 options 逐个增加到对象数组当中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;<span class="built_in">NewStringUTF</span>(options.<span class="built_in">itemAt</span>(i).<span class="built_in">string</span>());</span><br><span class="line">        <span class="built_in">assert</span>(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;<span class="built_in">SetObjectArrayElement</span>(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = <span class="built_in">toSlashClassName</span>(className);</span><br><span class="line">    <span class="comment">//寻找类名为 slashClassName 的类</span></span><br><span class="line">    jclass startClass = env-&gt;<span class="built_in">FindClass</span>(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//查找 main 方法，([Ljava/lang/String;)V 是 main 方法的签名</span></span><br><span class="line">        jmethodID startMeth = env-&gt;<span class="built_in">GetStaticMethodID</span>(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用 startClass 类当中的 main 方法，传入参数 strArray</span></span><br><span class="line">            env-&gt;<span class="built_in">CallStaticVoidMethod</span>(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionCheck</span>())</span><br><span class="line">                <span class="built_in">threadExitUncaughtException</span>(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 start 函数的注释我们可以大致了解到 <strong>start 函数的主要作用是启动虚拟机和名为 classname 的 main 方法</strong>。</p><p>而上文可以知道，传入的 classname 是 &quot;com.android.internal.os.ZygoteInit&quot; 。那么整个的执行流程就是：</p><p>首先会判断传递进来的参数是否存在 &quot;start-system-server&quot; ，如果存在则会输出启动日志，然后会通过 startVm 函数创建启动 DVM，在启动 DVM 之后会通过 startReg 函数注册 JNI 方法，在注册完毕之后会将传入的 options 参数转换为 Java 的对象数组，而之所以需要转换成对象数组是因为在于 options 需要作为 main 方法的参数传入，之后再通过传入的 className 去获得 jclass 对象，并根据 main 方法的 JNI 签名得到 jmethodID，最终通过CallStaticVoidMethod 方法完成 main 方法的调用。</p><h3 id="zygoteinit-分析">ZygoteInit 分析</h3><p>frameworks/base/core/java/com/android/internal/os</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    String socketName = <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//注册 socket</span></span><br><span class="line">        registerZygoteSocket(socketName);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//预加载类和资源</span></span><br><span class="line">        preload();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            <span class="comment">//创建 SystemServer 进程</span></span><br><span class="line">            startSystemServer(abiList, socketName);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//等待客户端请求</span></span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Zygote died with exception&quot;</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个 main 方法的执行流程是：首先通过 registerZygoteSocket 方法对 socket 进行了注册，注册的 socket 用于和 ActivityManagerService 进行通信，然后调用 preload 方法对类和资源进行加载，之后则会调用 startSystemServer 创建 SystemServer 进程，最后通过 runSelectLoop 等待来自 ActivityManagerService 的请求。</p><p>这里最为关键的是 socket 以及创建 SystemServer 进程，所以我们需要进一步了解这两个部分。</p><h4 id="注册-socket-过程">注册 Socket 过程</h4><p>首先是注册 Socket 部分， registerZygoteSocket 主要是利用文件描述符创建了一个 LocalServerSocket 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerZygoteSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fileDesc;</span><br><span class="line">      <span class="comment">//socket 名为 ANDROID_SOCKET_zygote</span></span><br><span class="line">        <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String env = System.getenv(fullSocketName);</span><br><span class="line">            fileDesc = Integer.parseInt(env);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(fullSocketName + <span class="string">&quot; unset or invalid&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">            fd.setInt$(fileDesc);</span><br><span class="line">          <span class="comment">//创建 LocalServerSockt</span></span><br><span class="line">            sServerSocket = <span class="keyword">new</span> LocalServerSocket(fd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Error binding to local socket &#x27;&quot;</span> + fileDesc + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动-systemserver">启动 SystemServer</h4><p>startSystemServer 主要工作是对设置的参数进行解析，然后通过 forkSystemServer 创建 SystemServer 进程，最后在 SystemServer 进程中调用 handleSystemServerProcess 方法处理剩余工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">  <span class="comment">//设置 uid 为 1000,设置 gid 为 1000，启动 com.android.server.SystemServer</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">        <span class="comment">/// M: ANR mechanism for system_server add shell(2000) group to access</span></span><br><span class="line">        <span class="comment">///    /sys/kernel/debug/tracing/tracing_on</span></span><br><span class="line">        <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,2000,&quot;</span> +</span><br><span class="line">            <span class="string">&quot;3001,3002,3003,3006,3007,3009,3010&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--capabilities=&quot;</span> + capabilities + <span class="string">&quot;,&quot;</span> + capabilities,</span><br><span class="line">        <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--runtime-args&quot;</span>,</span><br><span class="line">        <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//对 args 进行解析</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">      <span class="comment">//创建 SystemServer 进程</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For child process */</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理 SystemServer 进程剩余工作</span></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="监听客户端的请求">监听客户端的请求</h4><p>runSelectLoop 的主要工作是通过 ZygoteConnection 的 acceptCommandPeer 方法监听客户端的请求，然后调用 runOnce 方法对来自客户端的请求进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//循环处理连接请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);<span class="comment">//无限等待能够进行 I/O 操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;poll failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//说明没有来自客户端的连接请求或数据处理请求</span></span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;<span class="comment">//处理来自客户端的连接请求</span></span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce();<span class="comment">//处理客户端数据处理请求，创建对应的进程</span></span><br><span class="line">                <span class="keyword">if</span> (done) &#123;<span class="comment">//处理完毕则进行移除</span></span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理客户端请求">处理客户端请求</h4><p>对于 runOnce 而言主要做的工作是从连接中读取参数，然后根据参数创建相应的进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = readArgumentList();<span class="comment">//读取参数</span></span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;IOException on command socket &quot;</span> + ex.getMessage());</span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF reached.</span></span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);<span class="comment">//构造 Arguments 对象</span></span><br><span class="line">      </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//创建进程</span></span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">&quot;Exception creating pipe&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">&quot;Invalid zygote arguments&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteSecurityException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr,</span><br><span class="line">                <span class="string">&quot;Zygote security policy prevents request: &quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//进入子进程的处理流程</span></span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">            <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>到这里我们大致能够知晓 Zygote 进程的启动过程和主要作用了：</p><ol type="1"><li>系统在启动 Zygote 的过程中首先启动了虚拟机，然后通过 JNI 调用了 ZygoteInit 中的 main 方法，由此系统从 C++ 的 FrameWork 层到了 Java 的 FrameWork 层，之后在则注册了用于和 ActvityManagerService 通信的 Socket，完成注册之后则会调用 startSystemServer 启动 SystemServer 进程，最后 Zygote 进程将会通过 runSelectLoop 对来自客户端的连接进行监听。</li><li>总的来说 Zygote 的主要作用启动 SystemServer 进程以及根据客户端的连接创建相应的进程。</li></ol><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRhY2hpODUvYXJ0aWNsZS9kZXRhaWxzLzU1MDQ3MTA0">Android系统启动流程（二）解析Zygote进程启动过程<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpdHl1YW4uY29tLzIwMTYvMDIvMTMvYW5kcm9pZC16eWdvdGUv">Android系统启动-zygote篇<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&quot;/posts/da66bd78.html&quot; title=&quot;Android启动过程简析（一）&quot;&gt;Android启动过程简析（一）&lt;/a&gt;中我们已经分析过了 init 进程是如何被启动的，本篇文章将会继续分析 zygote 启动过程以及作用。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.ikroal.cn/categories/Android/"/>
    
    
    <category term="SourceCode Analysis" scheme="https://www.ikroal.cn/tags/SourceCode-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动过程简析（一）之 init 进程</title>
    <link href="https://www.ikroal.cn/posts/da66bd78.html"/>
    <id>https://www.ikroal.cn/posts/da66bd78.html</id>
    <published>2017-10-28T05:51:42.000Z</published>
    <updated>2021-12-24T05:57:00.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>在进入到 Android 启动过程之前先让我们思考以下几个问题 1. Android 系统的启动过程是怎样的？ 2. init 、zygote 进程是什么？在系统启动的过程中各自发挥了什么作用？ 3. AMS、PMS 等这些服务是如何被启动的？ 4. Launcher 是如何被启动的？</p><p>此篇文章将针对 init 部分给出分析<span id="more"></span></p><h2 id="启动流程简述">启动流程简述</h2><p>在了解 init 部分之前，首先简单介绍下系统的启动流程以便抓住主线，当我们通过电源键开启系统的时候，系统首先会加载 bootloader 程序到 RAM 中，然后通过 bootloader 将内核程序加载到 RAM 中，之后内核程序会创建init 进程，在 init 进程中会创建 zygote 进程，而 zygote 进程则会创建 DVM 并且启动 SystemServer 进程，通过SystemServer 系统会启动一系列的服务，包括常见的 AMS、PMS 等，最后再通过 AMS 进入到我们熟知的 Launcher 程序。 所以整个流程的关键点在于 <strong>init 进程如何创建 zygote、zygote 进程如何创建 SystemServer、SystemServer 进程如何启动 AMS、AMS 如何启动 Launcher。</strong></p><h2 id="init-启动流程分析">init 启动流程分析</h2><p>由于 bootloader 和内核不是关心的重点，所以这里只是简单介绍它们的作用。</p><h3 id="加载运行-bootloader">加载运行 BootLoader</h3><p>在电源上电之后，CPU 中的操作控制器将发出控制信号，将程序计数器（PC）的内容送至地址寄存器（AR），之后启动对主存的读操作，最终将 BootLoader 加载到 RAM 当中。然后 BootLoader 开始执行，主要负责硬件的初始化，将内核程序加载到内存。</p><h3 id="init-进程的启动">init 进程的启动</h3><p>内核启动之后将会初始化软硬件环境，加载驱动程序，挂载根文件系统，然后创建 init 进程，init 作为系统中的第一个用户进程，其进程号为 1，在创建 init 进程之时，系统会执行位于 <strong>system/core/init </strong>下的 init.cpp 程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">//创建用户空间目录并挂载</span></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        <span class="built_in">mount</span>(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="string">&quot;mode=0755&quot;</span>);</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/socket&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="built_in">mount</span>(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">        <span class="built_in">mount</span>(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="string">&quot;hidepid=2,gid=&quot;</span> <span class="built_in">MAKE_STR</span>(AID_READPROC));</span><br><span class="line">        <span class="built_in">mount</span>(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal_handler_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">property_load_boot_defaults</span>();</span><br><span class="line">    <span class="built_in">export_oem_lock_status</span>();</span><br><span class="line">    <span class="comment">//启动属性服务</span></span><br><span class="line">    <span class="built_in">start_property_service</span>();</span><br><span class="line">  </span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">    Action::<span class="built_in">set_function_map</span>(&amp;function_map);</span><br><span class="line"></span><br><span class="line">    Parser&amp; parser = Parser::<span class="built_in">GetInstance</span>();</span><br><span class="line">    parser.<span class="built_in">AddSectionParser</span>(<span class="string">&quot;service&quot;</span>,std::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">    parser.<span class="built_in">AddSectionParser</span>(<span class="string">&quot;on&quot;</span>, std::make_unique&lt;ActionParser&gt;());</span><br><span class="line">    parser.<span class="built_in">AddSectionParser</span>(<span class="string">&quot;import&quot;</span>, std::make_unique&lt;ImportParser&gt;());</span><br><span class="line">    <span class="comment">//解析 init.rc 文件</span></span><br><span class="line">    parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/init.rc&quot;</span>);</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 init 进程主要做了三件事情：<strong>创建用户空间文件夹并挂载、启动属性服务、解析位于 system文件夹下的 init.rc 文件</strong>。 这里我们主要关注解析 init.rc 文件的过程，因为 zygote 进程就是在这个过程中创建的。</p><h4 id="android-init-language">Android Init Language</h4><p>由于 init.rc 是一个用 Android 初始化语言（AIL）编写的文件，为了更好的理解 rc 文件的解析过程需要了解一部分 AIL 语法。 AIL 主要有五种类型语句 Actions、Commands、Services、Options、Imports，在 AIL 中每个部分(语句块)表示为一个 Section，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on boot</span><br><span class="line">    ifup lo</span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br></pre></td></tr></table></figure><p>五种语句中只有 Actions、Services、Import 可以用于确定一个 Section。其中 Actions 由一系列 command 组成，Actions 拥有一个 trigger 用于确定何时执行这些命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt;</span><br><span class="line">    &lt;command&gt;</span><br><span class="line">    &lt;command&gt;</span><br><span class="line">    &lt;command&gt;</span><br><span class="line"> </span><br><span class="line">on early-init //触发器 early-init</span><br><span class="line">    write /proc/1/oom_score_adj -1000 //command</span><br><span class="line">    write /proc/sys/kernel/sysrq 0</span><br></pre></td></tr></table></figure><p>Services 由一些 option 组成，其在初始化的时候启动，并可以在退出后重启（可选）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*  //服务名、执行路径、参数</span><br><span class="line">        &lt;option&gt;  </span><br><span class="line">        &lt;option&gt; </span><br><span class="line">        </span><br><span class="line">service ueventd /sbin/ueventd </span><br><span class="line">    class core</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br></pre></td></tr></table></figure><p>Services 定义了自身的服务名、执行路径以及执行时传入的参数，option 用于指定何时和怎样启动 service，关于何时启动这里进行一下说明，Actions 中有一条命令是 class_start <服务类别名> 用于启动所有未运行的相同类别的 service，而 option 可以通过 class <类别名> 对 service 的类别名进行指定。<strong>所以 service 的启动一般是通过 action 触发之后执行 class_start 命令进行启动的。</strong> AIL 的介绍就到这了，<strong>如果想要详细了解请阅读 system/core/init 下的 readme.txt 文件</strong></类别名></服务类别名></p><h4 id="init.rc-解析">init.rc 解析</h4><p>system/core/rootdir/init.rc 现在接着分析 init.rc 文件，在文件的首部可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> /init.environ.rc</span><br><span class="line"><span class="keyword">import</span> /init.usb.rc</span><br><span class="line"><span class="keyword">import</span> /init.$&#123;ro.hardware&#125;.rc</span><br><span class="line"><span class="keyword">import</span> /init.usb.configfs.rc</span><br><span class="line"><span class="keyword">import</span> /init.$&#123;ro.zygote&#125;.rc</span><br></pre></td></tr></table></figure><p>在这里可以看到需要启动的 zygote，但是与其它引入的 rc 文件相比 zygote 部分并没有使用确定的值，而是使用 ${ro.zygote} 变量去替代，这是因为从 Android 在 5.0 以后开始支持 64 位程序，所以需要根据系统中 ro.zygote 属性的值动态引入。ro.zygote 的值可以通过 adb shell getprop 进行查询，我的手机查询结果是：</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/zygote-value.png"></p><p>这说明手机会启动两个 zygote 进程，对应的执行程序分别是 app_process64 (主模式)、app_process32，通过 adb shell ps | grep zygote 可以看到确实存在两个 zygote 进程</p><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/zygote-process.png"></p><p>接着查看与 init.rc 同一目录下的 init.zygote64_32.rc 文件 system/core/rootdir/init.zygote64_32.rc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">zygote</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">android_power</span>/<span class="title">request_state</span> <span class="title">wake</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">power</span>/<span class="title">state</span> <span class="title">on</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">netd</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">foreground</span>/<span class="title">tasks</span> /<span class="title">sys</span>/<span class="title">fs</span>/<span class="title">cgroup</span>/<span class="title">stune</span>/<span class="title">foreground</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">service</span> <span class="title">zygote_secondary</span> /<span class="title">system</span>/<span class="title">bin</span>/<span class="title">app_process32</span> -<span class="title">Xzygote</span> /<span class="title">system</span>/<span class="title">bin</span> --<span class="title">zygote</span> --<span class="title">socket</span>-<span class="title">name</span></span>=zygote_secondary</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">zygote_secondary</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">foreground</span>/<span class="title">tasks</span> /<span class="title">dev</span>/<span class="title">stune</span>/<span class="title">foreground</span>/<span class="title">tasks</span></span></span><br></pre></td></tr></table></figure><p>前文说过 service 的启动和类别名相关，这里两个 zygote service 的类别名都是 main，所以要想知道 zygote 怎么被启动的我们可以在 init.rc 中搜索 class_start main，可以发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on nonencrypted</span><br><span class="line">    # A/B update verifier that marks a successful boot.</span><br><span class="line">    exec - root -- /system/bin/update_verifier nonencrypted</span><br><span class="line">    class_start main</span><br><span class="line">    class_start late_start</span><br></pre></td></tr></table></figure><p>从这里我们可以了解到当 nonencrypted 这个触发器被触发的时候 zygote 就会被启动，所以启动 zygote 的问题就转变为<strong>这个触发器什么时候执行？class_start 对应的处理函数是什么？</strong>要想知道答案，必须回到 init.cpp 的解析过程当中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parser&amp; parser = Parser::<span class="built_in">GetInstance</span>();</span><br><span class="line">parser.<span class="built_in">AddSectionParser</span>(<span class="string">&quot;service&quot;</span>,std::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">parser.<span class="built_in">AddSectionParser</span>(<span class="string">&quot;on&quot;</span>, std::make_unique&lt;ActionParser&gt;());</span><br><span class="line">parser.<span class="built_in">AddSectionParser</span>(<span class="string">&quot;import&quot;</span>, std::make_unique&lt;ImportParser&gt;());</span><br><span class="line">parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/init.rc&quot;</span>);</span><br></pre></td></tr></table></figure><p>init.rc 交由一个 Parser 对象进行解析，而 Parser 的实现在 system/core/init/init_parser.cpp 文件中，让我们进入到 init_parser.cpp 中查看 AddSectionParser 的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::AddSectionParser</span><span class="params">(<span class="keyword">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::unique_ptr&lt;SectionParser&gt; parser)</span> </span>&#123;</span><br><span class="line">    section_parsers_[name] = std::<span class="built_in">move</span>(parser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init_parser.h 中 section_parsers_ 的定义</span></span><br><span class="line">std::map&lt;std::string, std::unique_ptr&lt;SectionParser&gt;&gt; section_parsers_;</span><br></pre></td></tr></table></figure><p>可以看到每一个 parser 最终被保存在 section_parsers_ 中，section_parsers_ 是什么？查看 init_parser.h 中的定义可以知道，section_parsers_ 是一个 map 集合，所以 section_parsers_ 的作用是将 parser 与对应的 Section 进行绑定。 在添加完所有的 parser 之后就会调用 Parser 的 ParseConfig 方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfig</span><span class="params">(<span class="keyword">const</span> std::string&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_dir</span>(path.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ParseConfigDir</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseConfigFile</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ParseConfig 中会对 path 进行判断，如果是目录则调用 ParseConfigDir 进行递归然后再通过 ParseConfigFile 进行解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigDir</span><span class="params">(<span class="keyword">const</span> std::string&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;Parsing directory %s...\n&quot;</span>, path.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="function">std::unique_ptr&lt;DIR, <span class="title">int</span><span class="params">(*)</span><span class="params">(DIR*)</span>&gt; <span class="title">config_dir</span><span class="params">(opendir(path.c_str()), closedir)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!config_dir) &#123;</span><br><span class="line">        <span class="built_in">ERROR</span>(<span class="string">&quot;Could not import directory &#x27;%s&#x27;\n&quot;</span>, path.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dirent* current_file;</span><br><span class="line">    <span class="keyword">while</span> ((current_file = <span class="built_in">readdir</span>(config_dir.<span class="built_in">get</span>()))) &#123;</span><br><span class="line">        std::string current_path =</span><br><span class="line">            android::base::<span class="built_in">StringPrintf</span>(<span class="string">&quot;%s/%s&quot;</span>, path.<span class="built_in">c_str</span>(), current_file-&gt;d_name);</span><br><span class="line">        <span class="comment">// Ignore directories and only process regular files.</span></span><br><span class="line">        <span class="keyword">if</span> (current_file-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ParseConfigFile</span>(current_path)) &#123; <span class="comment">//调用 ParseConfigFile 进行解析</span></span><br><span class="line">                <span class="built_in">ERROR</span>(<span class="string">&quot;could not import file &#x27;%s&#x27;\n&quot;</span>, current_path.<span class="built_in">c_str</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在 ParseConfigFile 中通过 ParseData 进行解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigFile</span><span class="params">(<span class="keyword">const</span> std::string&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;Parsing file %s...\n&quot;</span>, path.<span class="built_in">c_str</span>());</span><br><span class="line">    Timer t;</span><br><span class="line">    std::string data;</span><br><span class="line">  <span class="comment">//从 rc 文件中读取内容保存在 data 中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">read_file</span>(path.<span class="built_in">c_str</span>(), &amp;data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="string">&#x27;\n&#x27;</span>); <span class="comment">// <span class="doctag">TODO:</span> fix parse_config.</span></span><br><span class="line">    <span class="built_in">ParseData</span>(path, data); <span class="comment">//调用 ParseData 进行解析</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ParseData 解析过程如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::ParseData</span><span class="params">(<span class="keyword">const</span> std::string&amp; filename, <span class="keyword">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> Use a parser with const input and remove this copy</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">char</span>&gt; <span class="title">data_copy</span><span class="params">(data.begin(), data.end())</span></span>; <span class="comment">//将 rc 中的内容保存在 vector 中便于逐个字符进行解析</span></span><br><span class="line">    data_copy.<span class="built_in">push_back</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">    parse_state state;</span><br><span class="line">    state.filename = filename.<span class="built_in">c_str</span>();</span><br><span class="line">    state.line = <span class="number">0</span>;</span><br><span class="line">    state.ptr = &amp;data_copy[<span class="number">0</span>];</span><br><span class="line">    state.nexttoken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    SectionParser* section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; args; <span class="comment">//存放的是每行的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">next_token</span>(&amp;state)) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_EOF:</span><br><span class="line">            <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                section_parser-&gt;<span class="built_in">EndSection</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> T_NEWLINE:</span><br><span class="line">            state.line++;</span><br><span class="line">            <span class="comment">//如果 args 为空则不进行解析（rc 文件中间存在空行，所以需要判断）</span></span><br><span class="line">            <span class="keyword">if</span> (args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是不是一个 section 的起始位置（通过能不能获得解析器，可以判断 args[0] 是不是 service、on、import 其中一个）</span></span><br><span class="line">            <span class="keyword">if</span> (section_parsers_.<span class="built_in">count</span>(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                  <span class="comment">//如果上次存在解析则结束解析</span></span><br><span class="line">                    section_parser-&gt;<span class="built_in">EndSection</span>();</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//取出对应的解析器</span></span><br><span class="line">                section_parser = section_parsers_[args[<span class="number">0</span>]].<span class="built_in">get</span>();</span><br><span class="line">                std::string ret_err;</span><br><span class="line">              <span class="comment">//进行 Section 解析</span></span><br><span class="line">                <span class="keyword">if</span> (!section_parser-&gt;<span class="built_in">ParseSection</span>(args, &amp;ret_err)) &#123;</span><br><span class="line">                    <span class="built_in">parse_error</span>(&amp;state, <span class="string">&quot;%s\n&quot;</span>, ret_err.<span class="built_in">c_str</span>());</span><br><span class="line">                    section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123; <span class="comment">//不是的话说明 args 中是一个 section 的子块，则进行 Line 解析</span></span><br><span class="line">                std::string ret_err;</span><br><span class="line">                <span class="keyword">if</span> (!section_parser-&gt;<span class="built_in">ParseLineSection</span>(args, state.filename,</span><br><span class="line">                                                      state.line, &amp;ret_err)) &#123;</span><br><span class="line">                    <span class="built_in">parse_error</span>(&amp;state, <span class="string">&quot;%s\n&quot;</span>, ret_err.<span class="built_in">c_str</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解析完成后清空</span></span><br><span class="line">            args.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_TEXT:</span><br><span class="line">            args.<span class="built_in">emplace_back</span>(state.text);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ParseData 中通过调用 system/core/init/parser.cpp 中的 next_token 函数对 rc 内容进行分析，如果是 T_TEXT 则会保存在 args 中，如果是 T_NEWLINE 则会交由对应的解析器进行解析。init.rc 的大致解析过程如此，但是到这里我们依旧没能找到所需要的答案，所以需要继续查看 ActionParser 和 ServiceParser 的解析过程。</p><h4 id="actionparser-解析过程">ActionParser 解析过程</h4><p>ActionParser 位于 system/core/init/action.cpp 中，从前面的解析过程来看，最后的解析总是调用了对应 parser 的 ParseSection、ParseLineSection 以及 EndSection，所以我们主要看下这两个部分 ParseSection 的主要工作是创建 Action 对象，为对象添加触发器，并将 action_ 移动至当前 Action 对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ActionParser::ParseSection</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::string* err)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">triggers</span><span class="params">(args.begin() + <span class="number">1</span>, args.end())</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> action = std::make_unique&lt;Action&gt;(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">//为 action 增加触发器</span></span><br><span class="line">    <span class="keyword">if</span> (!action-&gt;<span class="built_in">InitTriggers</span>(triggers, err)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将 aciton_ 指针移动到当前的 action</span></span><br><span class="line">    action_ = std::<span class="built_in">move</span>(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//action_ 在 action.h 中的定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;Action&gt; action_;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ParseLineSection 的主要工作为查找对应 command 的处理函数，将创建的 Command 对象添加到到commands_，由于 commands_ 是 Action 的一个域，所以实际上 ParseLineSection 在填充当前 Action 对象的域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ActionParser::ParseLineSection</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> std::string&amp; filename, <span class="keyword">int</span> line,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    std::string* err)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将解析的 command 增加到当前 action 的 commands_ 中</span></span><br><span class="line">    <span class="keyword">return</span> action_ ? action_-&gt;<span class="built_in">AddCommand</span>(args, filename, line, err) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Action::AddCommand</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> std::string&amp; filename, <span class="keyword">int</span> line, std::string* err)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">//查找对应的 command 的处理函数</span></span><br><span class="line">    <span class="keyword">auto</span> function = function_map_-&gt;<span class="built_in">FindFunction</span>(args[<span class="number">0</span>], args.<span class="built_in">size</span>() - <span class="number">1</span>, err);</span><br><span class="line">    <span class="keyword">if</span> (!function) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AddCommand</span>(function, args, filename, line);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::AddCommand</span><span class="params">(BuiltinFunction f,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> std::string&amp; filename, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//commands_ 增加 command 和对应的处理函数</span></span><br><span class="line">    commands_.<span class="built_in">emplace_back</span>(f, args, filename, line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//commands_ 在 action.h 中的定义</span></span><br><span class="line">std::vector&lt;Command&gt; commands_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Command 在 action.h 中的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Command</span>(BuiltinFunction f, <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args,</span><br><span class="line">            <span class="keyword">const</span> std::string&amp; filename, <span class="keyword">int</span> line);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InvokeFunc</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">BuildCommandString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">BuildSourceString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BuiltinFunction func_;</span><br><span class="line">    std::vector&lt;std::string&gt; args_;</span><br><span class="line">    std::string filename_;</span><br><span class="line">    <span class="keyword">int</span> line_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EndSection 的主要工作是将解析完成的 action （域填充完毕的 Action 对象）添加到 ActionManager 的 acitons_ 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionParser::EndSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action_ &amp;&amp; action_-&gt;<span class="built_in">NumCommands</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">AddAction</span>(std::<span class="built_in">move</span>(action_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionManager::AddAction</span><span class="params">(std::unique_ptr&lt;Action&gt; action)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_action_it != actions_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        (*old_action_it)-&gt;<span class="built_in">CombineAction</span>(*action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//将解析之后的 action 对象增加到 actions_ 链表中，用于遍历执行。</span></span><br><span class="line">        actions_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(action));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ActionManager 在 action.h 中的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionManager</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ActionManager&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddAction</span><span class="params">(std::unique_ptr&lt;Action&gt; action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueueEventTrigger</span><span class="params">(<span class="keyword">const</span> std::string&amp; trigger)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueuePropertyTrigger</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueueAllPropertyTriggers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueueBuiltinAction</span><span class="params">(BuiltinFunction func, <span class="keyword">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExecuteOneCommand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasMoreCommands</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DumpState</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ActionManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ActionManager</span>(ActionManager <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(ActionManager <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Action&gt;&gt; actions_; <span class="comment">//actions_ 的定义</span></span><br><span class="line">    std::queue&lt;std::unique_ptr&lt;Trigger&gt;&gt; trigger_queue_;</span><br><span class="line">    std::queue&lt;<span class="keyword">const</span> Action*&gt; current_executing_actions_;</span><br><span class="line">    std::<span class="keyword">size_t</span> current_command_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过以上分析我们能够知道 class_start 的处理函数和 function_map_ 相关，查看 function_map_ 在 action.h 中的定义可以看到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> KeywordMap&lt;BuiltinFunction&gt;* function_map_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_function_map</span><span class="params">(<span class="keyword">const</span> KeywordMap&lt;BuiltinFunction&gt;* function_map)</span> </span>&#123;</span><br><span class="line">    function_map_ = function_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以要想知道处理函数是什么只需要知道 set_function_map 在哪里调用？让我们再次回到 init.cpp 中，可以看到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">Action::<span class="built_in">set_function_map</span>(&amp;function_map);</span><br></pre></td></tr></table></figure><p>接下来需要找到 BuiltinFunctionMap，BuiltinFunctionMap 的实现我们可以在 builtins.cpp 中找到，其具体的实现 system/core/init/builtins.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BuiltinFunctionMap::Map&amp; <span class="title">BuiltinFunctionMap::map</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> std::<span class="keyword">size_t</span> kMax = std::numeric_limits&lt;std::<span class="keyword">size_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map builtin_functions = &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#123;<span class="string">&quot;class_start&quot;</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_start&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;class_stop&quot;</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_stop&#125;&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> builtin_functions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就可以确定 class_start 对应的处理函数是 do_class_start，do_class_start 也可在 builtins.cpp 中找到。 简单总结下解析 Action 的过程，<strong>实际上是创建一个 Action 对象，然后为 Action 对象添加 Trigger 以及对应的 Command，其中在添加 Command 的过程中还为 Command 指定了处理函数，最后在将 Action 对象增加到 ActionManager vector 类型的 actions_ 链表当中去。</strong></p><h4 id="serviceparser-解析过程">ServiceParser 解析过程</h4><p>与前文一致，接着看那三个函数 ParseSection 的主要工作是创建 Service 对象，将 service_ 移动至当前 Service 对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ServiceParser::ParseSection</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 std::string* err)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">//获取服务名</span></span><br><span class="line">    <span class="keyword">const</span> std::string&amp; name = args[<span class="number">1</span>];</span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">//保存服务名外的参数（如执行路径等）</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">str_args</span><span class="params">(args.begin() + <span class="number">2</span>, args.end())</span></span>;</span><br><span class="line">  <span class="comment">//将 service_ 指针指向当前 Service 对象</span></span><br><span class="line">    service_ = std::make_unique&lt;Service&gt;(name, <span class="string">&quot;default&quot;</span>, str_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//service_ 在 service.h 中的定义</span></span><br><span class="line">std::unique_ptr&lt;Service&gt; service_;</span><br></pre></td></tr></table></figure><p>ParseLineSection 的主要工作是为 Service 中每个 option 指定处理函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ServiceParser::ParseLineSection</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> std::string&amp; filename, <span class="keyword">int</span> line,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     std::string* err)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">//为 Service 中的每一个 Option 指定处理函数</span></span><br><span class="line">    <span class="keyword">return</span> service_ ? service_-&gt;<span class="built_in">HandleLine</span>(args, err) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Service::HandleLine</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args, std::string* err)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> OptionHandlerMap handler_map;</span><br><span class="line">  <span class="comment">//寻找对应 option 的处理函数</span></span><br><span class="line">    <span class="keyword">auto</span> handler = handler_map.<span class="built_in">FindFunction</span>(args[<span class="number">0</span>], args.<span class="built_in">size</span>() - <span class="number">1</span>, err);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*handler)(args, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EndSection 的主要工作是将解析完成的 service （域填充完毕的 Service 对象）添加到 ServiceManager 的 services_ 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ServiceParser::EndSection() &#123;</span><br><span class="line">    <span class="keyword">if</span> (service_) &#123;</span><br><span class="line">        ServiceManager::GetInstance().AddService(std::move(service_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ServiceManager::AddService(std::unique_ptr&lt;Service&gt; service) &#123;</span><br><span class="line">    Service* old_service = FindServiceByName(service-&gt;name());</span><br><span class="line">    <span class="keyword">if</span> (old_service) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;ignored duplicate definition of service &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">              service-&gt;name().c_str());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//将解析之后 service 对象增加到 services_ 链表中</span></span><br><span class="line">    services_.emplace_back(std::move(service));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServiceManager 在 service.h 中的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManager</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> ServiceManager&amp; GetInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddService</span><span class="params">(std::unique_ptr&lt;Service&gt; service)</span></span>;</span><br><span class="line">    Service* MakeExecOneshotService(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args);</span><br><span class="line">    Service* FindServiceByName(<span class="keyword">const</span> std::string&amp; name) <span class="keyword">const</span>;</span><br><span class="line">    Service* FindServiceByPid(pid_t pid) <span class="keyword">const</span>;</span><br><span class="line">    Service* FindServiceByKeychord(<span class="keyword">int</span> keychord_id) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ForEachService</span><span class="params">(std::function&lt;<span class="keyword">void</span>(Service*)</span>&gt; callback) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ForEachServiceInClass</span><span class="params">(<span class="keyword">const</span> std::string&amp; classname,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">void</span> (*func)</span><span class="params">(Service* svc)</span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ForEachServiceWithFlags</span><span class="params">(unsigned matchflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">void</span> (*func)</span><span class="params">(Service* svc)</span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReapAnyOutstandingChildren</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RemoveService</span><span class="params">(<span class="keyword">const</span> Service&amp; svc)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DumpState</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ServiceManager();</span><br><span class="line">    <span class="function">bool <span class="title">ReapOneProcess</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> exec_count_; <span class="comment">// Every service needs a unique name.</span></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Service&gt;&gt; services_; <span class="comment">//services_ 的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的可以看下 option 的处理函数，虽然 OptionHandlerMap 与启动 zygote 无关，但是还是看下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Service::OptionHandlerMap::Map&amp; Service::OptionHandlerMap::<span class="built_in">map</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> std::<span class="keyword">size_t</span> kMax = std::numeric_limits&lt;std::<span class="keyword">size_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map option_handlers = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;class&quot;</span>,       &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleClass&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;console&quot;</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleConsole&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;critical&quot;</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleCritical&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;disabled&quot;</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleDisabled&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;group&quot;</span>,       &#123;<span class="number">1</span>,     NR_SVC_SUPP_GIDS + <span class="number">1</span>, &amp;Service::HandleGroup&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ioprio&quot;</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleIoprio&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;keycodes&quot;</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleKeycodes&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;oneshot&quot;</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleOneshot&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;onrestart&quot;</span>,   &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleOnrestart&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;seclabel&quot;</span>,    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleSeclabel&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;setenv&quot;</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleSetenv&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;socket&quot;</span>,      &#123;<span class="number">3</span>,     <span class="number">6</span>,    &amp;Service::HandleSocket&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;user&quot;</span>,        &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleUser&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;writepid&quot;</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleWritepid&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> option_handlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与解析 Action 类似，<strong>在整个过程中先创建 Service 对象，解析出 Service 的名字和对应的参数添加到对象当中，并且给每个 Option 指定了相应的处理函数</strong> 到这里 rc 文件的解析就结束了，通过 rc 文件的解析使得每个 action 都有了对应的执行函数，<strong>所以接下来的问题是这些 action 是如何被触发的（也即是 command 命令是如何被执行的）？</strong></p><h4 id="actions-的触发">Actions 的触发</h4><p>让我们继续回到 init.cpp 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ActionManager&amp; am = ActionManager::<span class="built_in">GetInstance</span>();</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!waiting_for_exec) &#123;</span><br><span class="line">        am.<span class="built_in">ExecuteOneCommand</span>();</span><br><span class="line">        <span class="built_in">restart_processes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 action 的 command 的执行是通过 ActionManager 的 ExecuteOneCommand 函数，而ActionManager 的 ExecuteOneCommand 最终调用了 Action 的 ExecuteOneCommand system/core/init/action.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionManager::ExecuteOneCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环等待，直到队列中不为空</span></span><br><span class="line">    <span class="keyword">while</span> (current_executing_actions_.<span class="built_in">empty</span>() &amp;&amp; !trigger_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//遍历 actions_</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; action : actions_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trigger_queue_.<span class="built_in">front</span>()-&gt;<span class="built_in">CheckTriggers</span>(*action)) &#123;</span><br><span class="line">                <span class="comment">//将 action 加入到 current_executing_actions_ 中</span></span><br><span class="line">                current_executing_actions_.<span class="built_in">emplace</span>(action.<span class="built_in">get</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        trigger_queue_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次只执行一个 action</span></span><br><span class="line">    <span class="keyword">auto</span> action = current_executing_actions_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == <span class="number">0</span>) &#123;</span><br><span class="line">        std::string trigger_name = action-&gt;<span class="built_in">BuildTriggersString</span>();</span><br><span class="line">        <span class="built_in">INFO</span>(<span class="string">&quot;processing action (%s)\n&quot;</span>, trigger_name.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行 action 的 command</span></span><br><span class="line">    action-&gt;<span class="built_in">ExecuteOneCommand</span>(current_command_);</span><br><span class="line">  </span><br><span class="line">    ++current_command_;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteOneCommand</span><span class="params">(std::<span class="keyword">size_t</span> command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">//执行 action 对象中保存的 command</span></span><br><span class="line">    <span class="built_in">ExecuteCommand</span>(commands_[command]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteCommand</span><span class="params">(<span class="keyword">const</span> Command&amp; command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Timer t;</span><br><span class="line">  <span class="comment">//调用 command 对应的处理函数</span></span><br><span class="line">    <span class="keyword">int</span> result = command.<span class="built_in">InvokeFunc</span>();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述分析可以知道，init 进程最终进入到无限循环中，然后按照 ActionManager 中 actions_ 保存的 action 顺序依次对每个 Action 进行处理，而在这个过程中 system/core/init/builtins.cpp 下用于启动 zygote 的 do_class_start 函数将会被执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_class_start</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    ServiceManager::<span class="built_in">GetInstance</span>().</span><br><span class="line">        <span class="built_in">ForEachServiceInClass</span>(args[<span class="number">1</span>], [] (Service* s) &#123; s-&gt;<span class="built_in">StartIfNotDisabled</span>(); &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do_class_start 函数中调用 Service 的 StartIfNotDisabled，StartIfNotDisabled 在 service.cpp 的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Service::StartIfNotDisabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(flags_ &amp; SVC_DISABLED)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Start</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags_ |= SVC_DISABLED_START;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StartIfNotDisabled 最终调用了 Service 的 Start 函数，Start 函数创建了 zygote 的进程，并且执行了 init.zygote64_32.rc 中定义的执行路径下的文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Service::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">   <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">       <span class="comment">//执行对应 service 对应的执行文件，args_[0].c_str() 就是执行路径</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">execve</span>(args_[<span class="number">0</span>].<span class="built_in">c_str</span>(), (<span class="keyword">char</span>**) &amp;strs[<span class="number">0</span>], (<span class="keyword">char</span>**) ENV) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;cannot execve(&#x27;%s&#x27;): %s\n&quot;</span>, args_[<span class="number">0</span>].<span class="built_in">c_str</span>(), <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成这一切之后将会进入 frameworks/base/cmds/app_process/app_main.cpp 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">      <span class="comment">//启动 zygote</span></span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">app_usage</span>();</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 zygote 最终在 app_main 的 main 函数中被启动。</p><h2 id="总结">总结</h2><p>到这里我们就能够回答对 init 部分相关的问题了 1. init 的作用 init 是系统中的第一个用户进程，它的主要作用是<strong>创建用户空间文件夹并挂载、启动属性服务、解析 init.rc 文件并启动 zygote 进程</strong>。 2. init 启动 zygote 的过程 init 进程通过解析 init.rc 文件将 action 保存在 ActionManager 的 actions_ 链表中，然后通过遍历 actions_ 链表，执行 action 命令对应的处理函数，从而转至 builtins.cpp 的 do_class_start 函数，之后通过 Service 的 StartIfNotDisabled 调用 Service 的 Start 函数，最终通过 Start 函数创建 zygote 进程，执行对应的 app_main.cpp 文件启动 zygote。</p><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2F1Z2FtZWxhL2FydGljbGUvZGV0YWlscy81MjEzMzE4Ng==">Android7.0 init进程源码分析<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uZ2JvY2hlbjEyMjMvYXJ0aWNsZS9kZXRhaWxzLzU2MzMxNjkw">Android Init Language(android初始化语言)<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRhY2hpODUvYXJ0aWNsZS9kZXRhaWxzLzU0NzgzNTA2">Android系统启动流程（一）解析init进程启动过程<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;在进入到 Android 启动过程之前先让我们思考以下几个问题 1. Android 系统的启动过程是怎样的？ 2. init 、zygote 进程是什么？在系统启动的过程中各自发挥了什么作用？ 3. AMS、PMS 等这些服务是如何被启动的？ 4. Launcher 是如何被启动的？&lt;/p&gt;
&lt;p&gt;此篇文章将针对 init 部分给出分析&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.ikroal.cn/categories/Android/"/>
    
    
    <category term="SourceCode Analysis" scheme="https://www.ikroal.cn/tags/SourceCode-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Android 基础之 Selector 的用法</title>
    <link href="https://www.ikroal.cn/posts/undefined.html"/>
    <id>https://www.ikroal.cn/posts/undefined.html</id>
    <published>2017-09-24T07:58:15.000Z</published>
    <updated>2021-07-24T13:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Selector（选择器）常常被用作控件的背景，是一种状态列表，一般分为 Drawable-selector 和 Color-selector，接下来分别说说这两者的使用方法。<span id="more"></span></p><h2 id="drawable-selector">Drawable-selector</h2><ol type="1"><li><p>首先需要在 res/drawable 文件夹下新建一个 Drawable Resource File 文件，填入文件名即可，创建之后的文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 selector 标签下新建一个 item 标签，item 标签表示一种状态，如果不指明状态，那么控件在任何状态下都会加载 item 内的 样式，常用的状态设置如下所示：</p><ul><li>android:state_pressed 设置为 true 时代表按压控件的时候使用 item 样式</li><li>android:state_selected 设置为 true 时代表控件被选中的时候使用 item 样式</li><li>android:state_checked 设置为 true 时代表控件处于 checked 状态的时候使用 item 样式</li></ul></li><li><p>接下来在 item 内部创建 shape 标签用于指定绘制的图形类别，总共有四种图形可以选择分别是：rectangle、oval、line、ring。在确定需要绘制的 shape 类型之后，就可以在 shape 标签内部对 shape 的各项属性进行配置，总共有六种标签属性。</p><ul><li>size 用来设置 shape 的大小</li><li>solid 用来设置填充 shape 的颜色</li><li>corners 用来设置 shape 的角度</li><li>stroke 用来给 shape 描边，可以描成虚线或实线</li><li>padding 设置内边距</li><li>gradient 设置 shape 的渐变颜色</li></ul></li><li><p>设置好相应的属性之后就可以通过设置控件的 android:drawble 属性进行使用了，这里给出一个例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">&quot;rectangle&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">&quot;5dp&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stroke</span> <span class="attr">android:width</span>=<span class="string">&quot;1dp&quot;</span> <span class="attr">android:color</span>=<span class="string">&quot;#00faff&quot;</span> <span class="attr">android:dashGap</span>=<span class="string">&quot;10dp&quot;</span> <span class="attr">android:dashWidth</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span> <span class="attr">android:width</span>=<span class="string">&quot;150dp&quot;</span> <span class="attr">android:height</span>=<span class="string">&quot;150dp&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;#bcb7b7&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">&quot;oval&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">&quot;360dp&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">stroke</span> <span class="attr">android:width</span>=<span class="string">&quot;1dp&quot;</span> <span class="attr">android:color</span>=<span class="string">&quot;#00fcb5&quot;</span> <span class="attr">android:dashGap</span>=<span class="string">&quot;10dp&quot;</span> <span class="attr">android:dashWidth</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">size</span> <span class="attr">android:width</span>=<span class="string">&quot;300dp&quot;</span> <span class="attr">android:height</span>=<span class="string">&quot;300dp&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;#ffff&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码绘制了两种状态，一种是默认状态下的圆，白色填充、虚线描边、半径是 300dp。另一种是被按下的状态，灰色填充、虚线描边、长和宽与圆一致。具体效果如下图所示： <img src="https://raw.githubusercontent.com/ikroal/blog-images/master/selector-circle.png"><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/selector-square.png"></p></li></ol><h2 id="color-selector">Color-selector</h2><p>Color-selector 定义在 res文件夹下，使用过程基本与 Drawable-selector 一致，不同在于 Color-selector 只是用于定义控件的颜色，所以只需要配置 item 标签的 color 属性即可，具体的例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">&quot;#000000&quot;</span> <span class="attr">android:state_pressed</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">&quot;#ffff&quot;</span> <span class="attr">android:state_pressed</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过指定 item 的状态和颜色，即可做到按压和松开时控件的颜色变化。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Selector（选择器）常常被用作控件的背景，是一种状态列表，一般分为 Drawable-selector 和 Color-selector，接下来分别说说这两者的使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Archived" scheme="https://www.ikroal.cn/categories/Archived/"/>
    
    
    <category term="Android" scheme="https://www.ikroal.cn/tags/Android/"/>
    
    <category term="Drawble" scheme="https://www.ikroal.cn/tags/Drawble/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的六大原则及单例模式</title>
    <link href="https://www.ikroal.cn/posts/8e198ed0.html"/>
    <id>https://www.ikroal.cn/posts/8e198ed0.html</id>
    <published>2017-09-16T17:05:58.000Z</published>
    <updated>2021-12-24T05:57:00.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象的六大原则">面向对象的六大原则</h2><h3 id="单一职责原则">单一职责原则</h3><p>单一职责原则 (SRP) 是指就一个类而言，应该仅有一个引起它变化的原因</p><blockquote><p>简单而言就是一个类应该只有一项职责，而不是具有多项职责，比如一个类既负责图片缓存的处理同时还负责显示图片，实际上应该拆分成两个类，一个类负责图片的缓存，另外一个类负责图片显示。如果一个类兼具太多的职责不仅导致了耦合性，而且在一个职责发生变化的时候还可能削弱其它的职责功能。</p></blockquote><span id="more"></span><h3 id="开闭原则">开闭原则</h3><p>开闭原则 (OCP) 是指软件中的对象对于修改应该是封闭的，对于扩展应该是开放的。</p><blockquote><p>如果一个类为了实现新的功能不断的对类中的原有代码进行修改和增加，不仅可能引入 Bug，还有可能会导致类越来越庞大，比如一个图片的缓存类需要实现内存缓存、SD 卡缓存、两种方式混合的缓存方法，在图片显示类中需要自由选择何种方式进行缓存显示。比较好的一种方式是：由于三种缓存方式实际上基本功能一致，所以可以定义一个接口，然后在图片显示类中义一个接口用于指向三个类实例化的对象，那么当需要采用哪种方式去进行缓存的时候，只需要使用 set 方法进行依赖注入将接口指向相应方式的对象即可，并且如果要实现其它不同的缓存方式只需要对接口进行实现即可。这样实现的代码耦合性弱扩展性强。</p></blockquote><h3 id="里氏替换原则">里氏替换原则</h3><p>里氏替换原则是指所有引用基类的地方必须能透明地使用其子类的对象</p><blockquote><p>一个基类的子类拥有基类的属性和方法（私有的除外），所以在大多数情况下基类能干的子类都能做，这样可以保证很好的扩展性，因为可以在基类的基础上进行扩展实现不同功能的子类。因此里氏替换原则有利于提高扩展性，同时为开闭原则提供了保障。</p></blockquote><h3 id="依赖倒置原则">依赖倒置原则</h3><p>依赖倒置原则是用于解耦的一种方式，主要有以下几个关键点：</p><ol type="1"><li>高层模块不应该依赖底层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ol><blockquote><p>第一点是指当高层的模块使用底层的模块时候，不应该直接使用底层模块类的具体对象，而应该使用其接口或者是抽象类，这样可以保证其扩展性，也就是说高层模块与底层模块之间应该通过接口发生联系，而不应该存在直接关联。</p></blockquote><h3 id="接口隔离原则">接口隔离原则</h3><p>接口隔离原则是指类间的关系应该建立在最小的接口上</p><blockquote><p>最小的接口实际上就是抽象的一种表达，一个接口下面可能可能会实现很多种接口，或者是很多层级接口，要对这些接口相同的功能部分进行操作的时候只需要对最顶层的接口操作即可，譬如当关闭输入输出流的时候，Java 中有很多种流，字节流、字符流、缓冲流。这个时候为了减少依赖、耦合性以及增加扩展性，我们只需要利用 Cloaseable 接口指向各种流的对象进行关闭操作即可。</p></blockquote><h3 id="迪米特原则">迪米特原则</h3><p>迪米特原则是指一个对象应该对其它对象有最少的了解</p><blockquote><p>一个类应该尽可能少的利用到其它类完成相同的任务，这样可以降低耦合性</p></blockquote><h2 id="单例模式">单例模式</h2><h3 id="定义">定义</h3><p>所谓单例也就是说在一个类在系统中只存在一个实例，并且可以自行实例化向系统提供这个实例</p><h3 id="使用场景">使用场景</h3><p>适用于某个类有且仅有一个对象的场景，避免创建多个对象消耗过多的资源。</p><blockquote><ol type="1"><li><p>构造函数不对外开放，一般为 private</p></li><li><p>通过一个静态方法或者枚举返回单例类对象</p></li><li><p>确保单例类对象有且只有一个，尤其是在多线程环境下</p></li><li><p>确保单例类对象在反序列化时不会重新构建对象</p></li></ol><p>也即是说单例模式的对象必须由该类的静态方法进行实例化和提供，并且不能出现多个对象。</p></blockquote><h3 id="优缺点">优缺点</h3><ol type="1"><li>优点<ul><li>单例模式在内存中只存在一个实例，减少了内存的开支。</li><li>减少了系统的性能开销，当一个对象的产生需要较多的资源的时候，这个时候可以通过产生一个单例对象，然后永驻内存来解决。</li><li>单例模式可以避免对资源的多重占用。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问</li></ul></li><li>缺点<ul><li><strong>单例模式一般没有接口，扩展很困难。</strong></li><li><strong>单例对象如果持有 Context，那么很容易引发内存泄漏，此时传递给单例对象的 Context 最好是 Application Context</strong></li></ul></li></ol><h3 id="常用的实现方式">常用的实现方式</h3><ol type="1"><li><p>饿汉模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEO</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> CEO sCeo = <span class="keyword">new</span> CEO();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">CEO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CEO <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sCeo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该种方式实现的单例模式当类被加载的时候就会初始化一个 CEO 对象，然后外部可以通过 newInstance 静态方法进行获取。</p><p>由于单例模式需要类能够自行进行实例化，所以返回值一定是类变量以及通过静态方法进行返回。</p></blockquote></li><li><p>懒汉模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sSingleInstance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleInstance <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (sSingleInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">          sSingleInstance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sSingleInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>采用懒汉模式实现的单例模式可以在使用的时候才将对象实例化，但是由于每次调用 newInstance 方法的时候都会进行同步（比不需要同步的慢 100 倍），所以造成了不必要的同步开销，不建议使用。</p></blockquote></li><li><p>Double Check Lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sSingleInstance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (sSingleInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (SingleInstance.class) &#123;</span><br><span class="line">              <span class="keyword">if</span> (sSingleInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  sSingleInstance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sSingleInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一次的判断避免了在对象非空情况下进行同步导致不必要开销的问题，第二次判断是由于可能存在线程 A，B 同时判断了对象为空，然后依次进入同步块中，如果这个时候不进行判断则可能导致创建出两个对象出来，所以需要进行第二次判断。</p><p>这个模式存在的一个问题是 mSingleInstance = new SingleInstance() 不是原子操作，其分为三个部分：给实例对象分配内存；调用构造函数，初始化成员字段；将实例对象指向分配的内存空间。并且后两步的执行顺序是不确定的，所以可能出现 A 线程执行完第三步，没有执行完第二步的情况下，程序切换至 B 线程，B 线程判断当前对象非空取走对象，但由于对象的成员字段没有初始化完成，所以可能出现错误。</p><p>解决办法是在 sInstance 前加上 volatile 关键字。</p></blockquote></li><li><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> SingleHolder.sSingleInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleHolder</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleInstance sSingleInstance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>采用这种方式实现的单例模式很好的避免了 DCL 中可能出现的问题，由于内部类只有在使用它的成员以及方法的时候才会进行载入，所以可以做到使用的时候才实例化对象，而且能够确保线程安全。</p></blockquote></li><li><p>枚举单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;do sth.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在任何情况下枚举实例都是一个单例，而且创建过程是线程安全的。</p></blockquote></li><li><p>容器实现单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; objectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!objectMap.containsKey(key)) &#123;</span><br><span class="line">          objectMap.put(key, instance);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> objectMap.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>采用容器实现的单例模式可以对多种对象的单例进行管理，例如 Android 当中的 getSystemService 就是这样实现的单例模式。</p></blockquote></li></ol><h2 id="总结">总结</h2><ol type="1"><li><p>前四种方式实现的单例模式存在在反序列化（反射执行无参构造函数）的情况下可能会重新创建一个对象，为了避免这种情况的发生，我们需要重写 readResolve 方法，这样在进行反序列化的时候就会执行这个方法获取对象实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span><span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单例模式的核心在于将构造函数进行私有化，并且通过一个静态方法返回唯一的对象实例，在这个获取的过程当中需要保证<strong>线程安全、防止反序列化</strong>导致生成实例对象等问题。</p></li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;面向对象的六大原则&quot;&gt;面向对象的六大原则&lt;/h2&gt;
&lt;h3 id=&quot;单一职责原则&quot;&gt;单一职责原则&lt;/h3&gt;
&lt;p&gt;单一职责原则 (SRP) 是指就一个类而言，应该仅有一个引起它变化的原因&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单而言就是一个类应该只有一项职责，而不是具有多项职责，比如一个类既负责图片缓存的处理同时还负责显示图片，实际上应该拆分成两个类，一个类负责图片的缓存，另外一个类负责图片显示。如果一个类兼具太多的职责不仅导致了耦合性，而且在一个职责发生变化的时候还可能削弱其它的职责功能。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Reading Notes" scheme="https://www.ikroal.cn/categories/Reading-Notes/"/>
    
    
    <category term="Design Pattern" scheme="https://www.ikroal.cn/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义控件之百分比圆环</title>
    <link href="https://www.ikroal.cn/posts/a4343d1d.html"/>
    <id>https://www.ikroal.cn/posts/a4343d1d.html</id>
    <published>2017-09-10T01:01:22.000Z</published>
    <updated>2021-12-24T05:57:00.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近做一个简单的测试 APP 的时候需要将手机的存储空间使用情况显示出来，刚好看见 360 清理大师的存储空间是以百分比圆环的方式实现的，所以大致模仿了一下它的实现过程。<span id="more"></span></p><h2 id="效果图">效果图</h2><p>首先放上效果图，然后我们再根据效果图进行分析 <img src="https://raw.githubusercontent.com/ikroal/blog-images/master/ring-origin-result.png"></p><h2 id="实现思路">实现思路</h2><p>从上图我们可以看到，绘制一个这样的百分比圆环主要有涉及到三个元素：</p><ol type="1"><li>背景空心圆：代表着总的进度</li><li>圆弧：代表着当前进度</li><li>文字：需要居中，表示具体的进度</li></ol><p>在了解到涉及到的元素之后，我们还需要了解绘制各个元素需要哪些参数，由于绘制都通过 onDraw 方法中的 canvas 对象，所以我们可以通过 canvas 对象的方法去确定所需要的参数。</p><ul><li>绘制圆：查看 drawCircle 可以知道总共需要四个参数：<strong>圆心 X、Y 坐标、半径长度以及画笔 Paint</strong>；</li><li>绘制圆弧：查看 drawArc 可以知道总共需要四个参数：<strong>Recf、圆弧的起始角度、从起始角度顺时针扫过的角度以及必须的 Paint</strong>，这里的 Recf 确定了一个矩形区域，然后确定了一个内接椭圆，而圆弧的绘制实际上是在椭圆上面进行截取；</li><li>绘制文本：查看 drawText 可以知道，需要四个参数：<strong>文本内容、进行绘制的 X、Y 坐标点以及Paint</strong>。</li></ul><h2 id="实现过程">实现过程</h2><p>在了解了绘制元素所需要的参数，这个时候就可以一步步进行绘制了：</p><ol type="1"><li><p>首先是绘制圆，这里我们定义了四个参数分别表示圆心 X，Y 的坐标、半径以及绘制所需要的画笔，然后对这些参数进行初始化，最终在 onDraw 进行绘制。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RingPercentDemo</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCircleX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCircleY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRadius;</span><br><span class="line">    <span class="keyword">private</span> Paint mCirclePaint;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RingPercentDemo</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RingPercentDemo</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mCircleX = <span class="number">300</span>;</span><br><span class="line">        mCircleY = <span class="number">300</span>;</span><br><span class="line">        mRadius = <span class="number">260</span>;</span><br><span class="line">        mCirclePaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mCirclePaint.setColor(Color.BLUE);</span><br><span class="line">        mCirclePaint.setStrokeWidth(<span class="number">10</span>);</span><br><span class="line">        mCirclePaint.setStyle(Style.STROKE); <span class="comment">//绘制空心圆所以不需要填充</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        canvas.drawCircle(mCircleX, mCircleY, mRadius, mCirclePaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>接下来是绘制圆环，从效果图上可以看出来，圆环实际上是在圆上截取一段圆弧表示，所以绘制圆环的矩形区域可以确定下来，在确定了矩形区域之后只需要自己设定起始的角度和扫过的角度即可以绘制出在圆上的圆弧。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RingPercentDemo</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> RectF mRecF;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mStartAngle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mSweepAngle;</span><br><span class="line">    <span class="keyword">private</span> Paint mRingPaint;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RingPercentDemo</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RingPercentDemo</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mRecF = <span class="keyword">new</span> RectF(mCircleX - mRadius, mCircleY - mRadius,</span><br><span class="line">            mCircleX + mRadius, mCircleY + mRadius);</span><br><span class="line">        mStartAngle = -<span class="number">90f</span>;</span><br><span class="line">        mSweepAngle = <span class="number">120f</span>;</span><br><span class="line">        mRingPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mRingPaint.setColor(Color.RED);</span><br><span class="line">        mRingPaint.setStrokeWidth(<span class="number">20</span>);</span><br><span class="line">        mRingPaint.setStyle(Style.STROKE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        canvas.drawArc(mRecF, mStartAngle, mSweepAngle,</span><br><span class="line">            <span class="keyword">false</span>, mRingPaint); <span class="comment">//设置为 false 不与中心点进行连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>最后是绘制文本，由于要绘制在圆的中心，所以文本的坐标我们首先设置为圆的中心，然后绘制的风格选为 Align.CENTER，这样文本将以设定的坐标点向两边延伸保证了 X 处于中心位置。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RingPercentDemo</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTextX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTextY;</span><br><span class="line">    <span class="keyword">private</span> Paint mTextPaint;</span><br><span class="line">    <span class="keyword">private</span> String mTextStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RingPercentDemo</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RingPercentDemo</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mTextPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mTextPaint.setColor(Color.BLACK);</span><br><span class="line">        mTextPaint.setStyle(Style.FILL);</span><br><span class="line">        mTextPaint.setTextSize(<span class="number">40</span>);</span><br><span class="line">        mTextPaint.setTextAlign(Align.CENTER);</span><br><span class="line">        mTextPaint.setTextSize(mRadius / <span class="number">2</span>);</span><br><span class="line">        mTextX = mCircleX;</span><br><span class="line">        mTextY = mCircleY;</span><br><span class="line">        mTextStr = <span class="string">&quot;33%&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        canvas.drawText(mTextStr, mTextX, mTextY, mTextPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 实际效果图： <img src="https://i.imgur.com/9ZYvei1.jpg" alt="tips1"> 这个时候我们能够发现文本实质上不在中心位置，这是为什么呢？因为我们在设定的坐标是用于确定绘制的<strong>基准线</strong>而不是绘制的中心点，所以自然文本不可能绘制在正中心，具体可以借用下图来进行描述： <img src="https://i.imgur.com/vOewNzN.jpg"> 从这就可以很明显的看到，文本的中心和设定的坐标之间是存在一个偏移量的，所以为了使文本处于真正的中心，我们需要计算得到这个偏移量，然后将之前设定的基准线下移。在计算偏移量之前首先需要了解字体是如何进行测量的，具体如下图所示： <img src="https://i.imgur.com/xwZqHv9.jpg"> 其中 Top 表示基准线以上可绘制的最大距离（负数），Bottom 表示基准线以下可绘制的最大距离（正数），Ascent 表示基准线以上推荐的可绘制的距离，Descent 表示基准线以下推荐的可绘制的距离。 了解完这一切之后如何计算偏移量就很简单了，通过 FontMetrics 获取 Bottom 和 Top，然后通过 ((Bottom - Top) / 2) - Bottom 最终取得偏移量。代码做如下修改：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RingPercentDemo</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTextX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTextY;</span><br><span class="line">    <span class="keyword">private</span> Paint mTextPaint;</span><br><span class="line">    <span class="keyword">private</span> String mTextStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RingPercentDemo</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RingPercentDemo</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        FontMetrics fontMetrics = mTextPaint.getFontMetrics();</span><br><span class="line">        <span class="keyword">float</span> offsetY = ((fontMetrics.bottom - fontMetrics.top) / <span class="number">2</span>) - fontMetrics.bottom;</span><br><span class="line">        mTextY = (<span class="keyword">int</span>) (mCircleY + offsetY);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后的效果： <img src="https://i.imgur.com/M9hzVs4.jpg" alt="tip2"></p><h2 id="改进">改进</h2><h3 id="自定义属性">自定义属性</h3><p>经过上述过程，虽然圆环百分比的效果已经实现，但是跟效果图中的还是差的很远，而且也不能够灵活，所以我们需要借助自定义属性去改进我们的圆环。</p><ol type="1"><li><p>首先需要在 values 文件夹下创建 attrs.xml 文件在里面声明我们需要定义的属性： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;RingPercentDemo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;radius&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">&quot;color&quot;</span> <span class="attr">name</span>=<span class="string">&quot;circleColor&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;circleStrokeWidth&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;circleStyle&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">&quot;color&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ringColor&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ringStrokeWidth&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;startAngle&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sweepAngle&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rate&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li><li><p>然后在构造函数获取到自定义的属性的属性值</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RingPercentDemo</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(</span><br><span class="line">            attrs, R.styleable.RingPercentDemo);</span><br><span class="line"></span><br><span class="line">        mRadius = typedArray.getInteger(R.styleable.RingPercentDemo_radius, <span class="number">60</span>);</span><br><span class="line">        mCircleColor = typedArray.getColor(</span><br><span class="line">            R.styleable.RingPercentDemo_circleColor, Color.GREEN);</span><br><span class="line">        mCircleStrokeWidth = typedArray.getInteger(</span><br><span class="line">            R.styleable.RingPercentDemo_circleStrokeWidth, <span class="number">5</span>);</span><br><span class="line">        mCircleStyle = typedArray.getInteger(</span><br><span class="line">            R.styleable.RingPercentDemo_circleStyle, <span class="number">0</span>);</span><br><span class="line">        mRingColor = typedArray.getColor(</span><br><span class="line">            R.styleable.RingPercentDemo_ringColor, Color.RED);</span><br><span class="line">        mRingStrokeWidth = typedArray.getColor(</span><br><span class="line">            R.styleable.RingPercentDemo_ringStrokeWidth, <span class="number">10</span>);</span><br><span class="line">        mStartAngle = typedArray.getInteger(</span><br><span class="line">            R.styleable.RingPercentDemo_startAngle, -<span class="number">90</span>);</span><br><span class="line">        mSweepAngle = typedArray.getInteger(</span><br><span class="line">            R.styleable.RingPercentDemo_sweepAngle, <span class="number">90</span>);</span><br><span class="line">        mRate = typedArray.getInteger(R.styleable.RingPercentDemo_rate, <span class="number">100</span>);</span><br><span class="line">        typedArray.recycle();</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></li><li><p>在获取到这些属性值之后只需要给对应的 Paint 和变量设置对应的值即可。</p></li></ol><h3 id="固定圆心和动态变化">固定圆心和动态变化</h3><ol type="1"><li><p>圆心的位置我们希望能够一直处于 View 的中心，所以需要重写 onMeasure 方法，在 onMeasure 方法通过获取 View 的高度和宽度得到了 View 的中心点坐标，从而使得圆心一直在 View 的中心。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(measuse(widthMeasureSpec), measuse(heightMeasureSpec));</span><br><span class="line"></span><br><span class="line">    mCircleX = getMeasuredWidth() / <span class="number">2</span>;</span><br><span class="line">    mCircleY = getMeasuredHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断设定的圆是否超出显示范围，如果超出需要缩小</span></span><br><span class="line">    <span class="keyword">if</span> (mCircleX &lt; mRadius) &#123;</span><br><span class="line">        mRadius = mCircleX - mCircleStrokeWidth - mRingStrokeWidth;</span><br><span class="line">        mTextPaint.setTextSize(mRadius / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCircleY &lt; mRadius) &#123;</span><br><span class="line">        mRadius = mCircleY - mCircleStrokeWidth - mRingStrokeWidth;</span><br><span class="line">        mTextPaint.setTextSize(mRadius / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FontMetrics fontMetrics = mTextPaint.getFontMetrics();</span><br><span class="line">    <span class="keyword">int</span> offsetY = (<span class="keyword">int</span>) (((fontMetrics.bottom - fontMetrics.top)) / <span class="number">2</span> - fontMetrics.bottom);</span><br><span class="line">    mTextX = mCircleX;</span><br><span class="line">    mTextY = mCircleY + offsetY;</span><br><span class="line"></span><br><span class="line">    mRecF = <span class="keyword">new</span> RectF(mCircleX - mRadius, mCircleY - mRadius,</span><br><span class="line">        mCircleX + mRadius, mCircleY + mRadius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>在解决了圆心的问题之后，还需要为圆弧提供动态变化的效果，这里可以通过不断重绘达成目标。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    canvas.drawCircle(mCircleX, mCircleY, mRadius, mCirclePaint);</span><br><span class="line">    canvas.drawArc(mRecF, mStartAngle, mCurrentAngle, <span class="keyword">false</span>, mRingPaint);</span><br><span class="line">    canvas.drawText(mTextStr, mTextX, mTextY, mTextPaint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCurrentAngle &lt; mSweepAngle) &#123;</span><br><span class="line">        mCurrentAngle += <span class="number">3.6</span>;</span><br><span class="line">        mTextStr = mCurrentAngle * <span class="number">100</span> / <span class="number">360</span> + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">        postInvalidateDelayed(mRate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZpcnN0ZHJlYW0xMC9SaW5nUGVyY2VudA==">相关测试工程<i class="fa fa-external-link-alt"></i></span></p><h2 id="总结">总结</h2><p>涉及到 View 的绘制需要对元素进行拆分，然后进行单独处理，这样思路会比较清晰</p><h2 id="thanks">Thanks</h2><ol type="1"><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9zbGdrYWlmYS9wLzcxMDEyOTcuaHRtbA==">android canvas drawText()文字居中<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnVnb25nYWhvdTExMC9hcnRpY2xlL2RldGFpbHMvNDkxNTkxODk=">Android自定义控件之百分比圆环进度条<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近做一个简单的测试 APP 的时候需要将手机的存储空间使用情况显示出来，刚好看见 360 清理大师的存储空间是以百分比圆环的方式实现的，所以大致模仿了一下它的实现过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Archived" scheme="https://www.ikroal.cn/categories/Archived/"/>
    
    
    <category term="Android" scheme="https://www.ikroal.cn/tags/Android/"/>
    
    <category term="Custom View" scheme="https://www.ikroal.cn/tags/Custom-View/"/>
    
  </entry>
  
  <entry>
    <title>Android 进阶之 Binder 浅解</title>
    <link href="https://www.ikroal.cn/posts/c234d605.html"/>
    <id>https://www.ikroal.cn/posts/c234d605.html</id>
    <published>2017-09-03T13:43:27.000Z</published>
    <updated>2021-12-24T05:57:00.084Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是-binder">什么是 Binder</h4><p>Binder 是 Android 中一种跨进程通信（IPC）方式。<span id="more"></span> #### Binder 的原理 Binder通信采用C/S架构，从组件视角来说，包含 Client、Server、ServiceManager 以及 binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。架构图如下所示： <img src="https://raw.githubusercontent.com/ikroal/blog-images/master/binder-principle.png"></p><ul><li>此处的 Service Manager 是指 Native 层的 ServiceManager（C++）</li><li>注册服务(addService)：Server 进程要先注册 Service 到 ServiceManager。该过程：Server 是客户端，ServiceManager 是服务端。</li><li>获取服务(getService)：Client 进程使用某个 Service 前，须先向 ServiceManager 中获取相应的 Service。该过程：Client 是客户端，ServiceManager 是服务端。</li><li>使用服务：Client 根据得到的 Service 信息建立与 Service 所在的 Server 进程通信的通路，然后就可以直接与 Service 交互。该过程：Client 是客户端，Server 是服务端。</li></ul><h4 id="binder-的结构">Binder 的结构</h4><p>在学习 Binder 的结构的时候，可以利用 AIDL 去生成 Binder，这里我们首先需要创建一个实现了 Parcelable 接口的 Book 类，然后在 main 文件夹下创建 AIDL 文件夹，分别创建 Book.aidl、IBookManager.aidl。三个文件的代码分别如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Book.java</span></span><br><span class="line"><span class="keyword">package</span> com.rookieyang.aidltest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by firstdream on 2017/9/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mBookId;</span><br><span class="line">    <span class="keyword">private</span> String mBookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> mBookId, String mBookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBookId = mBookId;</span><br><span class="line">        <span class="keyword">this</span>.mBookName = mBookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel parcel, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        parcel.writeInt(mBookId);</span><br><span class="line">        parcel.writeString(mBookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel parcel)</span> </span>&#123;</span><br><span class="line">            Book book = <span class="keyword">new</span> Book(parcel.readInt(), parcel.readString());</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.rookieyang.aidltest;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line">parcelable Book;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.rookieyang.aidltest;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要导入 Book 类</span></span><br><span class="line"><span class="keyword">import</span> com.rookieyang.aidltest.Book;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在经过上述的过程之后，点击编译即可生成 Binder 文件，以 IBookManager.aidl 生成的 IBookManager.java 为例， IBookManager.java 中定义了一个继承自 IInterface 的 IBookManager 接口，在 IBookManager 内包含了继承自 Binder 实现了 IBookManager 接口的内部类 Stub 和 实现了 IBookManager 接口的 Stub 的内部类 Proxy。整体结构如下图所示： <img src="https://raw.githubusercontent.com/ikroal/blog-images/master/IBookManager.png"> 下面针对 IBookManager.java 进行具体的分析：</p><ul><li>IBookManager 接口，这个接口与在 IBookManager.aidl 中一致<ul><li>getBookList()</li><li>addBook(Book book)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Stub 类<ul><li>DESCRIPTOR</li><li>Binder 的唯一标识，一般用当前 Binder 的类名表示</li><li>TRANSACTION_getBookList 和 TRANSACTION_addBook</li><li>两个id用于标识在transact过程中客户端所请求的到底是哪个方法</li><li>asInterface(IBinder obj)</li><li>用于将服务端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的 Stub 对象本身，否则返回的是系统封装后的 Stub.proxy 对象。</li><li>asBinder</li><li>此方法用于返回当前 Binder 对象。</li><li>onTransact</li><li>这个方法运行在服务端中的 Binder 线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。</li><li>服务端通过 code 可以确定客户端所请求的目标方法是什么，接着从 data 中取出目标方法所需的参数（如果目标方法有参数的话），然后执行目标方法。当目标方法执行完毕后，就向 reply 中写入返回值（如果目标方法有返回值的话），onTransact 方法的执行过程就是这样的。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTOR = <span class="string">&quot;com.rookieyang.binderdemo.IBookManager&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cast an IBinder object into an IBookManager interface,</span></span><br><span class="line"><span class="comment">     * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBookManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> IBookManager))) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((IBookManager) iin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IBookManager.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                List&lt;Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                reply.writeTypedList(_result);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                Book _arg0;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                    <span class="comment">//反序列化</span></span><br><span class="line">                    _arg0 = Book.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Proxy 类<ul><li>getBookList</li><li>这个方法运行在客户端，当客户端远程调用此方法时，它的内部实现是这样的：首先创建该方法所需要的输入型 Parcel 对象 _data 、输出型 Parcel 对象 _reply 和返回值对象 List；然后把该方法的参数信息写入 _data 中（如果有参数的话）；接着调用 transact 方法来发起 RPC（远程过程调用）请求，同时当前线程挂起；然后服务端的 onTransact 方法会被调用，直到 RPC 过程返回后，当前线程继续执行，并从 _reply 中取出 RPC 过程的返回结果；最后返回 _reply 中的数据。</li><li>addBook</li><li>这个方法运行在客户端，它的执行过程和 getBookList 是一样的，addBook 没有返回值，所以它不需要从 _reply 中取出返回值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder mRemote;</span><br><span class="line"></span><br><span class="line">    Proxy(IBinder remote) &#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Parcel _data = Parcel.obtain();</span><br><span class="line">        Parcel _reply = Parcel.obtain();</span><br><span class="line">        java.util.List&lt;Book&gt; _result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">            _result = _reply.createTypedArrayList(Book.CREATOR);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Parcel _data = Parcel.obtain();</span><br><span class="line">        Parcel _reply = Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _data.writeInt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="binder-的工作机制">Binder 的工作机制</h4><p><img src="https://raw.githubusercontent.com/ikroal/blog-images/master/binder-execute.png"> &gt; 以上述为例，客户端调用 getBookList 方法时，在方法内部定义了 Parcel 对象，然后通过调用 transact 发起远程请求，服务器端接收到后调用 onTransact 方法，根据传递过来的 Code 进行相应的处理，将结果写入 Parcel 对象当中，处理完成之后在 客户端的 transact 将结果取出来并返回。</p><h4 id="binder-使用的一些注意点">Binder 使用的一些注意点</h4><p>Binder 一般和 Service 配合使用，作为 bindService 执行时的返回，最后在 ServiceConnect 当中获取返回的 Binder： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ServiceConnection serviceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</span><br><span class="line">        mCalcAidl = ICalcAIDL.Stub.asInterface(iBinder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line">        mCalcAidl = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> &gt; 不同进程时返回的 iBinder 是 ICalcAIDL.Stub.Proxy，而相同进程中则是 ICalcAIDL.Stub。是返回 Stub 还是返回 Proxy 在底层已经做了判断，不是在 onServiceConnected 方法中进行的判断</p><p>在服务中使用时，定义的 AIDL 文件包名必须相同，不然将无法找到对应的 AIDL，从而导致无法进行通信，并且使用时需要通过 ICalcAIDL.Stub 实现在 AIDL 中定义的接口，从而为客户端提供服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ICalcAIDL.Stub mBinder = <span class="keyword">new</span> Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><blockquote><p>粗略的说，Client 通过 Binder 当中的 Proxy 进行了 IPC 的请求，而 Server 则通过 Stub 当中的 onTransact 对跨进程请求进行处理，之所以能进行跨进程请求的原因在于底层能够通过可序列化的数据，上述的 Book 类实现了 Parcelable 接口，而基本类型是被看作可序列化的，所以这些数据在底层能够进行传输，自然就可以通过 Binder 完成 IPC。</p></blockquote><hr><h4 id="参考">参考</h4><ol type="1"><li>Android 开发艺术探索-IPC 机制</li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1NzkxL2FydGljbGUvZGV0YWlscy8zODQ2MTA3OS8=">Android aidl Binder框架浅析<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlaXNodS5tZS8yMDE2LzAxLzEyL2JpbmRlci1pbmRleC1mb3ItbmV3ZXIv">Binder学习指南<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是-binder&quot;&gt;什么是 Binder&lt;/h4&gt;
&lt;p&gt;Binder 是 Android 中一种跨进程通信（IPC）方式。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.ikroal.cn/categories/Android/"/>
    
    
    <category term="Android IPC" scheme="https://www.ikroal.cn/tags/Android-IPC/"/>
    
  </entry>
  
  <entry>
    <title>Android 基础之 Service</title>
    <link href="https://www.ikroal.cn/posts/cbbb364f.html"/>
    <id>https://www.ikroal.cn/posts/cbbb364f.html</id>
    <published>2017-08-27T10:04:55.000Z</published>
    <updated>2021-12-24T05:57:00.073Z</updated>
    
    <content type="html"><![CDATA[<h4 id="service-的含义及作用">Service 的含义及作用</h4><p>Service 是一个可以在后台执行长时间运行操作而不需要提供用户界面的应用组件，也就是说 Service 是为了去处理那些不需要和用户交互但又耗时的操作。但是如果 Service 只是为了执行那些耗时的操作的话，其实只用线程也可以达到同样的目的，之所以需要单独用 Service 来进行实现的原因在于 Service 相较之线程而言优先级比较高，并且 Service 通过绑定启动的时候是可控的，如果系统不是极端不够用，一般而言是不会杀死 Service，但是线程可能存在被系统回收的可能性，所以 Service 的可靠性要比线程高。<span id="more"></span> 另外关于 Service，官网上还有如下的提示： &gt; 服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互</p><h4 id="service-的生命周期">Service 的生命周期</h4><p>Service 的生命周期主要和服务的使用方式有关，使用服务主要分为启动和绑定两种方式，其生命周期如下图所示： <img src="https://raw.githubusercontent.com/ikroal/blog-images/master/service-life-cycle.png"></p><h4 id="service-的基本使用">Service 的基本使用</h4><ol type="1"><li>创建服务 系统提供了一个 Service 抽象类，所以我们自己实现一个继承自 Service 的类，然后在 AndroidManifest.xml 注册即可。</li><li>运行服务 运行服务主要方法有两种，一种是调用 startService()，第二种则是 bindService()。实际上这两个方法可以同时调用。</li><li>服务中处理事件 startService 启动服务，事件的处理一般在服务的 onStartCommand 方法进行的，bindService 绑定服务之后，将会在 ServiceConnection 的 onServiceConnected 中返回一个 Binder 对象，利用返回的 Binder 对象可以调用相关的事件处理方法。</li><li>停止服务 服务的运行条件是服务被绑定或者被启动，所以想让服务不运行则需要破坏这两个条件，可以通过调用 stopService 和 unbindService 实现。</li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;service-的含义及作用&quot;&gt;Service 的含义及作用&lt;/h4&gt;
&lt;p&gt;Service 是一个可以在后台执行长时间运行操作而不需要提供用户界面的应用组件，也就是说 Service 是为了去处理那些不需要和用户交互但又耗时的操作。但是如果 Service 只是为了执行那些耗时的操作的话，其实只用线程也可以达到同样的目的，之所以需要单独用 Service 来进行实现的原因在于 Service 相较之线程而言优先级比较高，并且 Service 通过绑定启动的时候是可控的，如果系统不是极端不够用，一般而言是不会杀死 Service，但是线程可能存在被系统回收的可能性，所以 Service 的可靠性要比线程高。&lt;/p&gt;</summary>
    
    
    
    <category term="Archived" scheme="https://www.ikroal.cn/categories/Archived/"/>
    
    
    <category term="Android Service" scheme="https://www.ikroal.cn/tags/Android-Service/"/>
    
  </entry>
  
</feed>
